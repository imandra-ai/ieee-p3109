[@@@import "p3109.iml"]

[@@@import "math.iml"]

open Math

type t = P3109.Float8.t
(* We re-use the type definitions of P3109 for convenience, but none of it's functions. *)

let is_nan (x : t) =
  x.b7 = true && x.b6 = false && x.b5 = false && x.b4 = false && x.b3 = false
  && x.b2 = false && x.b1 = false && x.b0 = false

let is_ninf (x : t) =
  x.b7 = true && x.b6 = true && x.b5 = true && x.b4 = true && x.b3 = true
  && x.b2 = true && x.b1 = true && x.b0 = true

let is_pinf (x : t) =
  x.b7 = false && x.b6 = true && x.b5 = true && x.b4 = true && x.b3 = true
  && x.b2 = true && x.b1 = true && x.b0 = true

let is_zero (x : t) =
  x.b7 = false && x.b6 = false && x.b5 = false && x.b4 = false && x.b3 = false
  && x.b2 = false && x.b1 = false && x.b0 = false

let precision (fmt : P3109.Format.t) =
  let open P3109.Format in
  match fmt with
  | B8P1 -> 1
  | B8P2 -> 2
  | B8P3 -> 3
  | B8P4 -> 4
  | B8P5 -> 5
  | B8P6 -> 6
  | B8P7 -> 7

let get_format_parameters (fmt : P3109.Format.t) : int * int * real =
  let precision : int = precision fmt in
  let emax : int = ipow2 (8 - precision - 1) - 1 in
  let bias : int = emax + 1 in
  let max : real = pow2 emax *. (2. -. pow2 (2 - precision)) in
  precision, bias, max

(** Convert int [i] to a [t] (bitwise; lowest 8 bits only, rest ignored) *)
let of_int_bitwise (i : int) : t =
  {
    b0 = i mod 2 <> 0;
    b1 = i / 2 mod 2 <> 0;
    b2 = i / 4 mod 2 <> 0;
    b3 = i / 8 mod 2 <> 0;
    b4 = i / 16 mod 2 <> 0;
    b5 = i / 32 mod 2 <> 0;
    b6 = i / 64 mod 2 <> 0;
    b7 = i / 128 mod 2 <> 0;
  }

(** Bitwise and of two float8s *)
let bitwise_and (x : t) (y : t) : t =
  {
    b7 = x.b7 && y.b7;
    b6 = x.b6 && y.b6;
    b5 = x.b5 && y.b5;
    b4 = x.b4 && y.b4;
    b3 = x.b3 && y.b3;
    b2 = x.b2 && y.b2;
    b1 = x.b1 && y.b1;
    b0 = x.b0 && y.b0;
  }

(** Bitwise or of two float8s *)
let bitwise_or (x : t) (y : t) : t =
  {
    b7 = x.b7 || y.b7;
    b6 = x.b6 || y.b6;
    b5 = x.b5 || y.b5;
    b4 = x.b4 || y.b4;
    b3 = x.b3 || y.b3;
    b2 = x.b2 || y.b2;
    b1 = x.b1 || y.b1;
    b0 = x.b0 || y.b0;
  }

(** Bitwise or of three float8s *)
let bitwise_or3 (x : t) (y : t) (z : t) : t = bitwise_or (bitwise_or x y) z

(** Shift float8 to the right *)
let rec bit_shift_right (x : t) (i : int) : t =
  let open P3109.Float8 in
  if i <= 0 then
    x
  else (
    let shift1 (x : t) =
      {
        b7 = false;
        b6 = x.b7;
        b5 = x.b6;
        b4 = x.b5;
        b3 = x.b4;
        b2 = x.b3;
        b1 = x.b2;
        b0 = x.b1;
      }
    in
    shift1 (bit_shift_right x (i - 1))
  )

(** Shift float8 to the left *)
let rec bit_shift_left (x : t) (i : int) : t =
  let open P3109.Float8 in
  if i <= 0 then
    x
  else (
    let shift1 (x : t) =
      {
        b7 = x.b6;
        b6 = x.b5;
        b5 = x.b4;
        b4 = x.b3;
        b3 = x.b2;
        b2 = x.b1;
        b1 = x.b0;
        b0 = false;
      }
    in
    shift1 (bit_shift_left x (i - 1))
  )

(** Convert float8 to int (bitwise) *)

let to_int_bitwise (x : t) : int =
    (if x.b0 then 1 else 0)
  + (if x.b1 then 2 else 0)
  + (if x.b2 then 4 else 0)
  + (if x.b3 then 8 else 0)
  + (if x.b4 then 16 else 0)
  + (if x.b5 then 32 else 0)
  + (if x.b6 then 64 else 0)
  + (if x.b7 then 128 else 0)
  [@@ocamlformat "disable"]

let sign (x : real) : real = Real.(if x < 0.0 then -1.0 else 1.0)
[@@ocamlformat "if-then-else=compact"]

(** Extended reals *)
module ExReal = struct
  type t =
    | NINF
    | PINF
    | R of real

  let zero = R 0.0

  let ( < ) (x : t) (y : t) : bool =
    match x, y with
    | NINF, NINF | PINF, PINF | PINF, NINF | PINF, R _ -> false
    | NINF, PINF | NINF, R _ -> true
    | R x, R y -> Real.(x < y)

  let ( < ) (x : t) (y : real) : bool =
    match x, y with
    | NINF, _ -> true
    | PINF, _ -> false
    | R x, _ -> x <. y

  let ( > ) (x : t) (y : real) : bool =
    match x, y with
    | NINF, _ -> false
    | PINF, _ -> true
    | R x, _ -> x >. y

  let max (x : t) (y : t) : t =
    match x, y with
    | NINF, NINF | PINF, PINF | PINF, NINF | PINF, R _ -> x
    | NINF, PINF | NINF, R _ -> y
    | R x, R y -> R (Real.max x y)

  let abs (x : t) : t =
    match x with
    | NINF | PINF -> x
    | R x -> R (Real.abs x)

  let floor (x : t) : t =
    let open Math in
    match x with
    | NINF | PINF -> x
    | R x -> R (Real.of_int (floor x))

  let is_finite (x : t) =
    match x with
    | NINF | PINF -> false
    | _ -> true

  let sign (x : t) : t =
    match x with
    | NINF -> R (-1.0)
    | PINF -> R 1.0
    | R x ->
      Real.(
        if x <. 0.0 then
          R (-1.0)
        else
          R 1.0)

  let mul (x : t) (y : t) : (t, string) Result.t =
    match x, y with
    | NINF, PINF | PINF, NINF -> Error "invalid"
    | NINF, NINF -> Ok NINF
    | PINF, PINF -> Ok PINF
    | NINF, R 0.0 -> Error "invalid"
    | PINF, R 0.0 -> Error "invalid"
    | R 0.0, NINF -> Error "invalid"
    | R 0.0, PINF -> Error "invalid"
    | NINF, R y when y <. 0.0 -> Ok NINF
    | PINF, R y when y >. 0.0 -> Ok PINF
    | R x, NINF when x <. 0.0 -> Ok NINF
    | R x, PINF when x >. 0.0 -> Ok PINF
    | NINF, R _ | PINF, R _ -> Error "invalid"
    | R _, NINF | R _, PINF -> Error "invalid"
    | R x, R y -> Ok (R (x *. y))

  let ( * ) (x : t) (y : t) : (t, string) Result.t = mul x y

  let neg (x : t) : t =
    match x with
    | NINF -> PINF
    | PINF -> NINF
    | R x -> R (-.x)

  let ( ~- ) (x : t) : t = neg x
end

(** Convert [x] (in [fmt]) to extended real *)
let to_extended_real (x : t) (fmt : P3109.Format.t) : ExReal.t =
  let open Math in
  (* Convert X (in Format) to extended real *)
  (* Cannot return a NaN, so must not be referenced with a NaN code *)
  if is_pinf x then
    PINF
  else if is_ninf x then
    NINF
  else (
    let precision, bias, _ = get_format_parameters fmt in

    let sign =
      if not (is_zero (bitwise_and x (of_int_bitwise 0x80))) then
        -1.0
      else
        1.0
    in
    let trailing_bits =
      to_int_bitwise
        (bitwise_and x (of_int_bitwise (ipow2 (precision - 1) - 1)))
    in
    let biased_exponent =
      to_int_bitwise
        (bit_shift_right (bitwise_and x (of_int_bitwise 0x7F)) (precision - 1))
    in

    if biased_exponent = 0 then
      R
        (sign
        *. (0.0 +. (Real.of_int trailing_bits *. pow2 (1 - precision)))
        *. pow2 (1 - bias))
    else
      R
        (sign
        *. (1.0 +. (Real.of_int trailing_bits *. pow2 (1 - precision)))
        *. pow2 (biased_exponent - bias))
  )

let encode (x : ExReal.t) (fmt : P3109.Format.t) : t =
  let open Math in
  let precision, bias, _ = get_format_parameters fmt in
  (* if x = NAN  then of_int_bitwise 0x80 *)
  (* Invalid; NAN not in ExReal *)
  match x with
  | ExReal.PINF -> of_int_bitwise 0x7f
  | ExReal.NINF -> of_int_bitwise 0xff
  | ExReal.R 0.0 -> of_int_bitwise 0x00
  | ExReal.R x ->
    let sign_bit : t =
      of_int_bitwise
        (if Real.(x < 0.0) then
           0x80
         else
           0x00)
    in
    let exponent : int = max (ilog2 (Real.to_int x)) (1 - bias) in
    let significand : real =
      Real.abs x *. pow2 (-exponent) *. pow2 (precision - 1)
    in
    (* [significand] is an integer, because [x] is a valid value in the format *)
    let significand : int = Real.to_int significand in
    let fsignificand : t = of_int_bitwise significand in
    let trailing_bits : t =
      bitwise_and fsignificand (of_int_bitwise (ipow2 (precision - 1) - 1))
    in

    if significand < ipow2 (precision - 1) then
      (* subnormal *)
      bitwise_or sign_bit fsignificand
    else (
      (* normal *)
      let biased_exponent = of_int_bitwise (exponent + bias) in
      bitwise_or3 sign_bit
        (bit_shift_left biased_exponent (precision - 1))
        trailing_bits
    )

(** Round to ([precision], [bias]) in reals *)
let round_to_precision (z : ExReal.t) (precision : int) (bias : int)
    (rnd : P3109.RoundingMode.t) : ExReal.t =
  let open P3109.RoundingMode in
  match z with
  | ExReal.NINF | ExReal.PINF -> z
  | ExReal.R 0.0 -> z
  | ExReal.R z ->
    let e : int = max (ilog2 (Real.to_int z)) (1 - bias) - precision + 1 in
    let m = Real.abs z *. pow2 (-e) in
    (* Round [m] to integer [i] according to [rnd]. Note [m] is absolute value so floor is toward 0. *)
    let i : int = floor m in
    let delta : real = Real.(m - Real.of_int i) in

    let i =
      if
        rnd = NearestTiesToEven
        && Real.(
             (delta > 0.5 || (delta = 0.5 && is_odd i))
             || (rnd = NearestTiesToAway && delta >= 0.5)
             || (rnd = TowardPositive && z > 0.0 && delta > 0.0)
             || (rnd = TowardNegative && z < 0.0 && delta > 0.0))
      then
        i + 1 (* Away from zero, as [m] is absolute value *)
      else
        i
    in
    (* Reconstruct from rounded [i] *)
    R Real.(sign z * Real.of_int i * pow2 e)

type overflow_behaviour =
  | OvfSat
  | Other

let to_binary_8 (z : ExReal.t) (result_format : P3109.Format.t)
    (ovf : overflow_behaviour) (rnd : P3109.RoundingMode.t) :
    (t, string) Result.t =
  let open ExReal in
  let open P3109.RoundingMode in
  let precision, bias, max = get_format_parameters result_format in

  let z = round_to_precision z precision bias rnd in

  (* Saturate according to [ovf] *)
  let z =
    if abs z > max then
      if
        ovf = OvfSat
        || is_finite z
           && (rnd = TowardZero
              || (rnd = TowardPositive && z < 0.0)
              || (rnd = TowardNegative && z > 0.0))
      then
        ExReal.sign z * R max
      else
        ExReal.sign z * PINF
    else
      Ok z
  in

  match z with
  | Error s -> Error s
  | Ok z -> Ok (encode z result_format)

let negate (x : t) (xformat : P3109.Format.t) : t =
  let open ExReal in
  if is_nan x then
    x
  else (
    let rx = to_extended_real x xformat in
    let rz = ~-rx in
    encode rz xformat
  )
