(** An attempt at making error propagation less prominent *)

let ( let* ) (x : ('a, 'e) Result.t) (f : ('a -> ('b, 'e) Result.t)) : ('b, 'e) Result.t =
  match x with
  | Ok x ->
    (match f x with
    | Ok y -> Ok y
    | Error e -> Error e)
  | Error e -> Error e
  [@@macro]

let rec extract_error (xs : ('a, 'e) Result.t list) : ('b, 'e) Result.t =
  match xs with
  | [] -> Ok []
  | x :: xs ->
    (match x with
    | Ok x ->
      (match extract_error xs with
      | Ok ys -> Ok (x :: ys)
      | Error e -> Error e
      )
    | Error e -> Error e)

let ( let@ ) (xs : ('a, 'e) Result.t list) (f : 'a list -> ('b, 'e) Result.t) : ('b, 'e) Result.t =
  match extract_error xs with
  | Ok ys -> f ys
  | Error e -> Error e
  [@@macro]

let (let*@) (x : (('a, 'e) Result.t list, 'e) Result.t) (f : 'a list -> ('b, 'e) Result.t) : ('b, 'e) Result.t =
  let* t = x in
  let@ r = t in
  f r

theorem exists_error_err (xs : ('a, 'b) Result.t list) =
  List.exists (fun x -> Result.is_error x) xs ==> Result.is_error (extract_error xs)
  [@@by auto]

theorem exists_error_ok (xs : ('a, 'b) Result.t list) =
  not (List.exists (fun x -> Result.is_error x) xs) ==> Result.is_ok (extract_error xs)
  [@@by auto]

theorem extract_error_preserves_length (xs : ('a, 'b) Result.t list) =
  match (extract_error xs) [@trigger] with
  | Ok r -> List.length r = List.length xs
  | _ -> true
  [@@by auto]
  [@@fc]

theorem extract_error_empty (xs : ('a, 'b) Result.t list)=
  xs = [] ==> Result.is_ok  (extract_error xs) [@trigger]
  [@@by auto]
  [@@fc]