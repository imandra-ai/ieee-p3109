[@@@import Util, "dune:math"]

let unroll_nonlin qt nqt steps = Tactic.unroll ~smt:"z3-full-nonlinear" ~query_timeout:qt ~no_asm_query_timeout:nqt steps

(* Heron's method for approximation of the square root. *)

(* The state during computation of the (over-)approximation *)
type state = {
  i : int;
  p : int;
  x : real;
  g : real
}

(* State invariant *)
let inv (s : state) : bool =
  s.i >= 0 && s.p > 0 && s.x >=. 0.0 && s.g >=. 0.0 && s.g *. s.g >=. s.x

(* One transition step of the approximation *)
let step (s: state) : state =
  if s.i > s.p then
    { s with i = s.i + 1 }
  else if s.g *. s.g = s.x then
    { s with i = s.i + 1 }
  else (
    let t = (s.g +. s.x /. s.g) /. 2.0 in
    {s with i = s.i + 1; g = t}
  )

(* Transition invariant *)
let transition_inv (before : state) (after : state) =
  inv before
    ==>
  (* i increases, p and x stay *)
  (after.i >= before.i + 1) &&
  after.p = before.p &&
  after.x = before.x &&
  (* g decreases *)
  after.g <=. before.g &&
  (* the invariant still holds; chiefly the square of g is always above x *)
  inv after

(* The transition invariant is transitive *)
lemma transition_inv_is_transitive (s1 : state) (s2 : state) (s3 : state) =
  transition_inv s1 s2 && transition_inv s2 s3 ==> transition_inv s1 s3
  [@@by auto]
  [@@fc]

(* Each approximation step preserves the transition invariant *)
lemma step_step (s : state) (s' : state) =
  ((s' = step s) [@trigger]) ==> transition_inv s s'
  [@@by unroll_nonlin 10 10 1000]
  [@@fc]

(* Transition invariant implies state invariant *)
lemma transition_inv_implies_inv (s : state) (s' : state) =
  inv s && ((transition_inv s s') [@trigger]) ==> inv s'
  [@@fc]
  [@@by auto]

(* step preserves the state invariant *)
lemma step_preserves_inv (s : state) (s' : state) =
  inv s && ((s' = step s) [@trigger]) ==> inv s'
  [@@disable transition_inv_implies_inv]
  [@@by [%use step_step s s'] @> auto]
  [@@fc]

(* step_star: repeated application of step, p-i times *)
let rec step_star (s : state) : state =
  if s.i < s.p then
    step_star (step s)
  else
    s
  [@@measure Ordinal.of_int (s.p - s.i)]

(* step_star preserves the invariant *)
lemma step_star_inv (s : state) (s' : state) =
  inv s && ((s' = step_star s) [@trigger]) ==> inv s' && s'.x = s.x
  [@@disable step, inv]
  [@@by auto]
  [@@fc]

(* Define the starting point for the approximation to obtain a complete
  square root computation on states *)
let sqrt_s (x : real) (p : int) : (state, string) Result.t =
  let s = { i = 0; p = if p <= 0 then 1 else p; x; g = if x = 0.0 then 0.0 else if x >=. 1.0 then x else 1.0/.x } in
  if inv s then
    Ok (step_star s)
  else
    Error "initial state invariant violated"

(* sqrt_s preserves the state invariant *)
lemma sqrt_s_inv (x : real) (p : int) =
  match ((sqrt_s x p) [@trigger]) with
  | Ok s -> inv s
  | Error _ -> true
  [@@disable step_star, step, inv]
  [@@by auto]
  [@@fc]

(* sqrt_s computes an over-approximation of the (positive) square root *)
lemma sqrt_s_square_greater (x : real) (p : int) =
  match ((sqrt_s x p) [@trigger]) with
  | Ok s -> s.g *. s.g >=. s.x && s.x = x && s.g >=. 0.0
  | Error _ -> true
  [@@disable step_star, step, inv]
  [@@by [%use sqrt_s_inv x p] @> auto]
  [@@fc]

(* Wrap it all up in an easy-to-use function *)
let sqrt (x : real) (p : int) : (real, string) Result.t =
  match sqrt_s x p with
  | Ok s -> Ok s.g
  | Error e -> Error e

(* sqrt never throws errors as long as x is positive *)
theorem sqrt_ok (x : real) (p : int) =
  x >=. 0.0 ==> Result.is_ok (sqrt x p)
  [@@by unroll_nonlin 1 1 0]
  [@@fc]

(* Define what we mean by over-approximation *)
let is_an_over_approximation (rt : real) (x : real) =
  rt >=. 0.0 && rt *. rt >=. x

(* Define what we mean by under-approximation *)
let is_an_under_approximation (rt : real) (x : real) =
  rt >=. 0.0 && rt *. rt <=. x

(* Finally, tie everything together to prove that our function computes
  an over-approximation of the (positive) square root *)
theorem sqrt_over_approximates (x : real) (p : int) =
  match sqrt x p with
  | Ok rt -> is_an_over_approximation rt x
  | Error _ -> true
  [@@disable sqrt_s, step_star, step, inv]
  [@@by auto]

(* We can divide x by the over-approximated result to obtain an under-approximation *)
let sqrt_under (x : real) (p : int) : (real, string) Result.t =
  match sqrt x p with
  | Ok rt when x = 0.0 -> Ok 0.0
  | Ok rt -> Ok (x /. rt)
  | Error e -> Error e

(* A helper lemma: division by root-like numbers inverts the relationship *)
lemma division_by_rootlike_inverts (x : real) (rt : real) =
  x >. 0.0 && 0.0 <=. rt && rt *. rt >=. x
    ==>
  ((x /. rt) *. (x /. rt) [@trigger]) <=. x
  [@@by unroll_nonlin 1 1 0]
  [@@fc]

(* Another helper: division of numbers greater than zero is also greater than zero *)
lemma division_stays_gt_0 (x : real) (rt : real) =
  x >. 0.0 && rt >. 0.0 ==> x /. rt >. 0.0
  [@@by unroll_nonlin 1 1 0]
  [@@fc]

(* Proof that sqrt_under is an under-approximation *)
theorem sqrt_under_under_approximates (x : real) (p : int) =
  match sqrt_under x p with
  | Ok rt -> is_an_under_approximation rt x
  | Error _ -> true
  [@@disable sqrt]
  [@@by [%use sqrt_over_approximates x p] @> auto]
