[@@@import Specification, "dune:specification"]
[@@@import Util, "util.iml"]
[@@@import Sqrt, "sqrt.iml"]
[@@@import Theorems, "theorems.iml"]
[@@@import Theorems_pow2, "theorems_pow2.iml"]
[@@@import Theorems_sqrt_convergence, "theorems_sqrt_convergence.iml"]
[@@@import Fsqrt, "fsqrt.iml"]

open Specification
open Theorems_sqrt_convergence

let unroll_nonlin qt nqt steps = Tactic.unroll ~smt:"z3-full-nonlinear" ~query_timeout:qt ~no_asm_query_timeout:nqt steps [@@no_extract]

let f81 = {Format.kp = Format.B8P1; s = Signedness.Signed; d = Domain.Extended}
let f83 = {Format.kp = Format.B8P3; s = Signedness.Signed; d = Domain.Extended}

let fmt = f83 [@@macro]
let enc (r : real) = match Float.wEncode fmt (CER.R r) with | Ok e -> e | _ -> Float.nan f83
let dec (x : Float.t) = match Float.wDecode fmt x with | CER.R e -> e | _ -> 0.0

(* Just some checks; the important theorems are all in sqrt.iml *)
verify (Float.sqrt fmt fmt (SaturationMode.SatPropagate, RoundingMode.TowardZero) (enc 0.0) = (enc 0.0)) [@@by ground_eval ()]
verify (Float.sqrt fmt fmt (SaturationMode.SatPropagate, RoundingMode.TowardZero) (enc 1.0) = (enc 1.0)) [@@by ground_eval ()]
verify (dec (Float.sqrt fmt fmt (SaturationMode.SatPropagate, RoundingMode.TowardZero) (enc 1.0)) = 1.0) [@@by ground_eval ()]
verify (Float.sqrt fmt fmt (SaturationMode.SatPropagate, RoundingMode.TowardZero) (enc 4.0) = (enc 2.0)) [@@by ground_eval ()]
verify (dec(Float.sqrt fmt fmt (SaturationMode.SatPropagate, RoundingMode.TowardZero) (enc 4.0)) = 2.0) [@@by ground_eval ()]
verify (Float.sqrt fmt fmt (SaturationMode.SatPropagate, RoundingMode.TowardZero) (enc 16.0) = (enc 4.0)) [@@by ground_eval ()]
verify (Float.sqrt fmt fmt (SaturationMode.SatPropagate, RoundingMode.TowardZero) (enc 64.0) = (enc 8.0)) [@@by ground_eval ()]
verify (Float.sqrt fmt fmt (SaturationMode.SatPropagate, RoundingMode.TowardZero) (enc 256.0) = (enc 16.0)) [@@by ground_eval ()]
verify (dec (Float.sqrt fmt fmt (SaturationMode.SatPropagate, RoundingMode.TowardZero) (enc 256.0)) = 16.0) [@@by ground_eval ()]
verify (Float.sqrt fmt fmt (SaturationMode.SatPropagate, RoundingMode.TowardZero) (Float.nan f83) = Float.nan f83) [@@by ground_eval ()]

let cer_sqrt_approx (x : CER.t) (over : bool) (n : int) : (CER.t, string) Result.t =
  let open CER in
  match x with
  | NaN -> Ok NaN
  | NINF -> Ok NaN
  | R x when x <. 0.0 -> Ok NaN
  | PINF -> Ok PINF
  | R x ->
    (match
    (if over then Sqrt.sqrt_over x n else Sqrt.sqrt_under x n)
  with
    | Ok r -> Ok (R r)
    | Error e -> Error e)
  | _ -> Error "undefined"

theorem cer_sqrt_approx_ok (x : CER.t) (over : bool) (n : int) =
  Result.is_ok (cer_sqrt_approx x over n)
  [@@timeout 60]
  [@@disable Sqrt.sqrt_over, Sqrt.sqrt_under]
  [@@by auto]


theorem fsqrt_aux_both_ok (prec : int) (bias : int) (rnd : RoundingMode.t) (start : real -> int -> (Sqrt.state * Sqrt.state)) (x : real) (p : int)=
  x >=. 0.0 && Sqrt.inv (snd (start x p)) ==> Result.is_ok ((Fsqrt.fsqrt_aux_both prec bias rnd start x p) [@trigger])
  [@@timeout 3600]
  [@@disable Float.wDecode, Format.parameters, Sqrt.sqrt_both]
  [@@by auto]
  (* [@@fc] *)

theorem cer_fsqrt_ok (prec : int) (bias : int) (rnd : RoundingMode.t) (start : real -> int -> (Sqrt.state * Sqrt.state)) (x : CER.t) =
  match x with
  | NaN | PINF | NINF -> true
  | R r when r <. 0.0 -> true
  | R r ->
    Sqrt.inv (snd (start r 1000)) ==>
    Result.is_ok ((Fsqrt.cer_fsqrt prec bias rnd start x) [@trigger])
  [@@timeout 3600]
  [@@disable Float.wDecode, Format.parameters, Sqrt.sqrt_both]
  [@@by auto]
  [@@fc]

theorem square_gt_0 (x : CER.t) =
  let open CER in
  let open CER.ResultInfix in
  match (x * x) [@trigger] with
  | Ok sq -> sq >= zero
  | _ -> true
  [@@by auto]
  [@@fc]

theorem find_closest_sqrt_floats_aux_ok (f : Format.t) (x : CER.t) (l : Float.t) (u : Float.t) =
  l >= 0 && u >= 0 && l < u ==>
  Result.is_ok ((Fsqrt.find_closest_sqrt_floats_aux f x l u) [@trigger])
  [@@timeout 120]
  [@@disable Format.parameters, Float.wDecode]
  [@@by auto]
  [@@fc]

theorem find_closest_sqrt_floats_ok (f : Format.t) (x : CER.t) =
  Result.is_ok ((Fsqrt.find_closest_sqrt_floats f x) [@trigger])
  [@@timeout 120]
  [@@disable Format.parameters, Float.wDecode]
  [@@by auto]
  [@@fc]

theorem fsqrt_start_satisfies_inv (f : Format.t) (x : real) (p : int) =
  p > 0 && x >=. 0.0 ==>
  ((Sqrt.inv (snd (Fsqrt.fsqrt_start f x p))) [@trigger])
  [@@timeout 120]
  [@@disable Format.parameters, Float.wDecode, Fsqrt.find_closest_sqrt_floats]
  [@@by auto]
  [@@fc]

theorem fsqrt_i_ok (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) =
  Result.is_ok (fst ((Fsqrt.fsqrt_i f_x f_z pi x) [@trigger]))
  [@@timeout 3600]
  [@@disable Format.parameters, Float.wDecode, Float.wProject, Fsqrt.fsqrt_start, Fsqrt.cer_fsqrt]
  [@@by auto]
  [@@fc]

theorem fsqrt_ok (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) =
  Result.is_ok (Fsqrt.fsqrt f_x f_z pi x)
  [@@timeout 3600]
  [@@disable Format.parameters, Float.wDecode, Float.wProject, Fsqrt.fsqrt_start, Fsqrt.cer_fsqrt]
  [@@by auto]

let f83 = {Format.kp = Format.B8P3; s = Signedness.Signed; d = Domain.Extended}
let f157 = {Format.kp = Format.B15P7; s = Signedness.Signed; d = Domain.Extended}

theorem fsqrt_ok_below (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) =
  x < 0 ==> ((fsqrt_converges (f_x, f_z, pi) x) [@trigger])
  [@@timeout 60]
  [@@by unroll 100]
  [@@fc]

theorem fsqrt_ok_above (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) =
  (x >= Util.ipow2 (Format.k f_z)) ==> ((fsqrt_converges (f_x, f_z, pi) x) [@trigger])
  [@@timeout 3600]
  [@@by unroll 1000]
  [@@fc]

(* [fsqrt] always converges (within 100 iterations) for any input *)
theorem fsqrt_always_converges (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) =
  fsqrt_converges (f_x, f_z, pi) x
  [@@disable fsqrt_converges]
  [@@timeout 120]
  [@@by
    [%use fsqrt_ok_below f_x f_z pi x] @>
    [%use fsqrt_ok_above f_x f_z pi x] @>
    [%use Theorems_sqrt_convergence.fsqrt_converges_in_range f_x f_z pi] @>
    auto]
