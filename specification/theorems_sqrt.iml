[@@@import Specification, "dune:specification"]
[@@@import Sqrt, "sqrt.iml"]

open Specification
open Sqrt

let unroll_nonlin qt nqt steps = Tactic.unroll ~smt:"z3-full-nonlinear" ~query_timeout:qt ~no_asm_query_timeout:nqt steps

eval (sqrt 0.0 8)
eval (sqrt 1.0 8)
eval (sqrt 4.0 8)
eval (sqrt 9.0 8)

eval (Float8.of_int_repr 0x40)
eval (Float8.decode Format.B8P1 (Float8.of_int_repr 0x40))
eval (sqrt 2.0 8)

let fmt = Format.B8P3 [@@macro]
let enc (r : real) = match Float8.encode fmt (Float8.NaNOrExReal.XR (ExReal.R r)) with | Ok e -> e | _ -> Float8.nan
let dec (x : Float8.t) = match Float8.decode fmt x with | Ok (Float8.NaNOrExReal.XR (ExReal.R e)) -> e | _ -> 0.0

eval (enc 16.0)
eval (enc 32.0)

eval (sqrt 25.0 8)
eval (ExReal.sqrt (ExReal.R 25.0) 8)
eval (dec (Float8.sqrt fmt fmt (false, RoundingMode.TowardZero) (enc 256.0)))

verify (Float8.sqrt fmt fmt (false, RoundingMode.TowardZero) (enc 1.0) = (enc 1.0)) [@@by ground_eval]
verify (dec (Float8.sqrt fmt fmt (false, RoundingMode.TowardZero) (enc 1.0)) = 1.0) [@@by ground_eval]
verify (Float8.sqrt fmt fmt (false, RoundingMode.TowardZero) (enc 4.0) = (enc 2.0)) [@@by ground_eval]
verify (dec(Float8.sqrt fmt fmt (false, RoundingMode.TowardZero) (enc 4.0)) = 2.0) [@@by ground_eval]
verify (Float8.sqrt fmt fmt (false, RoundingMode.TowardZero) (enc 16.0) = (enc 4.0)) [@@by ground_eval]
verify (Float8.sqrt fmt fmt (false, RoundingMode.TowardZero) (enc 64.0) = (enc 8.0)) [@@by ground_eval]
verify (Float8.sqrt fmt fmt (false, RoundingMode.TowardZero) (enc 256.0) = (enc 16.0)) [@@by ground_eval]
verify (dec (Float8.sqrt fmt fmt (false, RoundingMode.TowardZero) (enc 256.0)) = 16.0) [@@by ground_eval]
verify (Float8.sqrt fmt fmt (false, RoundingMode.TowardZero) Float8.nan = Float8.nan)

eval (Float8.decode fmt (Float8.sqrt fmt fmt (false, RoundingMode.TowardZero) (enc 36.0)))

theorem sqrt_from_above (f : Format.t) (x : Float8.t) =
  match Float8.decode f x with
  | Ok (Float8.NaNOrExReal.XR (ExReal.R r)) when r >=. 0.0 ->
    (match sqrt r 8 with
    | Ok rt -> (rt *. rt) >=. r
    | Error _ -> false)
  | _ -> true
  [@@by enumerate ["f"; "x"] @> ground_eval]

let exp (f : Format.t) (x : Float8.t) : int =
  let _, _, bias, _ = Format.get_format_parameters f in
  let exp_sig : int =
      (if x.b0 then 1 else 0)
    + (if x.b1 then 2 else 0)
    + (if x.b2 then 4 else 0)
    + (if x.b3 then 8 else 0)
    + (if x.b4 then 16 else 0)
    + (if x.b5 then 32 else 0)
    + (if x.b6 then 64 else 0)
  in
  let biased_exp = match f with
    | Format.B8P1 -> exp_sig
    | Format.B8P2 -> exp_sig / 2
    | Format.B8P3 -> exp_sig / 4
    | Format.B8P4 -> exp_sig / 8
    | Format.B8P5 -> exp_sig / 16
    | Format.B8P6 -> exp_sig / 32
    | Format.B8P7 -> exp_sig / 64
  in
  biased_exp - bias


theorem sqrt_within (f : Format.t) (x : Float8.t) =
  match Float8.decode f x with
  | Ok (Float8.NaNOrExReal.XR (ExReal.R r)) when r >=. 0.0 ->
    (match sqrt r 64 with
    | Ok rt -> (rt *. rt) -. r <=. Util.pow2 (exp f x)
    | Error _ -> false)
  | _ -> true
  [@@timeout 3600]
  [@@by enumerate ["f"; "x"] @> auto]

eval (Float8.decode Format.B8P1 (Float8.of_int_repr 0x69))
eval (Float8.decode Format.B8P1 (Float8.of_int_repr 0x7E))

eval (exp Format.B8P1 (Float8.of_int_repr 0x70))
