[@@@import Specification, "dune:specification"]
[@@@import Util, "util.iml"]
[@@@import Sqrt, "sqrt.iml"]
[@@@import Theorems, "theorems.iml"]
[@@@import Theorems_pow2, "theorems_pow2.iml"]

open Specification

let unroll_nonlin qt nqt steps = Tactic.unroll ~smt:"z3-full-nonlinear" ~query_timeout:qt ~no_asm_query_timeout:nqt steps [@@no_extract]

let f81 = {Format.kp = Format.B8P1; s = Signedness.Signed; d = Domain.Extended}
let f83 = {Format.kp = Format.B8P3; s = Signedness.Signed; d = Domain.Extended}

let fmt = f83 [@@macro]
let enc (r : real) = match Float.encode fmt (AugReal.R r) with | Ok e -> e | _ -> Float.nan f83
let dec (x : Float.t) = match Float.decode fmt x with | AugReal.R e -> e | _ -> 0.0

(* Just some checks; the important theorems are all in sqrt.iml *)
verify (Float.sqrt fmt fmt (SaturationMode.SatPropagate, RoundingMode.TowardZero) (enc 0.0) = (enc 0.0)) [@@by ground_eval]
verify (Float.sqrt fmt fmt (SaturationMode.SatPropagate, RoundingMode.TowardZero) (enc 1.0) = (enc 1.0)) [@@by ground_eval]
verify (dec (Float.sqrt fmt fmt (SaturationMode.SatPropagate, RoundingMode.TowardZero) (enc 1.0)) = 1.0) [@@by ground_eval]
verify (Float.sqrt fmt fmt (SaturationMode.SatPropagate, RoundingMode.TowardZero) (enc 4.0) = (enc 2.0)) [@@by ground_eval]
verify (dec(Float.sqrt fmt fmt (SaturationMode.SatPropagate, RoundingMode.TowardZero) (enc 4.0)) = 2.0) [@@by ground_eval]
verify (Float.sqrt fmt fmt (SaturationMode.SatPropagate, RoundingMode.TowardZero) (enc 16.0) = (enc 4.0)) [@@by ground_eval]
verify (Float.sqrt fmt fmt (SaturationMode.SatPropagate, RoundingMode.TowardZero) (enc 64.0) = (enc 8.0)) [@@by ground_eval]
verify (Float.sqrt fmt fmt (SaturationMode.SatPropagate, RoundingMode.TowardZero) (enc 256.0) = (enc 16.0)) [@@by ground_eval]
verify (dec (Float.sqrt fmt fmt (SaturationMode.SatPropagate, RoundingMode.TowardZero) (enc 256.0)) = 16.0) [@@by ground_eval]
verify (Float.sqrt fmt fmt (SaturationMode.SatPropagate, RoundingMode.TowardZero) (Float.nan f83) = Float.nan f83) [@@by ground_eval]

(* Define two versions of floating-point sqrt based on over- and under-approximations *)

let aug_sqrt_approx (x : AugReal.t) (over : bool) (n : int) : (AugReal.t, string) Result.t =
  let open AugReal in
  match x with
  | NaN -> Ok NaN
  | NINF -> Ok NaN
  | R x when x <. 0.0 -> Ok NaN
  | PINF -> Ok PINF
  | R x ->
    (match (if over then Sqrt.sqrt_over x n else Sqrt.sqrt_under x n) with
    | Ok r -> Ok (R r)
    | Error e -> Error e)
  | _ -> Error "undefined"

theorem aug_sqrt_approx_ok (x : AugReal.t) (over : bool) (n : int) =
  Result.is_ok (aug_sqrt_approx x over n)
  [@@timeout 60]
  [@@disable Sqrt.sqrt_over, Sqrt.sqrt_under]
  [@@by auto]

let fsqrt_over (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) (n : int) : Float.t =
  match aug_sqrt_approx (Float.decode f_x x) true n with
  | Ok r -> (
    match Float.project f_z pi r with
    | Ok r -> r
    | Error _ -> Float.nan f_z (* unreachable by project_ok *)
  )
  | Error _ -> Float.nan f_z (* unreachable by aug_sqrt_approx_ok*)

let fsqrt_under (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) (n : int) : Float.t =
  match aug_sqrt_approx (Float.decode f_x x) false n with
  | Ok r -> (
    match Float.project f_z pi r with
    | Ok r -> r
    | Error _ -> Float.nan f_z (* unreachable by project_ok *)
    )
  | Error _ -> Float.nan f_z (* unreachable by aug_sqrt_approx_ok *)

let sqrt_gt_0 (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) : bool =
  let open AugReal in
  let frto = fsqrt_over f_x f_z pi x 12 in
  let frtu = fsqrt_under f_x f_z pi x 12 in
  match Float.decode f_z frto, Float.decode f_z frtu with
  | R rto, R rtu -> rto = rtu
  | R _, _ -> false
  | _, R _-> false
  | _ -> true (* special cases ok *)

let rec forall_in_range (p : 'a -> int -> bool) (args : 'a) (l : int) (u : int) =
  if l > u then
    true
  else
    p args l && forall_in_range p args (l + 1) u
  [@@measure Ordinal.of_int (u - l)]

theorem forall_elim (p: 'a -> int -> bool) (args : 'a) (l : int) (u : int) (x : int) =
  forall_in_range p args l u ==> (l <= x && x <= u ==> p args x)
  [@@by auto]

let mk_sqrt_gt_0 (args : Format.t * Projection.t) (x : Float.t) : bool =
  sqrt_gt_0 (fst args) (fst args) (snd args) x
  [@@macro]

theorem sqrt_gt0_below (f : Format.t) (pi : Projection.t) (x : Float.t) =
  x < 0 ==> ((mk_sqrt_gt_0 (f, pi) x) [@trigger])
  [@@timeout 60]
  [@@by unroll 100]
  [@@fc]

theorem sqrt_gt0_above (f : Format.t) (pi : Projection.t) (x : Float.t) =
  (x >= Util.ipow2 (Format.k f)) ==> ((mk_sqrt_gt_0 (f, pi) x) [@trigger])
  [@@timeout 60]
  [@@by unroll 100]
  [@@fc]

theorem sqrt_gt0_k8_mid (f : Format.t) (pi : Projection.t) =
  Format.k f = 8 && Format.p f >= 3 && f.s = Signedness.Signed && snd pi = RoundingMode.NearestTiesToEven ==>
  forall_in_range mk_sqrt_gt_0 (f, pi) 0 (Util.ipow2 8)
  [@@timeout 86400]
  [@@by enumerate ["f"; "pi"] @> ground_eval]

theorem sqrt_gt0_k8 (f : Format.t) (pi : Projection.t) (x : Float.t) =
  Format.k f = 8 && Format.p f >= 3 && f.s = Signedness.Signed && snd pi = RoundingMode.NearestTiesToEven ==>
  sqrt_gt_0 f f pi x
  [@@disable sqrt_gt_0]
  [@@by
    [%use sqrt_gt0_below f pi x] @>
    [%use sqrt_gt0_above f pi x] @>
    [%use sqrt_gt0_k8_mid f pi] @>
    [%use forall_elim mk_sqrt_gt_0 (f, pi) 0 (Util.ipow2 8) x] @>
    auto]
