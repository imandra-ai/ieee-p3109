[@@@import Util, "dune:math"]
[@@@import CER, "dune:math"]
[@@@import Sqrt, "dune:math"]
[@@@import Exp, "dune:math"]
[@@@import Log, "dune:math"]
[@@@import ErrorPropagation, "ErrorPropagation.iml"]
[@@@import IEEE754, "IEEE754.iml"]

open ErrorPropagation

(** Format definitions *)

module Signedness = struct
  type t = Signed | Unsigned
end

module Domain = struct
  type t = Extended | Finite
end

module Format = struct
  type kpt =
    | B2P1 | B2P2
    | B3P1 | B3P2 | B3P3
    | B4P1 | B4P2 | B4P3 | B4P4
    | B5P1 | B5P2 | B5P3 | B5P4 | B5P5
    | B6P1 | B6P2 | B6P3 | B6P4 | B6P5| B6P6
    | B7P1 | B7P2 | B7P3 | B7P4 | B7P5 | B7P6 | B7P7
    | B8P1 | B8P2 | B8P3 | B8P4 | B8P5 | B8P6 | B8P7 | B8P8
    | B9P1 | B9P2 | B9P3 | B9P4 | B9P5 | B9P6 | B9P7 | B9P8 | B9P9
    | B10P1 | B10P2 | B10P3 | B10P4 | B10P5 | B10P6 | B10P7 | B10P8 | B10P9 | B10P10
    | B11P1 | B11P2 | B11P3 | B11P4 | B11P5 | B11P6 | B11P7 | B11P8 | B11P9 | B11P10 | B11P11
    | B12P1 | B12P2 | B12P3 | B12P4 | B12P5 | B12P6 | B12P7 | B12P8 | B12P9 | B12P10 | B12P11 | B12P12
    | B13P1 | B13P2 | B13P3 | B13P4 | B13P5 | B13P6 | B13P7 | B13P8 | B13P9 | B13P10 | B13P11 | B13P12 | B13P13
    | B14P1 | B14P2 | B14P3 | B14P4 | B14P5 | B14P6 | B14P7 | B14P8 | B14P9 | B14P10 | B14P11 | B14P12 | B14P13 | B14P14
    | B15P1 | B15P2 | B15P3 | B15P4 | B15P5 | B15P6 | B15P7 | B15P8 | B15P9 | B15P10 | B15P11 | B15P12 | B15P13 | B15P14 | B15P15

  type t = {
    kp: kpt;
    s: Signedness.t;
    d: Domain.t;
  }

  let precision (f : t) : int =
    match f.kp with
    | B15P1  | B14P1  | B13P1  | B12P1  | B11P1  | B10P1 | B9P1 | B8P1 | B7P1 | B6P1 | B5P1 | B4P1 | B3P1 | B2P1 -> 1
    | B15P2  | B14P2  | B13P2  | B12P2  | B11P2  | B10P2 | B9P2 | B8P2 | B7P2 | B6P2 | B5P2 | B4P2 | B3P2 | B2P2 -> 2
    | B15P3  | B14P3  | B13P3  | B12P3  | B11P3  | B10P3 | B9P3 | B8P3 | B7P3 | B6P3 | B5P3 | B4P3 | B3P3 -> 3
    | B15P4  | B14P4  | B13P4  | B12P4  | B11P4  | B10P4 | B9P4 | B8P4 | B7P4 | B6P4 | B5P4 | B4P4 -> 4
    | B15P5  | B14P5  | B13P5  | B12P5  | B11P5  | B10P5 | B9P5 | B8P5 | B7P5 | B6P5 | B5P5-> 5
    | B15P6  | B14P6  | B13P6  | B12P6  | B11P6  | B10P6 | B9P6 | B8P6 | B7P6 | B6P6 -> 6
    | B15P7  | B14P7  | B13P7  | B12P7  | B11P7  | B10P7 | B9P7 | B8P7 | B7P7-> 7
    | B15P8  | B14P8  | B13P8  | B12P8  | B11P8  | B10P8 | B9P8 | B8P8 -> 8
    | B15P9  | B14P9  | B13P9  | B12P9  | B11P9  | B10P9 | B9P9 -> 9
    | B15P10 | B14P10 | B13P10 | B12P10 | B11P10 | B10P10 -> 10
    | B15P11 | B14P11 | B13P11 | B12P11 | B11P11-> 11
    | B15P12 | B14P12 | B13P12 | B12P12 -> 12
    | B15P13 | B14P13 | B13P13 -> 13
    | B15P14 | B14P14 -> 14
    | B15P15 -> 15
    [@@macro]

  let k_of_kp (kp : kpt) =
    match kp with
    | B2P1 | B2P2 -> 2
    | B3P1 | B3P2 | B3P3 -> 3
    | B4P1 | B4P2 | B4P3 | B4P4 -> 4
    | B5P1 | B5P2 | B5P3 | B5P4 | B5P5 -> 5
    | B6P1 | B6P2 | B6P3 | B6P4 | B6P5 | B6P6 -> 6
    | B7P1 | B7P2 | B7P3 | B7P4 | B7P5 | B7P6 | B7P7 -> 7
    | B8P1 | B8P2 | B8P3 | B8P4 | B8P5 | B8P6 | B8P7 | B8P8 -> 8
    | B9P1 | B9P2 | B9P3 | B9P4 | B9P5 | B9P6 | B9P7 | B9P8 | B9P9 -> 9
    | B10P1 | B10P2 | B10P3 | B10P4 | B10P5 | B10P6 | B10P7 | B10P8 | B10P9 | B10P10 -> 10
    | B11P1 | B11P2 | B11P3 | B11P4 | B11P5 | B11P6 | B11P7 | B11P8 | B11P9 | B11P10 | B11P11  -> 11
    | B12P1 | B12P2 | B12P3 | B12P4 | B12P5 | B12P6 | B12P7 | B12P8 | B12P9 | B12P10 | B12P11 | B12P12 -> 12
    | B13P1 | B13P2 | B13P3 | B13P4 | B13P5 | B13P6 | B13P7 | B13P8 | B13P9 | B13P10 | B13P11 | B13P12 | B13P13 -> 13
    | B14P1 | B14P2 | B14P3 | B14P4 | B14P5 | B14P6 | B14P7 | B14P8 | B14P9 | B14P10 | B14P11 | B14P12 | B14P13 | B14P14-> 14
    | B15P1 | B15P2 | B15P3 | B15P4 | B15P5 | B15P6 | B15P7 | B15P8 | B15P9 | B15P10 | B15P11 | B15P12 | B15P13 | B15P14 | B15P15 -> 15
  [@@macro]

  let width (f : t) : int = k_of_kp f.kp [@@macro]

  let k (f : t) : int = width f [@@macro]

  let p (f : t) : int = precision f [@@macro]

  let of_kp (k : int) (p : int) : (kpt, string) Result.t =
    match k with
    | 2 -> (match p with 1 -> Ok B2P1 | 2 -> Ok B2P2 | _ -> Error "invalid precision")
    | 3 -> (match p with 1 -> Ok B3P1 | 2 -> Ok B3P2 | 3 -> Ok B3P3 | _ -> Error "invalid precision")
    | 4 -> (match p with 1 -> Ok B4P1 | 2 -> Ok B4P2 | 3 -> Ok B4P3 | 4 -> Ok B4P4 | _ -> Error "invalid precision")
    | 5 -> (match p with 1 -> Ok B5P1 | 2 -> Ok B5P2 | 3 -> Ok B5P3 | 4 -> Ok B5P4 | 5 -> Ok B5P5 | _ -> Error "invalid precision")
    | 6 -> (match p with 1 -> Ok B6P1 | 2 -> Ok B6P2 | 3 -> Ok B6P3 | 4 -> Ok B6P4 | 5 -> Ok B6P5 | 6 -> Ok B6P6 | _ -> Error "invalid precision")
    | 7 -> (match p with 1 -> Ok B7P1 | 2 -> Ok B7P2 | 3 -> Ok B7P3 | 4 -> Ok B7P4 | 5 -> Ok B7P5 | 6 -> Ok B7P6 | 7 -> Ok B7P7 | _ -> Error "invalid precision")
    | 8 -> (match p with 1 -> Ok B8P1 | 2 -> Ok B8P2 | 3 -> Ok B8P3 | 4 -> Ok B8P4 | 5 -> Ok B8P5 | 6 -> Ok B8P6 | 7 -> Ok B8P7 | 8 -> Ok B8P8 | _ -> Error "invalid precision")
    | 9 -> (match p with 1 -> Ok B9P1 | 2 -> Ok B9P2 | 3 -> Ok B9P3 | 4 -> Ok B9P4 | 5 -> Ok B9P5 | 6 -> Ok B9P6 | 7 -> Ok B9P7 | 8 -> Ok B9P8 | 9 -> Ok B9P9 | _ -> Error "invalid precision")
    | 10 -> (match p with 1 -> Ok B10P1 | 2 -> Ok B10P2 | 3 -> Ok B10P3 | 4 -> Ok B10P4 | 5 -> Ok B10P5 | 6 -> Ok B10P6 | 7 -> Ok B10P7 | 8 -> Ok B10P8 | 9 -> Ok B10P9 | 10 -> Ok B10P10 | _ -> Error "invalid precision")
    | 11 -> (match p with 1 -> Ok B11P1 | 2 -> Ok B11P2 | 3 -> Ok B11P3 | 4 -> Ok B11P4 | 5 -> Ok B11P5 | 6 -> Ok B11P6 | 7 -> Ok B11P7 | 8 -> Ok B11P8 | 9 -> Ok B11P9 | 10 -> Ok B11P10 | 11 -> Ok B11P11 | _ -> Error "invalid precision")
    | 12 -> (match p with 1 -> Ok B12P1 | 2 -> Ok B12P2 | 3 -> Ok B12P3 | 4 -> Ok B12P4 | 5 -> Ok B12P5 | 6 -> Ok B12P6 | 7 -> Ok B12P7 | 8 -> Ok B12P8 | 9 -> Ok B12P9 | 10 -> Ok B12P10 | 11 -> Ok B12P11 | 12 -> Ok B12P12 | _ -> Error "invalid precision")
    | 13 -> (match p with 1 -> Ok B13P1 | 2 -> Ok B13P2 | 3 -> Ok B13P3 | 4 -> Ok B13P4 | 5 -> Ok B13P5 | 6 -> Ok B13P6 | 7 -> Ok B13P7 | 8 -> Ok B13P8 | 9 -> Ok B13P9 | 10 -> Ok B13P10 | 11 -> Ok B13P11 | 12 -> Ok B13P12 | 13 -> Ok B13P13 | _ -> Error "invalid precision")
    | 14 -> (match p with 1 -> Ok B14P1 | 2 -> Ok B14P2 | 3 -> Ok B14P3 | 4 -> Ok B14P4 | 5 -> Ok B14P5 | 6 -> Ok B14P6 | 7 -> Ok B14P7 | 8 -> Ok B14P8 | 9 -> Ok B14P9 | 10 -> Ok B14P10 | 11 -> Ok B14P11 | 12 -> Ok B14P12 | 13 -> Ok B14P13 | 14 -> Ok B14P14 | _ -> Error "invalid precision")
    | 15 -> (match p with 1 -> Ok B15P1 | 2 -> Ok B15P2 | 3 -> Ok B15P3 | 4 -> Ok B15P4 | 5 -> Ok B15P5 | 6 -> Ok B15P6 | 7 -> Ok B15P7 | 8 -> Ok B15P8 | 9 -> Ok B15P9 | 10 -> Ok B15P10 | 11 -> Ok B15P11 | 12 -> Ok B15P12 | 13 -> Ok B15P13 | 14 -> Ok B15P14 | 15 -> Ok B15P15 | _ -> Error "invalid precision")
    | _ -> Error "invalid width"

  let of_parts (k : int) (p : int) (s : Signedness.t) (d : Domain.t) : (t, string) Result.t =
    let* kp = of_kp k p in
    Ok { kp; s; d }

  let parameters (f : t) : int * int * int * real * real * Signedness.t * Domain.t =
    let open Util in
    let open Signedness in
    let open Domain in
    let k : int = k f in
    let p : int = precision f in
    let bias : int =
      match f.s with
      | Signed -> if k = p then -1 else ipow2 (k - p - 1) (* Error for k = p? *)
      | Unsigned -> ipow2 (k - p) in
    let m_hi : real =
      if p = 1 then
        match f.s, f.d with
        | Signed, Extended ->   pow2 (ipow2 (k - 1) - bias - 2)
        | Signed, Finite ->     pow2 (ipow2 (k - 1) - bias - 1)
        | Unsigned, Extended -> pow2 (ipow2 k       - bias - 3)
        | Unsigned, Finite ->   pow2 (ipow2 k       - bias - 2)
      else
        match f.s, f.d with
        | Signed, Extended ->   pow2 (ipow2 (k - p) - bias - 1) *. (2. -. pow2 (2 - p))
        | Signed, Finite ->     pow2 (ipow2 (k - p) - bias - 1) *. (2. -. pow2 (2 - p - 1))
        | Unsigned, Extended -> (
          match p with
          | 2 ->                pow2 (ipow2 (k - p + 1) - bias - 2) *. (2. -. pow2 (2 - p - 1))
          | _ ->                pow2 (ipow2 (k - p + 1) - bias - 1) *. (2. -. pow2 (2 - p) -. pow2 (2 - p - 1))
        )
        | Unsigned, Finite ->   pow2 (ipow2 (k - p + 1) - bias - 1) *. (2. -. pow2 (2 - p))
      in
    let m_lo = if f.s = Signed then -. m_hi else 0.0 in
    k, p, bias, m_lo, m_hi, f.s, f.d

  (** String representation *)
  let to_string (f : t) : string =
    "binary" ^ (Int.to_string (k f)) ^ "p" ^
    (Int.to_string (p f)) ^
    (if f.s == Signed then "s" else "u") ^
    (if f.d = Extended then "e" else "f")
    [@@program]
end

module SaturationMode = struct
  type t =
    | SatFinite
    | SatPropagate
    | OvfInf

  (** String representation *)
  let to_string (x : t) : string =
    match x with
    | SatFinite -> "SatFinite"
    | SatPropagate -> "SatPropagate"
    | OvfInf -> "OvfInf"
    [@@program]
end

(** Rounding mode definitions *)

module RoundingMode = struct
  type t =
    | TowardZero
    | TowardNegative
    | TowardPositive
    | NearestTiesToEven
    | NearestTiesToAway
    | ToOdd
    | Stochastic of int
    | StochasticBiased1 of int
    | StochasticBiased2 of int

    (** String representation *)
  let to_string (x : t) : string =
    match x with
    | TowardZero -> "TowardZero"
    | TowardNegative -> "TowardNegative"
    | TowardPositive -> "TowardPositive"
    | NearestTiesToEven -> "NearestTiesToEven"
    | NearestTiesToAway -> "NearestTiesToAway"
    | ToOdd -> "ToOdd"
    | Stochastic r -> "Stochastic (" ^ Int.to_string r ^ ")"
    | StochasticBiased1 r -> "StochasticBiased1 (" ^ Int.to_string r ^ ")"
    | StochasticBiased2 r -> "StochasticBiased2 (" ^ Int.to_string r ^ ")"
    [@@program]
end

(* Projection specifications *)
module Projection = struct
  type t = SaturationMode.t * RoundingMode.t

  (** String representation *)
  let to_string (x : t) : string =
    SaturationMode.to_string (fst x) ^ ", " ^ RoundingMode.to_string (snd x)
    [@@program]
end

let cer_is_within_range (f : Format.t) (x : CER.t) : bool =
  match x with
  | NaN -> true
  | NINF -> f.s = Signedness.Signed && f.d = Domain.Extended
  | PINF -> f.d = Domain.Extended
  | R r ->
    let _, _, _, m_lo, m_hi, _, _ = Format.parameters f in
    m_lo <=. r && r <=. m_hi

(** Floating-point numeral definitions *)

module Float = struct
  (* Type definition *)
  type t = int

  (* Constants *)

  let nan_ks (k : int) (s : Signedness.t): t =
    let open Signedness in
    match s with
    | Signed -> Util.ipow2 (k - 1)
    | Unsigned -> Util.ipow2 k - 1

  let nan (f : Format.t): t =
    let k, _, _, _, _, s, _ = Format.parameters f in
    nan_ks k s

  let ninf (f : Format.t) : (t, string) Result.t =
    let open Signedness in
    let open Domain in
    let k, _, _, _, _, s, d = Format.parameters f in
    match s, d with
    | Unsigned, _
    | _, Finite -> Error "invalid"
    | _ -> Ok (Util.ipow2 k - 1)

  let pinf (f : Format.t) : (t, string) Result.t =
    let open Signedness in
    let open Domain in
    let k, _, _, _, _, s, d = Format.parameters f in
    match s, d with
    | Signed, Extended -> Ok (Util.ipow2 (k - 1) - 1)
    | Unsigned, Extended -> Ok (Util.ipow2 k - 2)
    | _, Finite -> Error "invalid"

  let zero : t = 0 [@@macro]

  (* Internal helpers *)

  let to_int_repr (f : Format.t) (i : t) : int =
    let k, _, _, _, _, _, _ = Format.parameters f in
    if i < 0 || i >= Util.ipow2 k then nan f else i

  let to_int_repr_k (k : int) (i : t) (s : Signedness.t): int =
    if i < 0 || i >= Util.ipow2 k then (nan_ks k s) else i

  let of_int_repr (f : Format.t) (i : int) : t =
    let k, _, _, _, _, _, _ = Format.parameters f in
    if i < 0 || i >= Util.ipow2 k then nan f else i

  let of_int_repr_k (k : int) (s : Signedness.t) (i : int) : t =
    if i < 0 || i >= Util.ipow2 k then (nan_ks k s) else i

  let is_nan f x = to_int_repr f x = nan f
  let is_ninf f x = Ok (to_int_repr f x) = ninf f
  let is_pinf f x = Ok (to_int_repr f x) = pinf f
  let is_inf f x = is_ninf f x || is_pinf f x

  (** 4.9.1 Decode *)
  let rec wDecodeAux (k : int) (p : int) (b : int) (s: Signedness.t) (d : Domain.t) (x : t) : (CER.t, string) Result.t =
    let open Util in
    let open Signedness in
    let open Domain in
    (* if k > 15 then Error "invalid format" else (* Note: termination checks go off the rails if k is unbounded *) *)
    match to_int_repr_k k x s with
    | x when x = ipow2 (k - 1)     && s = Signed -> Ok NaN
    | x when x = ipow2  k      - 1 && s = Unsigned -> Ok NaN

    | x when x = ipow2 (k - 1) - 1 && d = Extended && s = Signed -> Ok PINF
    | x when x = ipow2  k      - 1 && d = Extended && s = Signed -> Ok NINF
    | x when x = ipow2  k      - 2 && d = Extended && s = Unsigned -> Ok PINF

    | x when ipow2 (k - 1) < x && x < ipow2 k && s = Signed ->
      let* r = wDecodeAux k p b s d (of_int_repr_k k s (x - ipow2 (k - 1))) in
      Ok CER.(~- r)

    | x ->
      let t = Real.of_int (x mod (ipow2 (p - 1))) in
      let e = Int.(Util.machine_idiv x (ipow2 (p - 1))) in

      let r = (
        if e = 0 then
          (0. +. t *. (pow2 (1 - p))) *. (pow2 (1 - b))
        else
          (1. +. t *. (pow2 (1 - p))) *. (pow2 (e - b))) in
      Ok CER.(R r)
    [@@timeout 3600]
    [@@measure Ordinal.of_int x]
    [@@by auto]

  let wDecode (f : Format.t) (x : t) : CER.t =
    let k, p, b, _, _, s, d = Format.parameters f in
    match wDecodeAux k p b s d x with
    | Ok r -> r
    | Error _ -> NaN (* unreachable by theorem_decode_ok *)

  (* 4.9.3 RoundToPrecision *)

  let internal_wRoundToPrecision (p : int) (b : int) (rnd : RoundingMode.t) (x : CER.t) : (CER.t, string) Result.t =
    let open Util in
    let open RoundingMode in
    let rsign (x : real) : real = if x <. 0.0 then -1.0 else 1.0 [@@macro] in
    let is_even (x : int) : bool = x mod 2 = 0 [@@macro] in
    match x with
    | CER.NaN -> Ok NaN
    | NINF
    | PINF -> Ok x
    | R 0.0 -> Ok x
    | R x ->
      let e : int = (max (floor_log2_abs x 32768) (1 - b)) - p + 1 in (* TODO: is 32768 always enough? *)
      let s : real = Real.abs x *. pow2 (- e) in
      let delta : real = Real.(s - floor s) in
      let code_is_even : bool =
        if p > 1 then
          is_even (ifloor s)
        else
          floor s = 0.0 || is_even (e + b) in
      let rnite x =
          if (x <. (floor x) +. 0.5) || (x = (floor x) +. 0.5 && is_even (ifloor x)) then
            floor x
          else
            (floor x) +. 1.0
      in
      let rnte n x = rnite (x *. pow2 n) *. pow2 (- n) in
      let round_away (rnd : RoundingMode.t) : bool =
        match rnd with
        | NearestTiesToEven -> delta >. 0.5 || (delta = 0.5 && not code_is_even)
        | NearestTiesToAway -> delta >=. 0.5
        | TowardPositive -> delta >. 0.0 && x >. 0.0
        | TowardNegative -> delta >. 0.0 && x <. 0.0
        | TowardZero -> false
        | ToOdd -> delta >. 0.0 && code_is_even
        | Stochastic r -> (
          let delta' = rnte (num_bits r) s -. floor s in
          delta' >=. i2r r *. (2 ^. (- (num_bits r)))
          )
        | StochasticBiased1 r -> delta >. i2r r *. (2 ^. (- (num_bits r)))
        | StochasticBiased2 r -> delta >. (i2r r +. 0.5) *. (2 ^. (- (num_bits r)))
      in
      let i = if round_away rnd then (floor s) +. 1.0
              else floor s in
      let z = CER.R (rsign x *. i *. (2 ^ e)) in
      Ok z

  (** Convert extended real value [x] to a new extended real that is representable
      with a given precision [p]. The exponent is bounded below by [2 - p - b] and
      unbounded above. *)
  let wRoundToPrecision (p : int) (b : int) (rnd : RoundingMode.t) (x : CER.t) : CER.t =
    match internal_wRoundToPrecision p b rnd x with
    | Ok r -> r
    | Error _ -> R 0.0 (* unreachable by internal_round_to_precision_ok *)

  (** 4.9.4 Saturate *)

  let internal_wSaturate
    (m_lo : real) (m_hi : real) (sat : SaturationMode.t) (rnd : RoundingMode.t)
    (x : CER.t) (sigma : Signedness.t) (delta : Domain.t)
    : (CER.t, string) Result.t =
    let open RoundingMode in
    let open SaturationMode in
    let open Signedness in
    let open Domain in
    match sat, rnd, x, sigma, delta with
    | _, _, NaN, _, _ -> Ok NaN

    | _, _, R x, _, _ when m_lo <=. x && x <=. m_hi -> Ok (R x)

    | SatFinite, _, PINF, _, _ -> Ok (R m_hi)
    | SatFinite, _, NINF, _, _ -> Ok (R m_lo)
    | SatFinite, _, R x, _, _ when x <=. m_lo -> Ok (R m_lo)
    | SatFinite, _, R x, _, _ when x >=. m_hi -> Ok (R m_hi)

    | SatPropagate, _, PINF, _, Extended -> Ok PINF
    | SatPropagate, _, PINF, _, _ -> Ok (R m_hi)
    | SatPropagate, _, NINF, Signed, Extended -> Ok NINF
    | SatPropagate, _, NINF, _, _ -> Ok (R m_lo)
    | SatPropagate, _, R x, _, _ when x <=. m_lo -> Ok (R m_lo)
    | SatPropagate, _, R x, _, _ when x >=. m_hi -> Ok (R m_hi)

    | OvfInf, _, PINF, _, Extended -> Ok PINF
    | OvfInf, _, PINF, _, _ -> Ok (R m_hi)
    | OvfInf, _, NINF, Signed, Extended -> Ok NINF
    | OvfInf, _, NINF, _, _ -> Ok (R m_lo)
    | OvfInf, (TowardZero | TowardPositive), R x, _, _ when x <=. m_lo -> Ok (R m_lo)
    | OvfInf, (TowardZero | TowardNegative), R x, _, _ when x >=. m_hi -> Ok (R m_hi)
    | OvfInf, _, R x, Signed, Extended when x <=. m_lo -> Ok NINF
    | OvfInf, _, R x, _, _ when x <=. m_lo -> Ok (R m_lo)
    | OvfInf, _, R x, _, Extended when x >=. m_hi -> Ok PINF
    | OvfInf, _, R x, _, _ when x >=. m_hi -> Ok (R m_hi)

    | _ -> Error "unreachable"

  (** Saturate extended real [x] to +-INF, or to maximum value [m], according to projection specification [pi]. *)
  let wSaturate (m_lo : real) (m_hi : real) (sat : SaturationMode.t) (rnd : RoundingMode.t) (x : CER.t) (s : Signedness.t) (d : Domain.t) : CER.t =
    match internal_wSaturate m_lo m_hi sat rnd x s d with
    | Ok x -> x
    | Error _ -> R 0.0 (* unreachable by theorem internal_wSaturate_ok *)


  (** 4.9.5 Encode *)

  let rec wEncode (f : Format.t) (x : CER.t) : (t, string) Result.t =
    let open Util in
    let k, p, b, _, _, _, _ = Format.parameters f in
    if not (cer_is_within_range f x)  then
        Error "precondition violation"
    else
      match x with
      | NaN -> Ok (of_int_repr f (
        if f.s = Signedness.Signed then ipow2 (k - 1)
        else ipow2 k - 1
        ))
      | PINF -> Ok (of_int_repr f (
        if f.s = Signedness.Signed then ipow2 (k - 1) - 1
        else ipow2 k - 2)
        )
      | NINF -> Ok (of_int_repr f (ipow2 k - 1))

      | R x when x <. 0.0 ->
        let* v = wEncode f CER.(R (-. x)) in
        Ok (of_int_repr f ((to_int_repr f v) + (ipow2 (k - 1))))

      | R x when x = 0.0 -> Ok zero

      | R x ->
        let e : int = Int.max (floor_log2_abs x 32768) (1 - b) in
        let s = x *. (2 ^. (- e)) *. (2 ^. (p - 1)) in
        (* [s] is an integer *)
        let s = Real.to_int s in
        let t = s mod (ipow2 (p - 1)) in
        let z =
          if s < ipow2 (p - 1) then
            t
          else
            t + (e + b) * ipow2 (p - 1) in
        Ok (of_int_repr f z)

      | _ -> Error "unreachable"


  (* 4.9.2 Project *)

  (** wProject extended real value [x] to P3109 format [f]. *)
  let wProject (f : Format.t) (pi : Projection.t) (x : CER.t) : (t, string) Result.t =
    let _, p, b, m_lo, m_hi, _, _ = Format.parameters f in
    let sat, rnd = pi in
    let r : CER.t = wRoundToPrecision p b rnd x in
    let s : CER.t = wSaturate m_lo m_hi sat rnd r f.s f.d in
    wEncode f s


  (** 6 Interconverting formats *)

  let encode754 (phi : IEEE754.Format.t) (x : CER.t) : IEEE754.t =
    (* See also IEEE754.ml *)
    IEEE754.round x phi IEEE754.RoundingMode.TowardZero

  (** 6.1 Conversion from IEEE Std 754 formats to P3109 *)

  let internal_convertFromIEEE754 (phi: IEEE754.Format.t) (f : Format.t) (pi : Projection.t) (x : IEEE754.t) : (t, string) Result.t =
    let open CER in
    match IEEE754.as_cer phi x with
    | Ok NaN -> Ok (nan f)
    | Ok r -> wProject f pi r
    | Error e -> Error e

  let convertFromIEEE754 (phi: IEEE754.Format.t) (f : Format.t) (pi : Projection.t) (x : IEEE754.t) : t =
    match internal_convertFromIEEE754 phi f pi x with
    | Ok r -> r
    | _ -> nan f (* unreachable by theorem internal_convertFromIEEE754_ok *)


  (** 6.2 Conversion from P3109 to IEEE Std 754 *)

  (* Convert [x] (in [f_x]) to IEEE−754 binary interchange format Binary{[k]} under IEEE−754 rounding mode [rnd754] *)
  let convertToIEEE754 (f : Format.t) (pi : Projection.t) (phi : IEEE754.Format.t) (x : t) : IEEE754.t =
    let open CER in
    if is_nan f x then (* canonical if defined else quiet *)
      IEEE754.canonical_nan phi
    else (
      match wDecode f x with
      | NaN -> IEEE754.quiet_nan phi
      | PINF -> IEEE754.pinf phi
      | NINF -> IEEE754.ninf phi
      | R y ->
        let _, _, _, _, _, p, b, m = IEEE754.Format.parameters phi in
        let r = wRoundToPrecision p b (snd pi) (r2a y) in
        let x = wSaturate (-. m) m (fst pi) (snd pi) r f.s f.d in
        encode754 phi x)


  (** 4.10 Interconverting formats *)

  (** Convert [x] (in [f_x]) to [f_z] with projection specification [pi] *)
  let convert (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) : (t, string) Result.t =
    wProject f_z pi (wDecode f_x x)


  (** 4.11 Arithmetic operations *)

  (** 4.11.1 Absolute Value, Negation *)

  let wAbs (x : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x with
    | NaN -> Ok NaN
    | NINF -> Ok PINF
    | PINF -> Ok PINF
    | R x -> Ok (R (Real.abs x))
    | _ -> Error "undefined"

  let internal_abs (f : Format.t) (x : t) : (t, string) Result.t =
    let open Signedness in
    if f.s = Unsigned then
      Error "precondition failure"
    else
      let* r = wAbs (wDecode f x) in
      wEncode f r

  (** Return the absolute value of [x] in [f] *)
  let abs (f : Format.t) (x : t) : t =
    match internal_abs f x  with
    | Ok x -> x
    | Error _ -> nan f (* unreachable by theorem internal_abs_ok *)


  let wNegate (x : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x with
    | NaN -> Ok NaN
    | NINF -> Ok PINF
    | PINF -> Ok NINF
    | R x -> Ok (R (-. x))
    | _ -> Error "undefined"

  let internal_negate (f : Format.t) (x : t) : (t, string) Result.t =
    let open Signedness in
    if f.s = Unsigned then
      Error "precondition failure"
    else
      let* r = wNegate (wDecode f x) in
      wEncode f r

  (** Return the negation of [x] in [f] *)
  let negate (f : Format.t) (x : t) : t =
    match internal_negate f x with
    | Ok r -> r
    | Error _ -> nan f (* unreachable by theorem internal_negate_ok *)


  (** 4.11.2 CopySign *)

  let wCopySign (x : CER.t) (y : CER.t) : (CER.t, string) Result.t =
    match x, y with
    | NaN, _ -> Ok NaN
    | _, NaN -> Ok NaN
    | (PINF | NINF), PINF -> Ok PINF
    | (PINF | NINF), NINF -> Ok NINF
    | (PINF | NINF), R y when y >=. 0.0 -> Ok PINF
    | (PINF | NINF), R y when y <. 0.0 -> Ok NINF
    | R x,  PINF  -> Ok (R (Real.abs x))
    | R x,  NINF -> Ok (R (-. (Real.abs x)))
    | R x,  R y when y >=. 0.0 -> Ok (R (Real.abs x))
    | R x,  R y when y <. 0.0 -> Ok (R (-. (Real.abs x)))
    | _ -> Error "undefined"

  let internal_copySign (f : Format.t) (x : t) (y : t) : (t, string) Result.t =
    let* r = wCopySign (wDecode f x) (wDecode f y) in
    wEncode f r

  let copySign (f : Format.t) (x : t) (y : t) : t =
    match internal_copySign f x y with
    | Ok x -> x
    | Error _ -> nan f (* unreachable by theorem internal_copySign_ok *)


  (** 4.11.3 Addition, Subtraction *)

  let wAdd (x : CER.t) (y : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y with
    | NaN, _ -> Ok NaN
    | _, NaN -> Ok NaN
    | PINF, NINF -> Ok NaN
    | NINF, PINF -> Ok NaN
    | PINF, _ -> Ok PINF
    | _, PINF -> Ok PINF
    | NINF, _ -> Ok NINF
    |  _, NINF -> Ok NINF
    | R x, R y -> Ok (R (x +. y))
    | _ -> Error "undefined"

  let internal_add (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) (y : t)  : (t, string) Result.t =
    let* r = wAdd (wDecode f_x x) (wDecode f_y y) in
    wProject f_z pi r

  (** Add [x] (in [f_x]) to [y] (in [f_y]), and return in [f_z] under projection specification [pi] *)
  let add (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) (y : t)  : t =
    match internal_add f_x f_y f_z pi x y with
    | Ok z -> z
    | Error _ -> nan f_z (* unreachable by theorem internal_add_ok *)

  let wSubtract (x : CER.t) (y : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y with
    | NaN, _ -> Ok NaN
    | _, NaN -> Ok NaN
    | PINF, PINF -> Ok NaN
    | NINF, NINF -> Ok NaN
    | _, PINF -> Ok NINF
    | PINF, _ -> Ok PINF
    | _, NINF -> Ok PINF
    | NINF, _ -> Ok NINF
    | R x, R y -> Ok (R (x -. y))
    | _ -> Error "undefined"

  let internal_subtract (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) (y : t) : (t, string) Result.t =
    let* r = wSubtract (wDecode f_x x) (wDecode f_y y) in
    wProject f_z pi r

  (** For [x] (in [f_x]), [y] (in [f_y]) compute [x-y] and return in [f_z],
      with projection specification [pi] *)
  let subtract (f_x : Format.t) (f_y : Format.t) (x : t) (y : t)
      (f_z : Format.t) (pi : Projection.t) :
      t =
    match internal_subtract f_x f_y f_z pi x y with
    | Ok x -> x
    | Error _ -> nan f_z (* unreachable by theorem internal_subtract_ok *)


    (** 4.11.4 Multiplication *)

  let wMultiply (x : CER.t) (y : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y with
    | NaN, _ -> Ok NaN
    | _, NaN -> Ok NaN
    | PINF, PINF -> Ok PINF
    | NINF, NINF -> Ok PINF
    | NINF, PINF -> Ok NINF
    | PINF, NINF -> Ok NINF
    | PINF, R y when y >. 0.0 -> Ok PINF
    | PINF, R y when y = 0.0 -> Ok NaN
    | PINF, R y when y <. 0.0 -> Ok NINF
    | R x, PINF when x >. 0.0 -> Ok PINF
    | R x, PINF when x = 0.0 -> Ok NaN
    | R x, PINF when x <. 0.0 -> Ok NINF
    | NINF, R y when y >. 0.0 -> Ok NINF
    | NINF, R y when y = 0.0 -> Ok NaN
    | NINF, R y when y <. 0.0 -> Ok PINF
    | R x, NINF when x >. 0.0 -> Ok NINF
    | R x, NINF when x = 0.0 -> Ok NaN
    | R x, NINF when x <. 0.0 -> Ok PINF
    | R x, R y -> Ok (R (x *. y))
    | _ -> Error "undefined"

  let internal_multiply (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) (y : t) : (t, string) Result.t =
    let* r = wMultiply (wDecode f_x x) (wDecode f_y y) in
    wProject f_z pi r

  (** For [x] (in [f_x]), [y] (in [f_y]) compute x * y and return in [f_z],
      with rounding mode [rnd] and saturation mode [ovf] *)
  let multiply (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) (y : t) : t =
    match internal_multiply f_x f_y f_z pi x y with
    | Ok x -> x
    | Error _ -> nan f_z (* unreachable by theorem internal_multiply_ok *)


  (** 4.11.5 Division *)

  let wDivide (x : CER.t) (y : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y with
    | NaN, _ -> Ok NaN
    | _, NaN -> Ok NaN
    | (PINF | NINF), (PINF | NINF) -> Ok NaN
    | _, R 0.0 -> Ok NaN
    | PINF, R y when y >. 0.0 -> Ok PINF
    | PINF, R y when y <. 0.0 -> Ok NINF
    | NINF, R y when y >. 0.0 -> Ok NINF
    | NINF, R y when y <. 0.0 -> Ok PINF
    | _, (PINF | NINF) -> Ok (R 0.0)
    | R x, R y -> Ok (R (x /. y))
    | _ -> Error "undefined"

  let internal_divide (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) (y : t) : (t, string) Result.t =
    let* r = wDivide (wDecode f_x x) (wDecode f_y y) in
    wProject f_z pi r

  (** For [x] (in [f_x]), [y] (in [f_y]) compute x / y and return in [f_z],
      with rounding mode [rnd] and saturation mode [ovf] *)
  let divide (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) (y : t) : t =
  match internal_divide f_x f_y  f_z pi x y with
  | Ok x -> x
  | Error _ -> nan f_z (* unreachable by theorem internal_divide_ok *)


  (** 4.11.6 Fused Multiply-Add *)

  let wFMA (x : CER.t) (y : CER.t) (z : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y, z with
    | NaN, _ , _ -> Ok NaN
    | _ , NaN, _ -> Ok NaN
    | _ , _, NaN -> Ok NaN

    | R 0.0, (PINF | NINF), _ -> Ok NaN
    | (PINF | NINF), R 0.0, _ -> Ok NaN

    | R x, PINF, PINF when x <. 0.0 -> Ok NaN
    | R x, NINF, PINF when x >. 0.0 -> Ok NaN
    | PINF, R y, PINF when y <. 0.0 -> Ok NaN
    | NINF, R y, PINF when y >. 0.0 -> Ok NaN

    | R x, NINF, NINF when x <. 0.0 -> Ok NaN
    | R x, PINF, NINF when x >. 0.0 -> Ok NaN
    | NINF, R y, NINF when y <. 0.0 -> Ok NaN
    | PINF, R y, NINF when y >. 0.0 -> Ok NaN

    | NINF, PINF, PINF -> Ok NaN
    | PINF, NINF, PINF -> Ok NaN
    | PINF, PINF, NINF -> Ok NaN
    | NINF, NINF, NINF -> Ok NaN

    | PINF, PINF, _ -> Ok PINF
    | NINF, NINF, _ -> Ok PINF
    | PINF, NINF, _ -> Ok NINF
    | NINF, PINF, _ -> Ok NINF

    | _, _, NINF -> Ok NINF
    | R x, NINF, R z when x >=. 0.0 -> Ok NINF
    | R x, NINF, R z when x <. 0.0 -> Ok PINF

    | _, _, PINF -> Ok PINF
    | R x, PINF, R z when x >=. 0.0 -> Ok PINF
    | R x, PINF, R z when x <. 0.0 -> Ok NINF

    | PINF, R y, R z when y >=. 0.0 -> Ok PINF
    | PINF, R y, R z when y <. 0.0 -> Ok NINF

    | NINF, R y, R z when y >=. 0.0 -> Ok NINF
    | NINF, R y, R z when y <. 0.0 -> Ok PINF

    | R x, R y, R z -> Ok (R (x *. y +. z))

    | _ -> Error "undefined"

  let internal_fma (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (f_r: Format.t) (pi : Projection.t) (x : t) (y : t) (z : t): (t, string) Result.t =
    let* r = wFMA (wDecode f_x x) (wDecode f_y y) (wDecode f_z z) in
    wProject f_r pi r

  let fma (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (f_r: Format.t) (pi : Projection.t) (x : t) (y : t) (z : t): t =
    match internal_fma f_x f_y f_z f_r pi x y z with
    | Ok r -> r
    | Error _ -> (nan f_r) (* unreachable by theorem internal_fma_ok *)


  (** 4.11.7 Fused Add-Add *)

  let wFAA (x : CER.t) (y : CER.t) (z : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y, z with
    | NaN, _ , _ -> Ok NaN
    | _ , NaN, _ -> Ok NaN
    | _ , _, NaN -> Ok NaN
    | PINF, NINF, _ -> Ok NaN
    | NINF, PINF, _ -> Ok NaN
    | PINF, _, NINF -> Ok NaN
    | NINF, _, PINF -> Ok NaN
    | _, PINF, NINF -> Ok NaN
    | _, NINF, PINF -> Ok NaN
    | PINF, PINF, PINF -> Ok PINF
    | NINF, NINF, NINF -> Ok NINF
    | _, PINF, PINF -> Ok PINF
    | PINF, _, PINF -> Ok PINF
    | PINF, PINF, _ -> Ok PINF
    | _, NINF, NINF -> Ok NINF
    | NINF, _, NINF -> Ok NINF
    | NINF, NINF, _ -> Ok NINF
    | PINF, _, _ -> Ok PINF
    | _, PINF, _ -> Ok PINF
    | _, _, PINF -> Ok PINF
    | NINF, _, _ -> Ok NINF
    | _, NINF, _ -> Ok NINF
    | _, _, NINF -> Ok NINF
    | R x, R y, R z -> Ok (R (x +. y +. z))
    | _ -> Error "undefined"

  let internal_faa (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (f_r: Format.t) (pi : Projection.t) (x : t) (y : t) (z : t): (t, string) Result.t =
    let* r = wFAA (wDecode f_x x) (wDecode f_y y) (wDecode f_z z) in
    wProject f_r pi r

  let faa (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (f_r: Format.t) (pi : Projection.t) (x : t) (y : t) (z : t): t =
    match internal_faa f_x f_y f_z f_r pi x y z with
    | Ok r -> r
    | Error _ -> (nan f_r) (* unreachable by theorem internal_faa_ok *)


  (** 4.11.8 Square root, Logarithm, Exponentiation, Reciprocal *)

  let wSqrt (x : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x with
    | NaN -> Ok NaN
    | NINF -> Ok NaN
    | R x when x <. 0.0 -> Ok NaN
    | PINF -> Ok PINF
    | R x ->
      (match Sqrt.sqrt x 8 with (* TODO: Proof that 8 is enough *)
      | Ok r -> Ok (R r)
      | Error e -> Error e)
    | _ -> Error "undefined"

  let internal_sqrt (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) : (t, string) Result.t =
    let* r = wSqrt (wDecode f_x x) in
    wProject f_z pi r

  let sqrt (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) : t =
    match internal_sqrt f_x f_z pi x with
    | Ok x -> x
    | Error _ -> (nan f_z) (* unreachable by theorem internal_sqrt_ok *)

  let wRSqrt (x : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x with
    | NaN -> Ok NaN
    | NINF -> Ok NaN
    | R x when x <=. 0.0 -> Ok NaN
    | PINF -> Ok (R 0.0)
    | R x ->
      (match Util.reciprocal (Sqrt.sqrt x 8) with (* TODO: Proof that 8 is enough *)
      | Ok r -> Ok (R r)
      | Error e -> Error e)
    | _ -> Error "undefined"

  let internal_rsqrt (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) : (t, string) Result.t =
    let* r = wRSqrt (wDecode f_x x) in
    wProject f_z pi r

  let rsqrt (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) : t =
  match internal_rsqrt f_x f_z pi x with
  | Ok x -> x
  | Error _ -> (nan f_z) (* unreachable by theorem internal_rsqrt_ok *)

  let wExp (x : CER.t) : (CER.t, string) Result.t =
    match x with
    | NaN -> Ok NaN
    | PINF -> Ok PINF
    | NINF -> Ok (R 0.0)
    | R x -> Ok (R (Exp.exp x 9)) (* TODO: Proof that 9 is enough *)
    | _ -> Error "undefined"

  let internal_exp (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) : (t, string) Result.t =
    let* z = wExp (wDecode f_x x) in
    wProject f_z pi z

  let exp (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) : t =
    match internal_exp f_x f_z pi x with
    | Ok x -> x
    | Error _ -> (nan f_z) (* unreachable by theorem internal_exp_ok *)

  let wLog (x : CER.t) : (CER.t, string) Result.t =
    match x with
    | NaN -> Ok NaN
    | NINF -> Ok NaN
    | PINF -> Ok PINF
    | R x when x <. 0.0 -> Ok NaN
    | R x when x = 0.0 -> Ok NINF
    | R x -> (
      match Log.ln x 9 with (* TODO: Proof that 9 is enough *)
      | Ok r -> Ok (R r)
      | Error e -> Error e)
    | _ -> Error "undefined"

  let internal_log (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) : (t, string) Result.t =
    let* z = wLog (wDecode f_x x) in
    wProject f_z pi z

  let log (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) : t =
    match internal_log f_x f_z pi x with
    | Ok x -> x
    | Error _ -> nan f_z (* unreachable by theorem internal_log_ok *)

  let wExp2 (x : CER.t) : (CER.t, string) Result.t =
    match x with
    | NaN -> Ok NaN
    | PINF -> Ok PINF
    | NINF -> Ok (R 0.0)
    | R x -> (
      match Exp.exp2 x 9 with (* TODO: Proof that 9 is enough *)
      | Ok r -> Ok (R r)
      | Error e -> Error e)
    | _ -> Error "undefined"

  let internal_exp2 (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) : (t, string) Result.t =
    let* z = wExp2 (wDecode f_x x) in
    wProject f_z pi z

  let exp2 (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) : t =
    match internal_exp2 f_x f_z pi x with
    | Ok x -> x
    | Error _ -> nan f_z (* unreachable by theorem internal_exp2_ok *)

  let wLog2 (x : CER.t) : (CER.t, string) Result.t =
    match x with
    | NaN -> Ok NaN
    | NINF -> Ok NaN
    | PINF -> Ok PINF
    | R x when x <. 0.0 -> Ok NaN
    | R x when x = 0.0 -> Ok NINF
    | R x -> (
      match Log.log2 x 9 with (* TODO: Proof that 9 is enough *)
      | Ok r -> Ok (R r)
      | Error e -> Error e)
    | _ -> Error "undefined"

  let internal_log2 (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) : (t, string) Result.t =
    let* z = wLog2 (wDecode f_x x) in
    wProject f_z pi z

  let log2 (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) : t =
    match internal_log2 f_x f_z pi x with
    | Ok x -> x
    | Error _ -> nan f_z (* unreachable by theorem internal_log2_ok *)

  let wRecip (x : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x with
    | NaN -> Ok NaN
    | R x when x = 0.0 -> Ok NaN
    | (PINF | NINF) -> Ok (R 0.0)
    | R x -> Ok (R (1.0 /. x))
    | _ -> Error "undefined"

  let internal_recip  (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) : (t, string) Result.t =
    let* r = wRecip (wDecode f_x x) in
    wProject f_z pi r

  let recip (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) : t =
    match internal_recip f_x f_z pi x with
    | Ok x -> x
    | Error _ -> (nan f_z) (* unreachable by theorem internal_recip_ok *)


  (** 4.11.9 Hypotenuse *)

  let wHypot (x : CER.t) (y : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y with
    | NaN, _ -> Ok NaN
    | _, NaN -> Ok NaN
    | _, (PINF | NINF) -> Ok PINF
    | (PINF | NINF), _ -> Ok PINF
    | R x, R y ->
      (match Sqrt.sqrt ((Util.ripow (Real.abs x) 2) +. (Util.ripow (Real.abs y) 2)) 8 with (* TODO: Proof that 8 is enough *)
      | Ok r -> Ok (R r)
      | Error e -> Error e)
    | _ -> Error "undefined"

  let internal_hypot (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) (y : t) : (t, string) Result.t =
    let* z = wHypot (wDecode f_x x) (wDecode f_y y) in
    wProject f_z pi z

  let hypot (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) (y : t): t =
    match internal_hypot f_x f_y f_z pi x y with
    | Ok r -> r
    | Error _ -> nan f_z (* unreachable by theorem internal_hypot_ok *)


  (** 4.12 Extrema *)

  (** 4.12.1 Minimum and Maximum *)

  let wMinimum (x : CER.t) (y : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y with
    | NaN, _ -> Ok NaN
    | _, NaN -> Ok NaN
    | PINF, PINF -> Ok PINF
    | NINF, NINF -> Ok NINF
    | PINF, NINF -> Ok NINF
    | NINF, PINF -> Ok NINF
    | PINF, R y -> Ok (R y)
    | R x, PINF -> Ok (R x)
    | NINF, _ -> Ok NINF
    | _, NINF -> Ok NINF
    | R x, R y -> Ok (if x <. y then (R x) else (R y))
    | _ -> Error "undefined"

  let internal_minimum (f : Format.t) (x : t) (y : t) : (t, string) Result.t =
    let* r = wMinimum (wDecode f x) (wDecode f y) in
    wEncode f r

  let minimum (f : Format.t) (x : t) (y : t)  : t =
    match internal_minimum f x y  with
    | Ok r -> r
    | Error _ -> nan f (* unreachable by theorem internal_minimum_ok *)

  let wMaximum (x : CER.t) (y : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y with
    | NaN, _ -> Ok NaN
    | _, NaN -> Ok NaN
    | PINF, PINF -> Ok PINF
    | NINF, NINF -> Ok NINF
    | PINF, NINF -> Ok PINF
    | NINF, PINF -> Ok PINF
    | PINF, _ -> Ok PINF
    | _, PINF -> Ok PINF
    | NINF, R y -> Ok (R y)
    | R x, NINF -> Ok (R x)
    | R x, R y -> Ok (if x <. y then (R y) else (R x))
    | _ -> Error "undefined"

  let internal_maximum (f : Format.t) (x : t) (y : t) : (t, string) Result.t =
    let* r = wMaximum (wDecode f x) (wDecode f y) in
    wEncode f r

  let maximum (f : Format.t) (x : t) (y : t) : t =
    match internal_maximum f x y  with
    | Ok r -> r
    | Error _ -> nan f (* unreachable by theorem internal_maximum_ok *)


  (** 4.xx Minimum, Maximum, and 'Number' variants *)

  let wMinimumNumber (x : CER.t) (y : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y with
    | NaN, NaN -> Ok NaN
    | x, NaN -> Ok x
    | NaN, y -> Ok y
    | x, y -> wMinimum x y
    | _ -> Error "undefined"

  let internal_minimumNumber (f : Format.t) (x : t) (y : t) : (t, string) Result.t =
    let* r = wMinimumNumber (wDecode f x) (wDecode f y) in
    wEncode f r

  let minimumNumber (f : Format.t) (x : t) (y : t) : t =
    match internal_minimumNumber f x y with
    | Ok r -> r
    | Error _ -> nan f (* unreachable by theorem internal_minimum_number_ok *)

  let wMaximumNumber (x : CER.t) (y : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y with
    | NaN, NaN -> Ok NaN
    | x, NaN -> Ok x
    | NaN, y -> Ok y
    | x, y -> wMaximum x y
    | _ -> Error "undefined"

  let internal_maximumNumber (f : Format.t) (x : t) (y : t) : (t, string) Result.t =
    let* r = wMaximumNumber (wDecode f x) (wDecode f y) in
    wEncode f r

  let maximumNumber (f : Format.t) (x : t) (y : t) : t =
    match internal_maximumNumber f x y with
    | Ok r -> r
    | Error _ -> nan f (* unreachable by theorem internal_maximum_number_ok *)

  (** 4.xx MinimumMagnitude, MaximumMagnitude, and 'Number' variants *)

  let wMinimumMagnitude (x : CER.t) (y : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y with
    | NaN, _ -> Ok NaN
    | _, NaN -> Ok NaN
    | PINF, PINF -> Ok PINF
    | NINF, NINF -> Ok NINF
    | PINF, NINF -> Ok NINF
    | NINF, PINF -> Ok NINF
    | (PINF | NINF), R y  -> Ok (R y)
    | R x, (PINF | NINF)  -> Ok (R x)
    | R x, R y when Real.abs x <. Real.abs y -> Ok (R x)
    | R x, R y when Real.abs x >. Real.abs y -> Ok (R y)
    | R x, R y when Real.abs x = Real.abs y -> Ok (if x <. y then (R x) else (R y)) [@ocaml.text "breakindent"]
    | _ -> Error "undefined"

  let internal_minimumMagnitude (f : Format.t) (x : t) (y : t) : (t, string) Result.t =
    let* r = wMinimumMagnitude (wDecode f x) (wDecode f y) in
    wEncode f r

  let minimumMagnitude (f : Format.t) (x : t) (y : t)  : t =
    match internal_minimumMagnitude f x y  with
    | Ok r -> r
    | Error _ -> nan f (* unreachable by theorem internal_minimum_magnitude_ok *)

  let wMaximumMagnitude (x : CER.t) (y : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y with
    | NaN, _ -> Ok NaN
    | _, NaN -> Ok NaN
    | PINF, _ -> Ok PINF
    | _, PINF -> Ok PINF
    | NINF, _ -> Ok NINF
    | _, NINF  -> Ok NINF
    | R x, R y when Real.abs x >. Real.abs y -> Ok (R x)
    | R x, R y when Real.abs x <. Real.abs y -> Ok (R y)
    | R x, R y when Real.abs x = Real.abs y -> Ok (if x <. y then (R y) else (R x)) [@ocaml.text "breakindent"]
    | _ -> Error "undefined"

  let internal_maximumMagnitude (f : Format.t) (x : t) (y : t) : (t, string) Result.t =
    let* r = wMaximumMagnitude (wDecode f x) (wDecode f y) in
    wEncode f r

  let maximumMagnitude (f : Format.t) (x : t) (y : t) : t =
    match internal_maximumMagnitude f x y  with
    | Ok r -> r
    | Error _ -> nan f (* unreachable by theorem internal_maximum_magnitude_ok *)

  let wMinimumMagnitudeNumber (x : CER.t) (y : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y with
    | NaN, _ -> Ok x
    | _, NaN -> Ok y
    | _, _ -> wMinimumMagnitude x y

  let internal_minimumMagnitudeNumber (f : Format.t) (x : t) (y : t) : (t, string) Result.t =
    let* r = wMinimumMagnitudeNumber (wDecode f x) (wDecode f y) in
    wEncode f r

  let minimumMagnitudeNumber (f : Format.t) (x : t) (y : t) : t =
    match internal_minimumMagnitudeNumber f x y  with
    | Ok r -> r
    | Error _ -> nan f (* unreachable by theorem internal_minimum_magnitude_number_ok *)

  let wMaximumMagnitudeNumber (x : CER.t) (y : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y with
    | NaN, _ -> Ok x
    | _, NaN -> Ok y
    | _, _ -> wMaximumMagnitude x y

  let internal_maximumMagnitudeNumber (f : Format.t) (x : t) (y : t) : (t, string) Result.t =
    let* r = wMaximumMagnitudeNumber (wDecode f x) (wDecode f y) in
    wEncode f r

  let maximumMagnitudeNumber (f : Format.t) (x : t) (y : t) : t =
    match internal_maximumMagnitudeNumber f x y  with
    | Ok r -> r
    | Error _ -> nan f (* unreachable by theorem internal_maximum_magnitude_number_ok *)


  (** 4.10.2 MinimumFinite, MaximumFinite *)

  let wMinimumFinite (x : CER.t) (y : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y with
    | NaN, NaN -> Ok NaN
    | NaN, y -> Ok y
    | x, NaN -> Ok x
    | PINF, PINF -> Ok PINF
    | NINF, NINF -> Ok NINF
    | PINF, NINF -> Ok NINF
    | NINF, PINF -> Ok NINF
    | PINF, R y -> Ok (R y)
    | R x, PINF -> Ok (R x)
    | NINF, R y -> Ok (R y)
    | R x, NINF -> Ok (R x)
    | R x, R y -> Ok (if x <. y then (R x) else (R y)) [@ocaml.text "breakindent"]
    | _ -> Error "undefined"

  let internal_minimumFinite (f : Format.t) (x : t) (y : t) : (t, string) Result.t =
    let* r = wMinimumFinite (wDecode f x) (wDecode f y) in
    wEncode f r

  let minimumFinite (f : Format.t) (x : t) (y : t) : t =
    match internal_minimumFinite f x y  with
    | Ok r -> r
    | Error _ -> nan f (* unreachable by theorem internal_minimum_finite_ok *)

  let wMaximumFinite (x : CER.t) (y : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y with
    | NaN, NaN -> Ok NaN
    | NaN, y -> Ok y
    | x, NaN -> Ok x
    | PINF, PINF -> Ok PINF
    | NINF, NINF -> Ok NINF
    | PINF, NINF -> Ok PINF
    | NINF, PINF -> Ok PINF
    | PINF, R y -> Ok (R y)
    | R x, PINF -> Ok (R x)
    | NINF, R y -> Ok (R y)
    | R x, NINF -> Ok (R x)
    | R x, R y -> Ok (if x <. y then (R y) else (R x)) [@ocaml.text "breakindent"]
    | _ -> Error "undefined"

  let internal_maximumFinite (f : Format.t) (x : t) (y : t) : (t, string) Result.t =
    let* r = wMaximumFinite (wDecode f x) (wDecode f y) in
    wEncode f r

  let maximumFinite (f : Format.t) (x : t) (y : t) : t =
    match internal_maximumFinite f x y  with
    | Ok r -> r
    | Error _ -> nan f (* unreachable by theorem internal_maximum_finite_ok *)


  (**  4.12.4 Clamp *)

  let wClamp (x : CER.t) (lo : CER.t) (hi : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, lo, hi with
    | NaN, _, _ -> Ok NaN
    | _, NaN, _ -> Ok NaN
    | _, _, NaN -> Ok NaN

    | _, R lo, R hi when lo >. hi -> Ok NaN

    | _, PINF, PINF -> Ok PINF
    | _, NINF, NINF -> Ok NINF
    | _, _, NINF -> Ok NaN
    | _, PINF, _ -> Ok NaN

    | PINF, _, PINF -> Ok PINF
    | PINF, _, R hi -> Ok (R hi)
    | NINF, NINF, _ -> Ok NINF
    | NINF, R lo, _ -> Ok (R lo)
    | R x, NINF, PINF -> Ok (R x)

    | R x, NINF, R hi when x <=. hi -> Ok (R x)
    | R x, NINF, R hi when x >. hi -> Ok (R hi)
    | R x, R lo, PINF when x <=. lo -> Ok (R lo)
    | R x, R lo, PINF when x >. lo -> Ok (R x)

    | R x, R lo, R hi -> Ok (R (
        if x <=. lo then lo
        else if x >=. hi then hi
        else x))
    | _ -> Error "undefined"

  let internal_clamp (f : Format.t) (x : t) (lo : t) (hi : t) : (t, string) Result.t =
    let* r = wClamp (wDecode f x) (wDecode f lo) (wDecode f hi) in
    wEncode f r

  let clamp (f : Format.t) (x : t) (lo : t) (hi : t) : t =
    match internal_clamp f x lo hi with
    | Ok r -> r
    | Error _ -> nan f (* unreachable by theorem internal_clamp_ok *)


  (** 4.13 Comparisons *)

  let wCompareLess (x : CER.t) (y : CER.t) : (bool, string) Result.t =
    let open CER in
    match x, y with
    | NaN, _ -> Ok false
    | _, NaN -> Ok false
    | PINF, _ -> Ok false
    | _, PINF -> Ok true
    | NINF, NINF -> Ok false
    | NINF, _ -> Ok true
    | _, NINF -> Ok false
    | R x, R y -> Ok (x <. y)
    | _ -> Error "undefined"

  let internal_compareLess (f_x : Format.t) (f_y : Format.t)  (x : t) (y : t) : (bool, string) Result.t =
    wCompareLess (wDecode f_x x) (wDecode f_y y)

  let compareLess (f_x : Format.t) (f_y : Format.t) (x : t) (y : t)  : bool =
    match internal_compareLess f_x f_y x y  with
    | Ok r -> r
    | Error _ -> false (* unreachable by theorem internal_compare_less_ok *)


  let wCompareLessEqual (x : CER.t) (y : CER.t) : (bool, string) Result.t =
    let open CER in
    match x, y with
    | NaN, _ -> Ok false
    | _, NaN -> Ok false
    | _, PINF -> Ok true
    | NINF, _ -> Ok true
    | PINF, _ -> Ok false
    | _, NINF -> Ok false
    | R x, R y -> Ok (x <=. y)
    | _ -> Error "undefined"

  let internal_compareLessEqual (f_x : Format.t) (f_y : Format.t)  (x : t) (y : t) : (bool, string) Result.t =
    wCompareLessEqual (wDecode f_x x) (wDecode f_y y)

  let compareLessEqual (f_x : Format.t) (f_y : Format.t) (x : t) (y : t)  : bool =
    match internal_compareLessEqual f_x f_y x y  with
    | Ok r -> r
    | Error _ -> false (* unreachable by theorem internal_compare_less_equal_ok *)


  let wCompareEqual (x : CER.t) (y : CER.t) : (bool, string) Result.t =
    let open CER in
    match x, y with
    | NaN, _ -> Ok false
    | _, NaN -> Ok false
    | PINF, PINF -> Ok true
    | NINF, NINF -> Ok true
    | PINF, _ -> Ok false
    | NINF, _ -> Ok false
    | _, NINF -> Ok false
    | _, PINF -> Ok false
    | R x, R y -> Ok (x = y)
    | _ -> Error "undefined"

  let internal_compareEqual (f_x : Format.t) (f_y : Format.t)  (x : t) (y : t) : (bool, string) Result.t =
    wCompareEqual (wDecode f_x x) (wDecode f_y y)

  let compare_equal (f_x : Format.t) (f_y : Format.t) (x : t) (y : t)  : bool =
    match internal_compareEqual f_x f_y x y  with
    | Ok r -> r
    | Error _ -> false (* unreachable by theorem internal_compare_equal_ok *)


  let wCompareGreater (x : CER.t) (y : CER.t) : (bool, string) Result.t =
    let open CER in
    match x, y with
    | NaN, _ -> Ok false
    | _, NaN -> Ok false
    | _, PINF -> Ok false
    | NINF, NINF -> Ok false
    | _, NINF -> Ok true
    | PINF, _ -> Ok true
    | NINF, _ -> Ok false
    | R x, R y -> Ok (x >. y)
    | _ -> Error "undefined"

  let internal_compareGreater (f_x : Format.t) (f_y : Format.t)  (x : t) (y : t) : (bool, string) Result.t =
    wCompareGreater (wDecode f_x x) (wDecode f_y y)

  let compareGreater (f_x : Format.t) (f_y : Format.t) (x : t) (y : t)  : bool =
    match internal_compareGreater f_x f_y x y  with
    | Ok r -> r
    | Error _ -> false (* unreachable by theorem internal_compareGreater_ok *)


  let wCompareGreaterEqual (x : CER.t) (y : CER.t) : (bool, string) Result.t =
    let open CER in
    match x, y with
    | NaN, _ -> Ok false
    | _, NaN -> Ok false
    | PINF, _ -> Ok true
    | NINF, NINF -> Ok true
    | NINF, _ -> Ok false
    | _, PINF -> Ok false
    | _, NINF -> Ok true
    | R x, R y -> Ok (x >=. y)
    | _ -> Error "undefined"

  let internal_compareGreaterEqual (f_x : Format.t) (f_y : Format.t)  (x : t) (y : t) : (bool, string) Result.t =
    wCompareGreaterEqual (wDecode f_x x) (wDecode f_y y)

  let compareGreaterEqual (f_x : Format.t) (f_y : Format.t) (x : t) (y : t)  : bool =
    match internal_compareGreaterEqual f_x f_y x y  with
    | Ok r -> r
    | Error _ -> false (* unreachable by theorem internal_compareGreaterEqual_ok *)


  (** 4.10.3 Predicates and classification *)

  let wIsZero (x : CER.t) : (bool, string) Result.t =
    match x with
    | NaN -> Ok false
    | (PINF | NINF) -> Ok false
    | R x -> Ok (x = 0.0)
    | _ -> Error "undefined"

  let internal_isZero (f : Format.t) (x : t) : (bool, string) Result.t =
    wIsZero (wDecode f x)

  let isZero (f : Format.t) (x : t) : bool =
    match internal_isZero f x with
    | Ok r -> r
    | _ -> false (* unreachable by theorem internal_is_zero_ok *)


  let wIsOne (x : CER.t) : (bool, string) Result.t =
    match x with
    | NaN -> Ok false
    | (PINF | NINF) -> Ok false
    | R x -> Ok (x = 1.0)
    | _ -> Error "undefined"

  let internal_isOne (f : Format.t) (x : t) : (bool, string) Result.t =
    wIsOne (wDecode f x)

  let isOne (f : Format.t) (x : t) : bool =
    match internal_isOne f x with
    | Ok r -> r
    | _ -> false (* unreachable by theorem internal_is_one_ok *)

  let isNaN (f : Format.t) (x : t) : bool = is_nan f x [@@macro]

  let isFinite (f : Format.t) (x : t) : bool = not (is_ninf f x) && not (is_pinf f x) && not (is_nan f x) [@@macro]

  let isInfinite (f : Format.t) (x : t) : bool = is_ninf f x || is_pinf f x [@@macro]

  let wIsSignMinus (x : CER.t) : (bool, string) Result.t =
    match x with
    | NaN -> Ok false
    | PINF -> Ok false
    | NINF -> Ok true
    | R x -> Ok (x <. 0.0)
    | _ -> Error "undefined"

  let internal_isSignMinus (f : Format.t) (x : t) : (bool, string) Result.t =
    wIsSignMinus (wDecode f x)

  let isSignMinus (f : Format.t) (x : t) : bool =
    match internal_isSignMinus f x with
    | Ok r -> r
    | _ -> false (* unreachable by theorem internal_is_sign_minus_ok *)

  let isNormal (f : Format.t) (x : t) : bool =
    let open Signedness in
    let k, p, _, _, _, _, _ = Format.parameters f in
    match x with
    | _ when isZero f x || is_ninf f x || is_pinf f x || is_nan f x -> false
    | _ ->
      let x = to_int_repr f x in
      (match f.s with
      | Signed -> Util.machine_idiv (x mod (Util.ipow2 (k - 1))) (Util.ipow2 (p - 1)) > 0
      | Unsigned -> Util.machine_idiv x (Util.ipow2 (p - 1)) > 0)

  let isSubnormal (f : Format.t) (x : t) : bool =
    match x with
    | _ when isZero f x || is_ninf f x || is_pinf f x || is_nan f x -> false
    | _ -> not (isNormal f x)


  (** 4.14.1 Classifier operation *)

  type class_ =
    | NaN
    | NegativeInfinity
    | NegativeNormal
    | NegativeSubnormal
    | Zero
    | PositiveSubnormal
    | PositiveNormal
    | PositiveInfinity

  let internal_class (f : Format.t) (x : t) : (class_, string) Result.t =
    if is_nan f x then Ok NaN
    else if isInfinite f x && isSignMinus f x then Ok NegativeInfinity
    else if isNormal f x && isSignMinus f x then Ok NegativeNormal
    else if isSubnormal f x && isSignMinus f x then Ok NegativeSubnormal
    else if isZero f x then Ok Zero
    else if isSubnormal f x && not (isSignMinus f x) then Ok PositiveSubnormal
    else if isNormal f x && not (isSignMinus f x) then Ok PositiveNormal
    else if isInfinite f x && not (isSignMinus f x) then Ok PositiveInfinity
    else Error "unclassified"

  let class_ (f : Format.t) (x : t) : class_ =
    match internal_class f x with
    | Ok c -> c
    | Error _ -> NaN (* Unchreable by thm_class_internal_ok *)


  (** 4.14.2 Total order predicate *)

  let totalOrder (f_x : Format.t) (f_y : Format.t) (x : t) (y: t) : bool =
    match x, y with
    | _, _ when isNaN f_x x -> true
    | _, _ when isNaN f_y y -> false
    | _ -> compareLessEqual f_x f_y x y


  (** 4.14.3 Comparison predicates *)

  let equal f_x f_y x y = compare_equal f_x f_y x y

  let greater f_x f_y x y = compareGreater f_x f_y x y

  let greaterEqual f_x f_y x y = compareGreaterEqual f_x f_y x y

  let less f_x f_y x y = compareLess f_x f_y x y

  let lessEqual f_x f_y x y = compareLessEqual f_x f_y x y

  let ordered f_x f_y x y = totalOrder f_x f_y x y

  let notEqual f_x f_y x y = not (compare_equal f_x f_y x y)

  let notGreater f_x f_y x y = not (compareGreater f_x f_y x y)

  let notGreaterEqual f_x f_y x y = not (compareGreaterEqual f_x f_y x y)

  let notLess f_x f_y x y = not (compareLess f_x f_y x y)

  let notLessEqual f_x f_y x y = not (compareLessEqual f_x f_y x y)

  let unordered f_x f_y x y = not (totalOrder f_x f_y x y)


  (** Convert [x] to a string *)
  let to_string (f : Format.t) (x : t) : string =
    CER.to_string (wDecode f x)
  [@@program]


  (** 5 Block operations *)

  let rec reduce (f : CER.t -> CER.t -> (CER.t, string) Result.t) (x: CER.t list) : (CER.t, string) Result.t =
    match x with
    | [x1; x2] -> f x1 x2
    | x1 :: x2 :: rest ->
      let* fx1x2 = f x1 x2 in
      reduce f (fx1x2 :: rest)
    | _ -> Error "reduce: precondition violation"


  (** 5.1.1 DecodeBlock *)

  let map_wMultiply (f_s : Format.t) (f_x : Format.t) (s : t) (x : t list) : (CER.t, string) Result.t list =
    List.map (fun x_i -> wMultiply (wDecode f_s s) (wDecode f_x x_i)) x

  let wBlockDecode (b : int) (f_s : Format.t) (f_x : Format.t) (s, x : t * t list) : (CER.t list, string) Result.t =
    if b < 1 || b <> List.length x then
      Error "invalid block size"
    else
      let@ cz = map_wMultiply f_s f_x s x in
      Ok cz

  (** 5.1.2 EncodeBlock *)

  let map_project (f : Format.t) (pi : Projection.t) (x : CER.t list) : (t, string) Result.t list =
    List.map (wProject f pi) x

  let wBlockProject_map_cz cs x =
    List.map
      (fun x_i ->
        match cs with
        | CER.NaN | _ when x_i = CER.NaN -> Ok CER.NaN
        | R 0.0 -> Ok (R 0.0)
        | (PINF | NINF) -> Ok (R 1.0)
        | _ -> wDivide x_i cs)
      x

  let wBlockProject
    (b : int)
    (f_s : Format.t) (f_z : Format.t) (pi_z : Projection.t)
    (s, x : t * CER.t list) :
    (t list, string) Result.t =
    if b < 0 || b <> List.length x then
      Error "invalid block size"
    else
      let open CER in
      let cs = wDecode f_s s in
      let@ cz = wBlockProject_map_cz cs x in
      let@ z = map_project f_z pi_z cz in
      Ok z


  (** 5.2 Convert Blocks *)

  (** 5.2.1 ConvertFromBlock *)

  let convertFromBlock
    (b : int)
    (f_s : Format.t) (f_x : Format.t) (f_z : Format.t)
    (pi_s : Projection.t) (pi_z : Projection.t)
    (s, x : t * t list) :
    (t list, string) Result.t =
    if b < 0 || b <> List.length x then
      Error "invalid block size"
    else
      let* cz = wBlockDecode b f_s f_x (s, x) in
      let@ z = map_project f_z pi_z cz in
      Ok z


  (** 5.2.2 ConvertToBlock *)

  let map_decode f_x x = List.map (wDecode f_x) x

  let convertToBlock
    (b : int)
    (f_s : Format.t) (f_x : Format.t) (f_z : Format.t) (pi_z : Projection.t)
    (x, s : t list * t) :
    (t * t list, string) Result.t =
    let cx = map_decode f_x x in
    let* z = wBlockProject b f_s f_z pi_z (s, cx) in
    Ok (s, z)


  (** 5.2.3 ConvertToBlockMaxAbsFinite *)

  let map_wabs (x : CER.t list) : (CER.t, string) Result.t list = List.map wAbs x

  let reduce_wMaximumFinite (x : CER.t list) : (CER.t, string) Result.t =
    reduce wMaximumFinite (CER.zero :: x)

  let map_convert_maf s' cx =
    List.map (fun cx_i -> if s' = CER.zero then Ok CER.zero else wDivide cx_i s') cx

  let convertToBlockMaxAbsFinite
    (b : int)
    (f_s : Format.t) (f_x : Format.t) (f_z : Format.t)
    (pi_s : Projection.t) (pi_z : Projection.t)
    (x : t list) :
    (t * t list, string) Result.t =
    if (b < 1 || b <> List.length x) then
      Error "invalid block size"
    else
      let cx = map_decode f_x x in
      let@ m = map_wabs cx in
      let* cs = reduce_wMaximumFinite m in
      let* s = wProject f_s pi_s cs in
      let s' = wDecode f_s s in
      let@ cz = map_convert_maf s' cx in
      let@ z = map_project f_z pi_z cz in
      Ok (s, z)


  (** 5.3 Block reduction operations *)

  (** 5.3.1 Sum and product *)

  let reduce_wAdd (cp : CER.t list) : (CER.t, string) Result.t =
    reduce wAdd (CER.zero :: cp)

  let blockReduceAdd
    (b : int)
    (f_sx : Format.t) (f_x : Format.t)
    (f_z : Format.t) (pi_z : Projection.t)
    (s_x, x : t * t list) :
    (t, string) Result.t =
    let* cx = wBlockDecode b f_sx f_x (s_x, x) in
    let* cz = reduce_wAdd cx in
    let z = wProject f_z pi_z cz in
    z

  let reduce_wMultiply (cp : CER.t list) : (CER.t, string) Result.t =
    reduce wMultiply (CER.one :: cp)

  let blockReduceMultiply
    (b : int)
    (f_sx : Format.t) (f_x : Format.t)
    (f_z : Format.t) (pi_z : Projection.t)
    (s_x, x : t * t list) :
    (t, string) Result.t =
    let* cx = wBlockDecode b f_sx f_x (s_x, x) in
    let* cz = reduce_wMultiply cx in
    let z = wProject f_z pi_z cz in
    z


  (** 5.3 Dot Product *)

  let map2_wMultiply (cx : CER.t list) (cy : CER.t list) : ((CER.t, string) Result.t list, string) Result.t =
    List.map2 wMultiply cx cy

  let blockDotProduct
    (b : int)
    (f_sx : Format.t) (f_x : Format.t)
    (f_sy : Format.t) (f_y : Format.t)
    (f_z : Format.t)
    (pi_z : Projection.t)
    (s_x, x : t * t list)
    (s_y, y : t * t list) :
    (t, string) Result.t =
    let* cx = wBlockDecode b f_sx f_x (s_x, x) in
    let* cy = wBlockDecode b f_sy f_y (s_y, y) in
    let*@ cp = map2_wMultiply cx cy in
    let* cz = reduce_wAdd cp in
    let* z = wProject f_z pi_z cz in
    Ok z


  (** 5.4 Elementwise operations on blocks *)

  type block_op_parameter = {
    f_s : Format.t;
    f_x : Format.t;
  }

  type block_op_argument = {
    s : t;
    x : t list;
  }

  let rec nth_r n = function
    | [] -> Error "invalid index"
    | y :: tail ->
      if n = 0 then
        Ok y
      else
        nth_r (n - 1) tail
  [@@adm 1n]

  (* Custom map2-like decoding of a list of blocks in params and args. *)
  let rec block_op_map2_wBlockDecode_aux b params args : (CER.t list, string) Result.t list =
    match params, args with
    | [], [] -> []
    | p :: params, a :: args ->
      (wBlockDecode b p.f_s p.f_x (a.s, a.x)) :: block_op_map2_wBlockDecode_aux b params args
    | _ -> []

  let block_op_map2_wBlockDecode b params args : ((CER.t list, string) Result.t list, string) Result.t =
    if List.length params <> List.length args then
      Error "invalid arguments"
    else
      Ok (block_op_map2_wBlockDecode_aux b params args)

  (* Alternative via List.map2, if we can make it work *)
  (* let block_op_map2wBlockDecode b params args =
    List.map2 (fun p a -> wBlockDecode b p.f_s p.f_x (a.s, a.x)) params args *)

  let block_op_map2_wop_unary wOp (xs : CER.t list) : ((CER.t, string) Result.t list, string) Result.t =
    Ok (List.map (fun x_i -> wOp x_i) xs)

  let block_op_map2_wop_binary wOp (xs : CER.t list) (ys : CER.t list) : ((CER.t, string) Result.t list, string) Result.t =
    List.map2 (fun x_i y_i -> wOp x_i y_i) xs ys

  let rec block_op_map2_wop_ternary wOp (xs : CER.t list) (ys : CER.t list) (zs : CER.t list) : ((CER.t, string) Result.t list, string) Result.t =
    let open Result in
    match xs, ys, zs with
    | [], [], [] -> Ok []
    | x :: xs, y :: ys, z :: zs ->
      block_op_map2_wop_ternary wOp xs ys zs >|= List.cons (wOp x y z)
    | _, _, _ -> Error "Lengths of xs, ys, zs don't match"

  let block_op_unary
    (b : int)
    (params : block_op_parameter list)
    (f_s : Format.t)
    (f_z : Format.t)
    (s_z : t)
    (pi_z : Projection.t)
    (args: block_op_argument list)
    (wOp : CER.t -> (CER.t, string) Result.t)
    :
    (t * t list, string) Result.t =
    if b < 1 ||
      List.length params <> List.length args ||
      List.length args <> 1 ||
      not (List.for_all (fun a_i -> List.length a_i.x = b) args) then
      Error "invalid arguments"
    else (
      let*@ cxs = block_op_map2_wBlockDecode b params args in
      let* x1 = nth_r 0 cxs in
      let*@ cz = block_op_map2_wop_unary wOp x1 in
      let* z = wBlockProject b f_s f_z pi_z (s_z, cz) in
      Ok (s_z, z)
    )
    (* [@@macro] *)

  let block_op_binary
    (b : int)
    (params : block_op_parameter list)
    (f_s : Format.t)
    (f_z : Format.t)
    (s_z : t)
    (pi_z : Projection.t)
    (args: block_op_argument list)
    (wOp : CER.t -> CER.t -> (CER.t, string) Result.t)
    :
    (t * t list, string) Result.t =
    if b < 1 ||
      List.length params <> List.length args ||
      List.length args <> 2 ||
      not (List.for_all (fun a_i -> List.length a_i.x = b) args) then
      Error "invalid arguments"
    else (
      let*@ cxs = block_op_map2_wBlockDecode b params args in
      let* x1 = nth_r 0 cxs in
      let* x2 = nth_r 1 cxs in
      let*@ cz = block_op_map2_wop_binary wOp x1 x2 in
      let* z = wBlockProject b f_s f_z pi_z (s_z, cz) in
      Ok (s_z, z)
    )
    (* [@@macro] *)

  let block_op_ternary
    (b : int)
    (params : block_op_parameter list)
    (f_s : Format.t)
    (f_z : Format.t)
    (s_z : t)
    (pi_z : Projection.t)
    (args: block_op_argument list)
    (wOp : CER.t -> CER.t -> CER.t -> (CER.t, string) Result.t)
    :
    (t * t list, string) Result.t =
    if b < 1 ||
      List.length params <> List.length args ||
      List.length args <> 3 ||
      not (List.for_all (fun a_i -> List.length a_i.x = b) args) then
      Error "invalid arguments"
    else (
      let*@ cxs = block_op_map2_wBlockDecode b params args in
      let* x1 = nth_r 0 cxs in
      let* x2 = nth_r 1 cxs in
      let* x3 = nth_r 2 cxs in
      let*@ cz = block_op_map2_wop_ternary wOp x1 x2 x3 in
      let* z = wBlockProject b f_s f_z pi_z (s_z, cz) in
      Ok (s_z, z)
    )
    (* [@@macro] *)

  let blockAbs b f_sx f_x f_s f_z pi_s pi_z (s_x, x) s_z =
    block_op_unary b
      [{f_s = f_sx; f_x}]
      f_s f_z s_z pi_z
      [{s = s_x; x}]
      wAbs

  let blockNegate b f_sx f_x f_s f_z pi_s pi_z (s_x, x) s_z =
    block_op_unary b
      [{f_s = f_sx; f_x}]
      f_s f_z s_z pi_z
      [{s = s_x; x}]
      wNegate

  let blockExp b f_sx f_x f_s f_z pi_s pi_z (s_x, x) s_z =
    block_op_unary b
      [{f_s = f_sx; f_x}]
      f_s f_z s_z pi_z
      [{s = s_x; x}]
      wExp

  let blockSqrt b f_sx f_x f_s f_z pi_s pi_z (s_x, x) s_z =
    block_op_unary b
      [{f_s = f_sx; f_x}]
      f_s f_z s_z pi_z
      [{s = s_x; x}]
      wSqrt

  let blockRSqrt b f_sx f_x f_s f_z pi_s pi_z (s_x, x) s_z =
    block_op_unary b
      [{f_s = f_sx; f_x}]
      f_s f_z s_z pi_z
      [{s = s_x; x}]
      wRSqrt

  let blockExp2 b f_sx f_x f_s f_z pi_s pi_z (s_x, x) s_z =
    block_op_unary b
      [{f_s = f_sx; f_x}]
      f_s f_z s_z pi_z
      [{s = s_x; x}]
      wExp2

  let blockLog2 b f_sx f_x f_s f_z pi_s pi_z (s_x, x) s_z =
    block_op_unary b
      [{f_s = f_sx; f_x}]
      f_s f_z s_z pi_z
      [{s = s_x; x}]
      wLog2

  let blockLog b f_sx f_x f_s f_z pi_s pi_z (s_x, x) s_z =
    block_op_unary b
      [{f_s = f_sx; f_x}]
      f_s f_z s_z pi_z
      [{s = s_x; x}]
      wLog

  let blockRecip b f_sx f_x f_s f_z pi_s pi_z (s_x, x) s_z =
    block_op_unary b
      [{f_s = f_sx; f_x}]
      f_s f_z s_z pi_z
      [{s = s_x; x}]
      wRecip


  let blockCopySign b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z =
    block_op_binary b
      [{f_s = f_sx1; f_x = f_x1}; {f_s = f_sx2; f_x = f_x2}]
      f_s f_z s_z pi_z
      [{s=s_x1; x = x1}; {s=s_x2; x = x2}]
      wCopySign

  let blockAdd b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z =
    block_op_binary b
      [{f_s = f_sx1; f_x = f_x1}; {f_s = f_sx2; f_x = f_x2}]
      f_s f_z s_z pi_z
      [{s=s_x1; x = x1}; {s=s_x2; x = x2}]
      wAdd

  let blockSubtract b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z =
    block_op_binary b
      [{f_s = f_sx1; f_x = f_x1}; {f_s = f_sx2; f_x = f_x2}]
      f_s f_z s_z pi_z
      [{s=s_x1; x = x1}; {s=s_x2; x = x2}]
      wSubtract

  let blockMultiply b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z =
    block_op_binary b
      [{f_s = f_sx1; f_x = f_x1}; {f_s = f_sx2; f_x = f_x2}]
      f_s f_z s_z pi_z
      [{s=s_x1; x = x1}; {s=s_x2; x = x2}]
      wMultiply

  let blockDivide b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z =
    block_op_binary b
      [{f_s = f_sx1; f_x = f_x1}; {f_s = f_sx2; f_x = f_x2}]
      f_s f_z s_z pi_z
      [{s=s_x1; x = x1}; {s=s_x2; x = x2}]
      wDivide

  let blockHypot b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z =
    block_op_binary b
      [{f_s = f_sx1; f_x = f_x1}; {f_s = f_sx2; f_x = f_x2}]
      f_s f_z s_z pi_z
      [{s=s_x1; x = x1}; {s=s_x2; x = x2}]
      wHypot

  let blockMinimum b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z =
    block_op_binary b
      [{f_s = f_sx1; f_x = f_x1}; {f_s = f_sx2; f_x = f_x2}]
      f_s f_z s_z pi_z
      [{s=s_x1; x = x1}; {s=s_x2; x = x2}]
      wMinimum

  let blockMinimumNumber b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z =
    block_op_binary b
      [{f_s = f_sx1; f_x = f_x1}; {f_s = f_sx2; f_x = f_x2}]
      f_s f_z s_z pi_z
      [{s=s_x1; x = x1}; {s=s_x2; x = x2}]
      wMinimumNumber

  let blockMinimumMagnitude b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z =
    block_op_binary b
      [{f_s = f_sx1; f_x = f_x1}; {f_s = f_sx2; f_x = f_x2}]
      f_s f_z s_z pi_z
      [{s=s_x1; x = x1}; {s=s_x2; x = x2}]
      wMinimumMagnitude

  let blockMinimumMagnitudeNumber b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z =
    block_op_binary b
      [{f_s = f_sx1; f_x = f_x1}; {f_s = f_sx2; f_x = f_x2}]
      f_s f_z s_z pi_z
      [{s=s_x1; x = x1}; {s=s_x2; x = x2}]
      wMinimumMagnitudeNumber

  let blockMaximum b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z =
    block_op_binary b
      [{f_s = f_sx1; f_x = f_x1}; {f_s = f_sx2; f_x = f_x2}]
      f_s f_z s_z pi_z
      [{s=s_x1; x = x1}; {s=s_x2; x = x2}]
      wMaximum

  let blockMaximumNumber b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z =
    block_op_binary b
      [{f_s = f_sx1; f_x = f_x1}; {f_s = f_sx2; f_x = f_x2}]
      f_s f_z s_z pi_z
      [{s=s_x1; x = x1}; {s=s_x2; x = x2}]
      wMaximumNumber

  let blockMaximumMagnitude b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z =
    block_op_binary b
      [{f_s = f_sx1; f_x = f_x1}; {f_s = f_sx2; f_x = f_x2}]
      f_s f_z s_z pi_z
      [{s=s_x1; x = x1}; {s=s_x2; x = x2}]
      wMaximumMagnitude

  let blockMaximumMagnitudeNumber b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z =
    block_op_binary b
      [{f_s = f_sx1; f_x = f_x1}; {f_s = f_sx2; f_x = f_x2}]
      f_s f_z s_z pi_z
      [{s=s_x1; x=x1}; {s=s_x2; x=x2}]
      wMaximumMagnitudeNumber

  let blockFMA b f_sx1 f_x1 f_sx2 f_x2 f_sx3 f_x3 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) (s_x3, x3) s_z =
    block_op_ternary b
      [{f_s = f_sx1; f_x = f_x1}; {f_s = f_sx2; f_x = f_x2}; {f_s = f_sx3; f_x = f_x3}]
      f_s f_z s_z pi_z
      [{s = s_x1; x = x1}; {s = s_x2; x = x2}; {s = s_x3; x = x3}]
      wFMA

  let blockFAA b f_sx1 f_x1 f_sx2 f_x2 f_sx3 f_x3 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) (s_x3, x3) s_z =
    block_op_ternary b
      [{f_s = f_sx1; f_x = f_x1}; {f_s = f_sx2; f_x = f_x2}; {f_s = f_sx3; f_x = f_x3}]
      f_s f_z s_z pi_z
      [{s = s_x1; x = x1}; {s = s_x2; x = x2}; {s = s_x3; x = x3}]
      wFAA


  (** Extra: Show how to do ScaledAdd, ScaledFMA, ScaledMultiply with B=1 *)

  (** For [x, s_x] (in [f_x]), [y, s_y] (in [f_y]),
      compute [x] * [s_x] + [y] * [s_y] and return in [f_z],
      with projection specification [pi] *)
  let internal_scaledAdd f_x f_y f_z pi x s_x y s_y =
    let* s_z = wEncode f_z CER.one in (* Note: 1 is not in all formats, e.g. binary2p1se *)
    let* (_, r) = blockAdd 1 f_x f_x f_y f_y f_z f_z pi pi (s_x, [x]) (s_y, [y]) s_z in
    Ok (List.hd r)

  let scaledAdd (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) (s_x : t) (y : t) (s_y : t) : t =
    match internal_scaledAdd f_x f_y f_z pi x s_x y s_y with
    | Ok r -> r
    | Error _ -> nan f_z (* unreachable by theorem internal_scaled_add_ok *)

  (** For [x, s_x] (in [f_x]), [y, s_y] (in [f_y]),
      compute [x] * [y] * [s] and return in [f_z],
      with projection specification [pi] *)
  let internal_scaledMultiply f_x f_y f_z pi x s_x y s_y =
    let* s_z = wEncode f_z CER.one in (* Note: 1 is not in all formats, e.g. binary2p1se *)
    let* (_, r) = blockMultiply 1 f_x f_x f_y f_y f_z f_z pi pi (s_x, [x]) (s_y, [y]) s_z in
    Ok (List.hd r)

  let scaledMultiply (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) (s_x : t) (y : t) (s_y : t) : t =
    match internal_scaledMultiply f_x f_y f_z pi x s_x y s_y with
    | Ok r -> r
    | Error _ -> nan f_z (* unreachable by theorem internal_scaled_multiply_ok *)

  (** For [x] (in [f_x]), [y] (in [f_y]), [s_xy] (in [f_sxy]),
      [z] (in [f_z]) and [s_z] (in [f_sz]), compute
      [x] * [y] * [s_xy] + [z] * [s_z] and return in [f_r],
      with projection specification [pi] *)
  let internal_scaledFMA f_x f_y f_sxy f_z f_sz f_r pi x y s_xy z s_z =
    let* s_r = wEncode f_r CER.one in
    let* (_, r) = blockFMA 1 f_sxy f_x f_sxy f_y f_z f_sz f_r f_r pi pi (s_xy, [x]) (s_xy, [y]) (s_z, [z]) s_r in
    Ok (List.hd r)

  let scaledFMA
    (f_x : Format.t) (f_y : Format.t) (f_sxy : Format.t) (f_z : Format.t) (f_sz : Format.t) (f_r : Format.t) (pi : Projection.t)
    (x : t) (y : t) (s_xy : t) (z : t) (s_z : t) : t =
    match internal_scaledFMA f_x f_y f_sxy f_z f_sz f_r pi x y s_xy z s_z with
    | Ok r -> r
    | Error _ -> nan f_z (* unreachable by theorem internal_scaled_fma_ok *)


  (** 4.5 Format-level operations *)

  let bitWidthOf (f : Format.t) : int = Format.k f
  let precisionOf (f : Format.t) : int = Format.p f
  let signednessOf (f : Format.t) : Signedness.t = f.s
  let domainOf (f : Format.t) : Domain.t = f.d

  let exponentBitsOf (f : Format.t) : int =
    let k, p, _, _, _, _, _ = Format.parameters f in
    match f.s with
    | Signed -> k - p - 1
    | Unsigned -> k - p

  let trailingBitsOf (f : Format.t) : int =
    Format.p f - 1

  let exponentBiasOf (f : Format.t) : int =
    let k, p, _, _, _, s, _ = Format.parameters f in
    match s with
    | Signed -> if k = p then -1 else Util.ipow2 (k - p - 1)
    | Unsigned -> Util.ipow2 (k - p)

  let maxFiniteOf (f : Format.t) : (t, string) Result.t =
    let _, _, _, _, m_hi, _, _ = Format.parameters f in
    wEncode f (CER.R m_hi)

  let minFiniteOf (f : Format.t) : (t, string) Result.t =
    let _, _, _, m_lo, _, s, _ = Format.parameters f in
    wEncode f (CER.R m_lo)

  let minPositiveOf (f : Format.t) : (t, string) Result.t =
    let open Signedness in
    let open Domain in
    let k, p, _, _, _, s, d = Format.parameters f in
    match k, p, s, d with
    | 2, _, Signed, Extended -> pinf f
    | _ -> Ok 1

  let minNormalOf (f : Format.t) : (t, string) Result.t =
    let open Signedness in
    let open Domain in
    let k, p, b, _, _, s, d = Format.parameters f in
    match k, p, s, d with
    | 2, 1, Signed, Extended -> Ok (nan f)
    | 2, 2, Unsigned, Extended -> Ok (nan f)
    | _ -> Ok (Util.ipow2 (p - 1))


end