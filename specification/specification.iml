[@@@import Util, "dune:math"]
[@@@import ExReal, "dune:math"]
[@@@import IEEE754, "IEEE754.iml"]
[@@@import Binary16, "binary16.iml"]

(** Format definitions *)

module Format = struct
  type t =
    | B8P1
    | B8P2
    | B8P3
    | B8P4
    | B8P5
    | B8P6
    | B8P7

  let precision (fmt : t) =
    match fmt with
    | B8P1 -> 1
    | B8P2 -> 2
    | B8P3 -> 3
    | B8P4 -> 4
    | B8P5 -> 5
    | B8P6 -> 6
    | B8P7 -> 7
    [@@macro]

  let get_format_parameters (fmt : t) : int * int * real =
    let open Util in
    if fmt = B8P1 then 1, 63, 9223372036854775808.0
    else (
      let precision : int = precision fmt in
      let emax : int = ipow2 (8 - precision - 1) - 1 in
      let bias : int = emax + 1 in
      let max : real = pow2 emax *. (2. -. pow2 (2 - precision)) in
      precision, bias, max)
end

(** Rounding mode definitions *)

module RoundingMode = struct
  type t =
    | TowardZero
    | TowardNegative
    | TowardPositive
    | NearestTiesToEven
    | NearestTiesToAway
end

module SaturationMode = struct
  type t =
    | OvfSat
    | Other
end

(** Floating-point numeral definitions *)

module Float8 = struct
  (* Type definition *)
  type t = { b7: bool; b6: bool; b5: bool; b4: bool; b3: bool; b2: bool; b1: bool; b0: bool; } [@@ocamlformat "disable"]

  (* Constants *)

  let nan : t =
    { b7 = true; b6 = false; b5 = false; b4 = false; b3 = false; b2 = false; b1 = false; b0 = false; } [@@ocamlformat "disable"]

  let ninf : t =
    { b7 = true; b6 = true; b5 = true; b4 = true; b3 = true; b2 = true; b1 = true; b0 = true; } [@@ocamlformat "disable"]

  let pinf : t =
    { b7 = false; b6 = true; b5 = true; b4 = true; b3 = true; b2 = true; b1 = true; b0 = true; } [@@ocamlformat "disable"]

  let zero : t =
    { b7 = false; b6 = false; b5 = false; b4 = false; b3 = false; b2 = false; b1 = false; b0 = false; } [@@ocamlformat "disable"]

  (** Classification predicates *)

  let is_zero (x : t) : bool = x = zero [@@macro]

  let is_nan (x : t) : bool = x = nan [@@macro]

  let is_ninf (x : t) : bool = x = ninf [@@macro]

  let is_pinf (x : t) : bool = x = pinf [@@macro]

  let is_inf (x : t) : bool = x = ninf || x = pinf [@@macro]

  let is_finite (x : t) : bool = x <> nan && x <> ninf && x <> pinf [@@macro]

  let is_normal (x : t) (fmt : Format.t) : bool =
    let open Format in
    is_finite x
    &&
    match fmt with
    | B8P1 -> x.b6 || x.b5 || x.b4 || x.b3 || x.b2 || x.b1 || x.b0
    | B8P2 -> x.b6 || x.b5 || x.b4 || x.b3 || x.b2 || x.b1
    | B8P3 -> x.b6 || x.b5 || x.b4 || x.b3 || x.b2
    | B8P4 -> x.b6 || x.b5 || x.b4 || x.b3
    | B8P5 -> x.b6 || x.b5 || x.b4
    | B8P6 -> x.b6 || x.b5
    | B8P7 -> x.b6

  let is_subnormal (x : t) (fmt : Format.t) : bool =
    let open Format in
    is_finite x
    &&
    match fmt with
    | B8P1 ->
      (not x.b6) && (not x.b5) && (not x.b4) && (not x.b3) && (not x.b2)
      && (not x.b1) && not x.b0
    | B8P2 ->
      (not x.b6) && (not x.b5) && (not x.b4) && (not x.b3) && (not x.b2)
      && not x.b1
    | B8P3 -> (not x.b6) && (not x.b5) && (not x.b4) && (not x.b3) && not x.b2
    | B8P4 -> (not x.b6) && (not x.b5) && (not x.b4) && not x.b3
    | B8P5 -> (not x.b6) && (not x.b5) && not x.b4
    | B8P6 -> (not x.b6) && not x.b5
    | B8P7 -> not x.b6

  let is_sign_minus (x : t) : bool = x.b7 [@@macro]

  let is_canonical (_x : t) : bool = true [@@macro]

  let is_signaling (_x : t) : bool = false [@@macro]

  (** Classifier *)

  type class_ =
    | NaN
    | NegativeInfinity
    | NegativeNormal
    | NegativeSubnormal
    | Zero
    | PositiveSubnormal
    | PositiveNormal
    | PositiveInfinity

  let class_internal (x : t) (fmt : Format.t) : (class_, string) Result.t =
    if is_nan x then Ok NaN
    else if is_inf x && is_sign_minus x then Ok NegativeInfinity
    else if is_normal x fmt && is_sign_minus x then Ok NegativeNormal
    else if is_subnormal x fmt && is_sign_minus x then Ok NegativeSubnormal
    else if is_zero x then Ok Zero
    else if is_subnormal x fmt && not (is_sign_minus x) then Ok PositiveSubnormal
    else if is_normal x fmt && not (is_sign_minus x) then Ok PositiveNormal
    else if is_inf x && not (is_sign_minus x) then Ok PositiveInfinity
    else Error "unclassified"

  let class_ (x : t) (fmt : Format.t) : class_ =
    match class_internal x fmt with
    | Ok c -> c
    | Error _ -> NaN (* Unchreable by thm_class_internal_ok *)

  (** Convert int [i] to a [t] (bitwise; lowest 8 bits only, rest ignored) *)
  let of_int_bitwise (i : int) : t =
    {
      b0 = i mod 2 <> 0;
      b1 = i / 2 mod 2 <> 0;
      b2 = i / 4 mod 2 <> 0;
      b3 = i / 8 mod 2 <> 0;
      b4 = i / 16 mod 2 <> 0;
      b5 = i / 32 mod 2 <> 0;
      b6 = i / 64 mod 2 <> 0;
      b7 = i / 128 mod 2 <> 0;
    }

  (** Bitwise and of two float8s *)
  let bitwise_and (x : t) (y : t) : t =
    {
      b7 = x.b7 && y.b7;
      b6 = x.b6 && y.b6;
      b5 = x.b5 && y.b5;
      b4 = x.b4 && y.b4;
      b3 = x.b3 && y.b3;
      b2 = x.b2 && y.b2;
      b1 = x.b1 && y.b1;
      b0 = x.b0 && y.b0;
    }

  (** Bitwise or of two float8s *)
  let bitwise_or (x : t) (y : t) : t =
    {
      b7 = x.b7 || y.b7;
      b6 = x.b6 || y.b6;
      b5 = x.b5 || y.b5;
      b4 = x.b4 || y.b4;
      b3 = x.b3 || y.b3;
      b2 = x.b2 || y.b2;
      b1 = x.b1 || y.b1;
      b0 = x.b0 || y.b0;
    }

  (** Bitwise or of three float8s *)
  let bitwise_or3 (x : t) (y : t) (z : t) : t = bitwise_or (bitwise_or x y) z
  [@@macro]

  (** Shift float8 to the right *)
  let rec bit_shift_right (x : t) (i : int) : t =
    if i <= 0 then x
    else (
      let shift1 (x : t) =
        {
          b7 = false;
          b6 = x.b7;
          b5 = x.b6;
          b4 = x.b5;
          b3 = x.b4;
          b2 = x.b3;
          b1 = x.b2;
          b0 = x.b1;
        }
      in
      shift1 (bit_shift_right x (i - 1)))
    [@@unroll 6]

  (** Shift float8 to the left *)
  let rec bit_shift_left (x : t) (i : int) : t =
    if i <= 0 then x
    else (
      let shift1 (x : t) =
        {
          b7 = x.b6;
          b6 = x.b5;
          b5 = x.b4;
          b4 = x.b3;
          b3 = x.b2;
          b2 = x.b1;
          b1 = x.b0;
          b0 = false;
        }
      in
      shift1 (bit_shift_left x (i - 1)))

  (** Convert float8 to int (bitwise) *)

  let to_int_bitwise (x : t) : int =
      (if x.b0 then 1 else 0)
    + (if x.b1 then 2 else 0)
    + (if x.b2 then 4 else 0)
    + (if x.b3 then 8 else 0)
    + (if x.b4 then 16 else 0)
    + (if x.b5 then 32 else 0)
    + (if x.b6 then 64 else 0)
    + (if x.b7 then 128 else 0)
  [@@ocamlformat "disable"]

  let sign (x : real) : real = Real.(if x < 0.0 then -1.0 else 1.0)
  [@@ocamlformat "if-then-else=compact"]

  (** Convert [x] (in [fmt]) to extended real *)
  let to_extended_real (x : t) (fmt : Format.t) : ExReal.t =
    let open Util in
    (* Convert X (in Format) to extended real *)
    (* Cannot return a NaN, so must not be referenced with a NaN code *)
    if is_pinf x then PINF
    else if is_ninf x then NINF
    else (
      let precision, bias, _ = Format.get_format_parameters fmt in
      let sign =
        if not (is_zero (bitwise_and x (of_int_bitwise 0x80))) then -1.0
        else 1.0
      in
      let trailing_bits =
        to_int_bitwise
          (bitwise_and x (of_int_bitwise (ipow2 (precision - 1) - 1)))
      in
      let biased_exponent =
        to_int_bitwise
          (bit_shift_right
             (bitwise_and x (of_int_bitwise 0x7F))
             (precision - 1))
      in

      if biased_exponent = 0 then
        R
          (sign
          *. (0.0 +. (Real.of_int trailing_bits *. pow2 (1 - precision)))
          *. pow2 (1 - bias))
      else
        R
          (sign
          *. (1.0 +. (Real.of_int trailing_bits *. pow2 (1 - precision)))
          *. pow2 (biased_exponent - bias))
    )

  module NaNOrExReal = struct
    type t =
      | NaN
      | XR of ExReal.t
  end

  let real_is_within_range (x : real) (fmt : Format.t) : bool =
    let _, _, fmax = Format.get_format_parameters fmt in
    (-. fmax) <=. x && x <=. fmax

  let exreal_is_within_range (x : ExReal.t) (fmt : Format.t) : bool =
    match x with
    | ExReal.PINF | ExReal.NINF -> true
    | ExReal.R r -> real_is_within_range r fmt

  let encode (x : NaNOrExReal.t) (fmt : Format.t) : (t, string) Result.t =
    let open Util in
    let precision, bias, _ = Format.get_format_parameters fmt in
      match x with
      | NaNOrExReal.NaN -> Ok (of_int_bitwise 0x80)
      | NaNOrExReal.XR x ->
        (match x with
        | ExReal.PINF -> Ok (of_int_bitwise 0x7f)
        | ExReal.NINF -> Ok (of_int_bitwise 0xff)
        | ExReal.R 0.0 -> Ok (of_int_bitwise 0x00)
        | ExReal.R x when not (real_is_within_range x fmt) ->
          Error "precondition violation"
        | ExReal.R x ->
          Ok (
            let sign_bit : t = of_int_bitwise (if x <. 0.0 then 0x80 else 0x00) in
            let exponent : int = max (floor_log2_abs x 64) (1 - bias) in
            let rsignificand : real =
              Real.abs x *. pow2 (-exponent) *. pow2 (precision - 1)
            in
            (* [rsignificand] is an integer, because [x] is a valid value in the format *)
            let isignificand : int = Real.to_int rsignificand in
            let fsignificand : t = of_int_bitwise isignificand in
            let trailing_bits : t =
              bitwise_and fsignificand
                (of_int_bitwise (ipow2 (precision - 1) - 1))
            in

            if isignificand < ipow2 (precision - 1) then
              (* subnormal *)
              bitwise_or sign_bit fsignificand
            else (
              (* normal *)
              let biased_exponent = of_int_bitwise (exponent + bias) in
              bitwise_or3 sign_bit
                (bit_shift_left biased_exponent (precision - 1))
                trailing_bits)))

  (** Round to ([precision], [bias]) in reals *)
  let round_to_precision (z : ExReal.t) (precision : int) (bias : int)
      (rnd : RoundingMode.t) : ExReal.t =
    (* "round_to_precision" is never called with a NaN *)
    let open Util in
    let open RoundingMode in
    match z with
    | ExReal.NINF | ExReal.PINF -> z
    | ExReal.R 0.0 -> z
    | ExReal.R z ->
      let e : int = max (ilog2 (Real.to_int z)) (1 - bias) - precision + 1 in
      let m = Real.abs z *. pow2 (-e) in
      (* Round [m] to integer [i] according to [rnd].
         Note [m] is absolute value so floor is toward 0. *)
      let i : int = floor m in
      let delta : real = Real.(m - Real.of_int i) in

      let i =
        if
          rnd = NearestTiesToEven
          && Real.(
               (delta > 0.5 || (delta = 0.5 && is_odd i))
               || (rnd = NearestTiesToAway && delta >= 0.5)
               || (rnd = TowardPositive && z > 0.0 && delta > 0.0)
               || (rnd = TowardNegative && z < 0.0 && delta > 0.0))
        then i + 1 (* Away from zero, as [m] is absolute value *)
        else i
      in
      (* Reconstruct from rounded [i] *)
      R Real.(sign z * Real.of_int i * pow2 e)

  (** Saturate according to [ovf] and [rnd]. *)
  let saturate (z : ExReal.t) (max : ExReal.t)  (ovf : SaturationMode.t) (rnd : RoundingMode.t) : (ExReal.t, string) Result.t =
    let open ExReal in
    let open ExReal.Infix in
    if ExReal.abs z > max then
      if
        ovf = SaturationMode.OvfSat
        || ExReal.is_finite z
          && (rnd = RoundingMode.TowardZero
              || (rnd = RoundingMode.TowardPositive && z < R 0.0)
              || (rnd = RoundingMode.TowardNegative && z > R 0.0))
      then ExReal.sign z * max
      else ExReal.sign z * PINF
    else Ok z

  let to_binary_8 (z : NaNOrExReal.t) (result_format : Format.t)
      (ovf : SaturationMode.t) (rnd : RoundingMode.t) : (t, string) Result.t =
    let open ExReal in
    match z with
    | NaNOrExReal.NaN -> Error "precondition violation"
    | NaNOrExReal.XR z ->
      let precision, bias, max = Format.get_format_parameters result_format in

      let z = round_to_precision z precision bias rnd in
      let z = saturate z (R max) ovf rnd in

      (match z with
      | Error s -> Error s
      | Ok z ->
        (if exreal_is_within_range z result_format then
          encode (NaNOrExReal.XR z) result_format
        else
          Error "out of range"))

  let internal_lt (x : t) (y : t) (x_fmt : Format.t) (y_fmt : Format.t) : (bool, string) Result.t =
    let x = to_extended_real x x_fmt in
    let y = to_extended_real y y_fmt in
    Ok ExReal.Infix.(x < y)

  let lt (x : t) (y : t) (x_fmt : Format.t) (y_fmt : Format.t) : bool =
    match internal_lt x y x_fmt y_fmt with
    | Ok r -> r
    | Error _ -> false (* unreachable by theorem internal_lt_ok *)

  let internal_negate (x : t) (fmt : Format.t) : (t, string) Result.t =
    let open ExReal.Infix in
    if is_nan x then Ok x
    else (
      let rx = to_extended_real x fmt in
      let rz = ~-rx in
      encode (NaNOrExReal.XR rz) fmt
    )

  (** Return the negation of [x] in [fmt] *)
  let negate (x : t) (fmt : Format.t) : t =
    match internal_negate x fmt with
    | Ok x -> x
    | Error _ -> nan (* unreachable by theorem internal_negate_ok *)

  let internal_add (x : t) (y : t) (x_fmt : Format.t) (y_fmt : Format.t)
      (result_fmt : Format.t) (ovf : SaturationMode.t) (rnd : RoundingMode.t) :
      (t, string) Result.t =
    if is_nan x || is_nan y then encode NaNOrExReal.NaN result_fmt
    else (
      let x = to_extended_real x x_fmt in
      let y = to_extended_real y y_fmt in
      if ExReal.is_inf x && y = ExReal.neg x then
        encode NaNOrExReal.NaN result_fmt
      else (
        let open ExReal.Infix in
        let z = x + y in
        match z with
        | Error s -> Error s
        | Ok z -> to_binary_8 (NaNOrExReal.XR z) result_fmt ovf rnd))

  (** Add [x] (in [x_fmt]) to [y] (in [y_fmt]), and return in [result_fmt]
      under rounding mode [rnd] and saturation mode [ovf] *)
  let add (x : t) (y : t) (x_fmt : Format.t) (y_fmt : Format.t)
      (result_fmt : Format.t) (ovf : SaturationMode.t) (rnd : RoundingMode.t) :
      t =
    match internal_add x y x_fmt y_fmt result_fmt ovf rnd with
    | Ok x -> x
    | Error _ -> nan (* unreachable by theorem internal_add_ok *)

  let internal_add_scaled (x : t) (y : t) (x_fmt : Format.t) (y_fmt : Format.t)
      (xscale : int) (yscale : int) (result_fmt : Format.t)
      (ovf : SaturationMode.t) (rnd : RoundingMode.t) : (t, string) Result.t =
    if is_nan x || is_nan y then encode NaNOrExReal.NaN result_fmt
    else (
      let x = to_extended_real x x_fmt in
      let y = to_extended_real y y_fmt in
      if ExReal.is_inf x && y = ExReal.neg x then
        encode NaNOrExReal.NaN result_fmt
      else (
        let open ExReal.ResultInfix in
        let x, y = Ok x, Ok y in
        let z = x * (2 ^ xscale) + y * (2 ^ yscale) in
        Result.flat_map
          (fun z -> to_binary_8 (NaNOrExReal.XR z) result_fmt ovf rnd)
          z))

  (** For [x] (in [x_fmt]), [y] (in [y_fmt]), [xscale], [yscale],
      compute [x] * 2^[xscale] + [y] * 2^[yscale] and return in [result_fmt],
      with rounding mode [rnd] and saturation mode [ovf] *)
  let add_scaled (x : t) (y : t) (x_fmt : Format.t) (y_fmt : Format.t)
      (xscale : int) (yscale : int) (result_fmt : Format.t)
      (ovf : SaturationMode.t) (rnd : RoundingMode.t) : t =
    match
      internal_add_scaled x y x_fmt y_fmt xscale yscale result_fmt ovf rnd
    with
    | Ok x -> x
    | Error _ -> nan (* unreachable by theorem internal_add_scaled_ok *)

  let internal_subtract (x : t) (y : t) (x_fmt : Format.t) (y_fmt : Format.t)
      (result_fmt : Format.t) (ovf : SaturationMode.t) (rnd : RoundingMode.t) :
      (t, string) Result.t =
    if is_nan x || is_nan y then encode NaNOrExReal.NaN result_fmt
    else (
      let x = to_extended_real x x_fmt in
      let y = to_extended_real y y_fmt in
      if ExReal.is_inf x && y = x then encode NaNOrExReal.NaN result_fmt
      else (
        let z = ExReal.sub x y in
        match z with
        | Error s -> Error s
        | Ok z -> to_binary_8 (NaNOrExReal.XR z) result_fmt ovf rnd))

  (** For [x] (in [x_fmt]), [y] (in [y_fmt]) compute [x-y] and return in [result_fmt],
      with rounding mode [rnd] and saturation mode [ovf] *)
  let subtract (x : t) (y : t) (x_fmt : Format.t) (y_fmt : Format.t)
      (result_fmt : Format.t) (ovf : SaturationMode.t) (rnd : RoundingMode.t) :
      t =
    match internal_subtract x y x_fmt y_fmt result_fmt ovf rnd with
    | Ok x -> x
    | Error _ -> nan (* unreachable by theorem internal_subtract_ok *)

  let internal_multiply (x : t) (y : t) (x_fmt : Format.t) (y_fmt : Format.t)
      (result_fmt : Format.t) (ovf : SaturationMode.t) (rnd : RoundingMode.t) :
      (t, string) Result.t =
    if is_nan x || is_nan y then encode NaNOrExReal.NaN result_fmt
    else (
      let x = to_extended_real x x_fmt in
      let y = to_extended_real y y_fmt in
      if ExReal.is_inf x && y = ExReal.neg x then
        encode NaNOrExReal.NaN result_fmt
      else if
        (ExReal.is_inf x && y = ExReal.zero)
        || (ExReal.is_inf y && x = ExReal.zero)
      then encode NaNOrExReal.NaN result_fmt
      else (
        let open ExReal.Infix in
        let z = x * y in
        match z with
        | Error s -> Error s
        | Ok z -> to_binary_8 (NaNOrExReal.XR z) result_fmt ovf rnd))

  (** For [x] (in [x_fmt]), [y] (in [y_fmt]) compute x * y and return in [result_fmt],
      with rounding mode [rnd] and saturation mode [ovf] *)
  let multiply (x : t) (y : t) (x_fmt : Format.t) (y_fmt : Format.t)
      (result_fmt : Format.t) (ovf : SaturationMode.t) (rnd : RoundingMode.t) :
      t =
    match internal_multiply x y x_fmt y_fmt result_fmt ovf rnd with
    | Ok x -> x
    | Error _ -> nan (* unreachable by theorem internal_multiply_ok *)

  let internal_multiply_scaled (x : t) (y : t) (x_fmt : Format.t)
      (y_fmt : Format.t) (scale : int) (result_fmt : Format.t)
      (ovf : SaturationMode.t) (rnd : RoundingMode.t) : (t, string) Result.t =
    if is_nan x || is_nan y then encode NaNOrExReal.NaN result_fmt
    else (
      let x = to_extended_real x x_fmt in
      let y = to_extended_real y y_fmt in
      if
        (ExReal.is_inf x && y = ExReal.zero)
        || (ExReal.is_inf y && x = ExReal.zero)
      then encode NaNOrExReal.NaN result_fmt
      else (
        let open ExReal.ResultInfix in
        let x, y = Ok x, Ok y in
        let z = x * y * (2 ^ scale) in
        match z with
        | Error s -> Error s
        | Ok z -> to_binary_8 (NaNOrExReal.XR z) result_fmt ovf rnd)
    )

  (** For [x] (in [x_fmt]), [y] (in [y_fmt]), [scale], compute
      [x] * [y] * 2^[scale] and return in [result_fmt],
      with rounding mode [rnd] and saturation mode [ovf] *)
  let multiply_scaled (x : t) (y : t) (x_fmt : Format.t) (y_fmt : Format.t)
      (scale : int) (result_fmt : Format.t) (ovf : SaturationMode.t)
      (rnd : RoundingMode.t) : t =
    match internal_multiply_scaled x y x_fmt y_fmt scale result_fmt ovf rnd with
    | Ok x -> x
    | Error _ -> nan (* unreachable by theorem internal_multiply_scaled_ok *)

  let internal_divide (x : t) (y : t) (x_fmt : Format.t) (y_fmt : Format.t)
      (result_fmt : Format.t) (ovf : SaturationMode.t) (rnd : RoundingMode.t) :
      (t, string) Result.t =
    if is_nan x || is_nan y then encode NaNOrExReal.NaN result_fmt
    else (
      let x = to_extended_real x x_fmt in
      let y = to_extended_real y y_fmt in
      if ExReal.is_inf x &&
        (ExReal.is_inf y || y = ExReal.zero)
      then
        encode NaNOrExReal.NaN result_fmt
      else (
        let open ExReal.Infix in
        let z = x / y in
        match z with
        | Error s -> Error s
        | Ok z -> to_binary_8 (NaNOrExReal.XR z) result_fmt ovf rnd))

  (** For [x] (in [x_fmt]), [y] (in [y_fmt]) compute x / y and return in [result_fmt],
      with rounding mode [rnd] and saturation mode [ovf] *)
  let divide (x : t) (y : t) (x_fmt : Format.t) (y_fmt : Format.t)
    (result_fmt : Format.t) (ovf : SaturationMode.t)
    (rnd : RoundingMode.t) : t =
  match internal_divide x y x_fmt y_fmt  result_fmt ovf rnd with
  | Ok x -> x
  | Error _ -> nan (* unreachable by theorem internal_divide_ok *)

  (** Convert [x] (in [x_fmt]) to [result_fmt] with rounding mode [rnd] and saturation mode [ovf] *)
  let convert_binary8_to_binary8 (x : t) (x_fmt : Format.t)
      (result_fmt : Format.t) (ovf : SaturationMode.t) (rnd : RoundingMode.t) =
    if is_nan x then encode NaNOrExReal.NaN result_fmt
    else (
      let x = to_extended_real x x_fmt in
      to_binary_8 (NaNOrExReal.XR x) result_fmt ovf rnd)

  (** Convert [x] (in [x_fmt]) to binary16 format with rounding mode [rnd] and saturation mode [ovf] *)
  let convert_binary8_to_binary16_internal (x : t) (x_fmt : Format.t)
      (ovf : SaturationMode.t) (rnd : RoundingMode.t) :
      (Binary16.t, string) Result.t =
    let open ExReal in
    if is_nan x then Ok Binary16.nan
    else (
      let x = to_extended_real x x_fmt in
      let z = round_to_precision x 11 15 rnd in
      match saturate z (R 65504.0) ovf rnd with
      | Ok z -> Ok (Binary16.of_exreal z)
      | Error s -> Error s)

  let convert_binary8_to_binary16 (x : t) (x_fmt : Format.t)
      (ovf : SaturationMode.t) (rnd : RoundingMode.t) : Binary16.t =
    match convert_binary8_to_binary16_internal x x_fmt ovf rnd with
    | Ok r -> r
    | Error _ -> Binary16.nan (* unreachable by thm_convert_binary8_to_binary16_internal_ok *)

  (* Convert [x] (in [x_fmt]) to IEEE−754 binary interchange format Binary{[k]} under IEEE−754 rounding mode [rnd754] *)
  let convert_binary8_to_754 (x : t) (x_fmt : Format.t) (r_fmt : IEEE754.Format.t)
      (rnd754 : IEEE754.RoundingMode.t) : IEEE754.t =
    if is_nan x then (* canonical if defined else quiet *)
      IEEE754.canonical_nan r_fmt
    else (
      let r = to_extended_real x x_fmt in
      IEEE754.round r r_fmt rnd754)

  (** Convert [x] to a string of zeroes and ones *)
  let to_string (x : t) (fmt : Format.t) : string =
    let bool_to_bin x = if x then "1" else "0" in
    let xreal = to_extended_real x fmt in
    Printf.sprintf "%s%s%s%s%s%s%s%s = %s" (bool_to_bin x.b7) (bool_to_bin x.b6)
      (bool_to_bin x.b5) (bool_to_bin x.b4) (bool_to_bin x.b3)
      (bool_to_bin x.b2) (bool_to_bin x.b1) (bool_to_bin x.b0)
      (if is_nan x then "NaN" else ExReal.to_string xreal)
      [@@ocamlformat "if-then-else=compact"] [@@program]
end
