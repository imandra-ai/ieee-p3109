[@@@import Util, "dune:math"]
[@@@import CER, "dune:math"]
[@@@import Sqrt, "dune:math"]
[@@@import Exp, "dune:math"]
[@@@import Log, "dune:math"]
[@@@import ErrorPropagation, "ErrorPropagation.iml"]
[@@@import IEEE754, "IEEE754.iml"]

(** Format definitions *)

module Signedness = struct
  type t = Signed | Unsigned
end

module Domain = struct
  type t = Extended | Finite
end

module Format = struct
  type kpt =
    | B2P1 | B2P2
    | B3P1 | B3P2 | B3P3
    | B4P1 | B4P2 | B4P3 | B4P4
    | B5P1 | B5P2 | B5P3 | B5P4 | B5P5
    | B6P1 | B6P2 | B6P3 | B6P4 | B6P5| B6P6
    | B7P1 | B7P2 | B7P3 | B7P4 | B7P5 | B7P6 | B7P7
    | B8P1 | B8P2 | B8P3 | B8P4 | B8P5 | B8P6 | B8P7 | B8P8
    | B9P1 | B9P2 | B9P3 | B9P4 | B9P5 | B9P6 | B9P7 | B9P8 | B9P9
    | B10P1 | B10P2 | B10P3 | B10P4 | B10P5 | B10P6 | B10P7 | B10P8 | B10P9 | B10P10
    | B11P1 | B11P2 | B11P3 | B11P4 | B11P5 | B11P6 | B11P7 | B11P8 | B11P9 | B11P10 | B11P11
    | B12P1 | B12P2 | B12P3 | B12P4 | B12P5 | B12P6 | B12P7 | B12P8 | B12P9 | B12P10 | B12P11 | B12P12
    | B13P1 | B13P2 | B13P3 | B13P4 | B13P5 | B13P6 | B13P7 | B13P8 | B13P9 | B13P10 | B13P11 | B13P12 | B13P13
    | B14P1 | B14P2 | B14P3 | B14P4 | B14P5 | B14P6 | B14P7 | B14P8 | B14P9 | B14P10 | B14P11 | B14P12 | B14P13 | B14P14
    | B15P1 | B15P2 | B15P3 | B15P4 | B15P5 | B15P6 | B15P7 | B15P8 | B15P9 | B15P10 | B15P11 | B15P12 | B15P13 | B15P14 | B15P15

  type t = {
    kp: kpt;
    s: Signedness.t;
    d: Domain.t;
  }

  let precision (f : t) : int =
    match f.kp with
    | B15P1  | B14P1  | B13P1  | B12P1  | B11P1  | B10P1 | B9P1 | B8P1 | B7P1 | B6P1 | B5P1 | B4P1 | B3P1 | B2P1 -> 1
    | B15P2  | B14P2  | B13P2  | B12P2  | B11P2  | B10P2 | B9P2 | B8P2 | B7P2 | B6P2 | B5P2 | B4P2 | B3P2 | B2P2 -> 2
    | B15P3  | B14P3  | B13P3  | B12P3  | B11P3  | B10P3 | B9P3 | B8P3 | B7P3 | B6P3 | B5P3 | B4P3 | B3P3 -> 3
    | B15P4  | B14P4  | B13P4  | B12P4  | B11P4  | B10P4 | B9P4 | B8P4 | B7P4 | B6P4 | B5P4 | B4P4 -> 4
    | B15P5  | B14P5  | B13P5  | B12P5  | B11P5  | B10P5 | B9P5 | B8P5 | B7P5 | B6P5 | B5P5-> 5
    | B15P6  | B14P6  | B13P6  | B12P6  | B11P6  | B10P6 | B9P6 | B8P6 | B7P6 | B6P6 -> 6
    | B15P7  | B14P7  | B13P7  | B12P7  | B11P7  | B10P7 | B9P7 | B8P7 | B7P7-> 7
    | B15P8  | B14P8  | B13P8  | B12P8  | B11P8  | B10P8 | B9P8 | B8P8 -> 8
    | B15P9  | B14P9  | B13P9  | B12P9  | B11P9  | B10P9 | B9P9 -> 9
    | B15P10 | B14P10 | B13P10 | B12P10 | B11P10 | B10P10 -> 10
    | B15P11 | B14P11 | B13P11 | B12P11 | B11P11-> 11
    | B15P12 | B14P12 | B13P12 | B12P12 -> 12
    | B15P13 | B14P13 | B13P13 -> 13
    | B15P14 | B14P14 -> 14
    | B15P15 -> 15
    [@@macro]

  let k_of_kp (kp : kpt) =
    match kp with
    | B2P1 | B2P2 -> 2
    | B3P1 | B3P2 | B3P3 -> 3
    | B4P1 | B4P2 | B4P3 | B4P4 -> 4
    | B5P1 | B5P2 | B5P3 | B5P4 | B5P5 -> 5
    | B6P1 | B6P2 | B6P3 | B6P4 | B6P5 | B6P6 -> 6
    | B7P1 | B7P2 | B7P3 | B7P4 | B7P5 | B7P6 | B7P7 -> 7
    | B8P1 | B8P2 | B8P3 | B8P4 | B8P5 | B8P6 | B8P7 | B8P8 -> 8
    | B9P1 | B9P2 | B9P3 | B9P4 | B9P5 | B9P6 | B9P7 | B9P8 | B9P9 -> 9
    | B10P1 | B10P2 | B10P3 | B10P4 | B10P5 | B10P6 | B10P7 | B10P8 | B10P9 | B10P10 -> 10
    | B11P1 | B11P2 | B11P3 | B11P4 | B11P5 | B11P6 | B11P7 | B11P8 | B11P9 | B11P10 | B11P11  -> 11
    | B12P1 | B12P2 | B12P3 | B12P4 | B12P5 | B12P6 | B12P7 | B12P8 | B12P9 | B12P10 | B12P11 | B12P12 -> 12
    | B13P1 | B13P2 | B13P3 | B13P4 | B13P5 | B13P6 | B13P7 | B13P8 | B13P9 | B13P10 | B13P11 | B13P12 | B13P13 -> 13
    | B14P1 | B14P2 | B14P3 | B14P4 | B14P5 | B14P6 | B14P7 | B14P8 | B14P9 | B14P10 | B14P11 | B14P12 | B14P13 | B14P14-> 14
    | B15P1 | B15P2 | B15P3 | B15P4 | B15P5 | B15P6 | B15P7 | B15P8 | B15P9 | B15P10 | B15P11 | B15P12 | B15P13 | B15P14 | B15P15 -> 15
  [@@macro]

  let width (f : t) : int = k_of_kp f.kp [@@macro]

  let k (f : t) : int = width f [@@macro]

  let p (f : t) : int = precision f [@@macro]

  let of_kp (k : int) (p : int) : (kpt, string) Result.t =
    match k with
    | 2 -> (match p with 1 -> Ok B2P1 | 2 -> Ok B2P2 | _ -> Error "invalid precision")
    | 3 -> (match p with 1 -> Ok B3P1 | 2 -> Ok B3P2 | 3 -> Ok B3P3 | _ -> Error "invalid precision")
    | 4 -> (match p with 1 -> Ok B4P1 | 2 -> Ok B4P2 | 3 -> Ok B4P3 | 4 -> Ok B4P4 | _ -> Error "invalid precision")
    | 5 -> (match p with 1 -> Ok B5P1 | 2 -> Ok B5P2 | 3 -> Ok B5P3 | 4 -> Ok B5P4 | 5 -> Ok B5P5 | _ -> Error "invalid precision")
    | 6 -> (match p with 1 -> Ok B6P1 | 2 -> Ok B6P2 | 3 -> Ok B6P3 | 4 -> Ok B6P4 | 5 -> Ok B6P5 | 6 -> Ok B6P6 | _ -> Error "invalid precision")
    | 7 -> (match p with 1 -> Ok B7P1 | 2 -> Ok B7P2 | 3 -> Ok B7P3 | 4 -> Ok B7P4 | 5 -> Ok B7P5 | 6 -> Ok B7P6 | 7 -> Ok B7P7 | _ -> Error "invalid precision")
    | 8 -> (match p with 1 -> Ok B8P1 | 2 -> Ok B8P2 | 3 -> Ok B8P3 | 4 -> Ok B8P4 | 5 -> Ok B8P5 | 6 -> Ok B8P6 | 7 -> Ok B8P7 | 8 -> Ok B8P8 | _ -> Error "invalid precision")
    | 9 -> (match p with 1 -> Ok B9P1 | 2 -> Ok B9P2 | 3 -> Ok B9P3 | 4 -> Ok B9P4 | 5 -> Ok B9P5 | 6 -> Ok B9P6 | 7 -> Ok B9P7 | 8 -> Ok B9P8 | 9 -> Ok B9P9 | _ -> Error "invalid precision")
    | 10 -> (match p with 1 -> Ok B10P1 | 2 -> Ok B10P2 | 3 -> Ok B10P3 | 4 -> Ok B10P4 | 5 -> Ok B10P5 | 6 -> Ok B10P6 | 7 -> Ok B10P7 | 8 -> Ok B10P8 | 9 -> Ok B10P9 | 10 -> Ok B10P10 | _ -> Error "invalid precision")
    | 11 -> (match p with 1 -> Ok B11P1 | 2 -> Ok B11P2 | 3 -> Ok B11P3 | 4 -> Ok B11P4 | 5 -> Ok B11P5 | 6 -> Ok B11P6 | 7 -> Ok B11P7 | 8 -> Ok B11P8 | 9 -> Ok B11P9 | 10 -> Ok B11P10 | 11 -> Ok B11P11 | _ -> Error "invalid precision")
    | 12 -> (match p with 1 -> Ok B12P1 | 2 -> Ok B12P2 | 3 -> Ok B12P3 | 4 -> Ok B12P4 | 5 -> Ok B12P5 | 6 -> Ok B12P6 | 7 -> Ok B12P7 | 8 -> Ok B12P8 | 9 -> Ok B12P9 | 10 -> Ok B12P10 | 11 -> Ok B12P11 | 12 -> Ok B12P12 | _ -> Error "invalid precision")
    | 13 -> (match p with 1 -> Ok B13P1 | 2 -> Ok B13P2 | 3 -> Ok B13P3 | 4 -> Ok B13P4 | 5 -> Ok B13P5 | 6 -> Ok B13P6 | 7 -> Ok B13P7 | 8 -> Ok B13P8 | 9 -> Ok B13P9 | 10 -> Ok B13P10 | 11 -> Ok B13P11 | 12 -> Ok B13P12 | 13 -> Ok B13P13 | _ -> Error "invalid precision")
    | 14 -> (match p with 1 -> Ok B14P1 | 2 -> Ok B14P2 | 3 -> Ok B14P3 | 4 -> Ok B14P4 | 5 -> Ok B14P5 | 6 -> Ok B14P6 | 7 -> Ok B14P7 | 8 -> Ok B14P8 | 9 -> Ok B14P9 | 10 -> Ok B14P10 | 11 -> Ok B14P11 | 12 -> Ok B14P12 | 13 -> Ok B14P13 | 14 -> Ok B14P14 | _ -> Error "invalid precision")
    | 15 -> (match p with 1 -> Ok B15P1 | 2 -> Ok B15P2 | 3 -> Ok B15P3 | 4 -> Ok B15P4 | 5 -> Ok B15P5 | 6 -> Ok B15P6 | 7 -> Ok B15P7 | 8 -> Ok B15P8 | 9 -> Ok B15P9 | 10 -> Ok B15P10 | 11 -> Ok B15P11 | 12 -> Ok B15P12 | 13 -> Ok B15P13 | 14 -> Ok B15P14 | 15 -> Ok B15P15 | _ -> Error "invalid precision")
    | _ -> Error "invalid width"

  let of_parts (k : int) (p : int) (s : Signedness.t) (d : Domain.t) : (t, string) Result.t =
    match of_kp k p with
    | Ok kp -> Ok { kp; s; d }
    | Error e -> Error e

  let parameters (f : t) : int * int * int * real * real * Signedness.t * Domain.t =
    let open Util in
    let open Signedness in
    let open Domain in
    let k : int = k f in
    let p : int = precision f in
    let bias : int =
      match f.s with
      | Signed -> if k = p then -1 else ipow2 (k - p - 1) (* Error for k = p? *)
      | Unsigned -> ipow2 (k - p) in
    let m_hi : real =
      if p = 1 then
        match f.s, f.d with
        | Signed, Extended ->   pow2 (ipow2 (k - 1) - bias - 2)
        | Signed, Finite ->     pow2 (ipow2 (k - 1) - bias - 1)
        | Unsigned, Extended -> pow2 (ipow2 k       - bias - 3)
        | Unsigned, Finite ->   pow2 (ipow2 k       - bias - 2)
      else
        match f.s, f.d with
        | Signed, Extended ->   pow2 (ipow2 (k - p) - bias - 1) *. (2. -. pow2 (2 - p))
        | Signed, Finite ->     pow2 (ipow2 (k - p) - bias - 1) *. (2. -. pow2 (2 - p - 1))
        | Unsigned, Extended -> (
          match p with
          | 2 ->                pow2 (ipow2 (k - p + 1) - bias - 2) *. (2. -. pow2 (2 - p - 1))
          | _ ->                pow2 (ipow2 (k - p + 1) - bias - 1) *. (2. -. pow2 (2 - p) -. pow2 (2 - p - 1))
        )
        | Unsigned, Finite ->   pow2 (ipow2 (k - p + 1) - bias - 1) *. (2. -. pow2 (2 - p))
      in
    let m_lo = if f.s = Signed then -. m_hi else 0.0 in
    k, p, bias, m_lo, m_hi, f.s, f.d

  (** String representation *)
  let to_string (f : t) : string =
    "binary" ^ (Int.to_string (k f)) ^ "p" ^
    (Int.to_string (p f)) ^
    (if f.s == Signed then "s" else "u") ^
    (if f.d = Extended then "e" else "f")
    [@@program]
end

module SaturationMode = struct
  type t =
    | SatFinite
    | SatPropagate
    | OvfInf

  (** String representation *)
  let to_string (x : t) : string =
    match x with
    | SatFinite -> "SatFinite"
    | SatPropagate -> "SatPropagate"
    | OvfInf -> "OvfInf"
    [@@program]
end

(** Rounding mode definitions *)

module RoundingMode = struct
  type t =
    | TowardZero
    | TowardNegative
    | TowardPositive
    | NearestTiesToEven
    | NearestTiesToAway
    | ToOdd
    | Stochastic of int
    | StochasticBiased1 of int
    | StochasticBiased2 of int

    (** String representation *)
  let to_string (x : t) : string =
    match x with
    | TowardZero -> "TowardZero"
    | TowardNegative -> "TowardNegative"
    | TowardPositive -> "TowardPositive"
    | NearestTiesToEven -> "NearestTiesToEven"
    | NearestTiesToAway -> "NearestTiesToAway"
    | ToOdd -> "ToOdd"
    | Stochastic r -> "Stochastic (" ^ Int.to_string r ^ ")"
    | StochasticBiased1 r -> "StochasticBiased1 (" ^ Int.to_string r ^ ")"
    | StochasticBiased2 r -> "StochasticBiased2 (" ^ Int.to_string r ^ ")"
    [@@program]
end

(* Projection specifications *)
module Projection = struct
  type t = SaturationMode.t * RoundingMode.t

  (** String representation *)
  let to_string (x : t) : string =
    SaturationMode.to_string (fst x) ^ ", " ^ RoundingMode.to_string (snd x)
    [@@program]
end

let aug_real_is_within_range (f : Format.t) (x : CER.t) : bool =
  match x with
  | NaN -> true
  | NINF -> f.s = Signedness.Signed && f.d = Domain.Extended
  | PINF -> f.d = Domain.Extended
  | R r ->
    let _, _, _, m_lo, m_hi, _, _ = Format.parameters f in
    m_lo <=. r && r <=. m_hi

(** Floating-point numeral definitions *)

module Float = struct
  (* Type definition *)
  type t = int

  (* Constants *)

  let nan_ks (k : int) (s : Signedness.t): t =
    let open Signedness in
    match s with
    | Signed -> Util.ipow2 (k - 1)
    | Unsigned -> Util.ipow2 k - 1

  let nan (f : Format.t): t =
    let k, _, _, _, _, s, _ = Format.parameters f in
    nan_ks k s

  let ninf (f : Format.t) : (t, string) Result.t =
    let open Signedness in
    let open Domain in
    let k, _, _, _, _, s, d = Format.parameters f in
    match s, d with
    | Unsigned, _
    | _, Finite -> Error "invalid"
    | _ -> Ok (Util.ipow2 k - 1)

  let pinf (f : Format.t) : (t, string) Result.t =
    let open Signedness in
    let open Domain in
    let k, _, _, _, _, s, d = Format.parameters f in
    match s, d with
    | Signed, Extended -> Ok (Util.ipow2 (k - 1) - 1)
    | Unsigned, Extended -> Ok (Util.ipow2 k - 2)
    | _, Finite -> Error "invalid"

  let zero : t = 0 [@@macro]

  (* Internal helpers *)

  let to_int_repr (f : Format.t) (i : t) : int =
    let k, _, _, _, _, _, _ = Format.parameters f in
    if i < 0 || i >= Util.ipow2 k then nan f else i

  let to_int_repr_k (k : int) (i : t) (s : Signedness.t): int =
    if i < 0 || i >= Util.ipow2 k then (nan_ks k s) else i

  let of_int_repr (f : Format.t) (i : int) : t =
    let k, _, _, _, _, _, _ = Format.parameters f in
    if i < 0 || i >= Util.ipow2 k then nan f else i

  let of_int_repr_k (k : int) (s : Signedness.t) (i : int) : t =
    if i < 0 || i >= Util.ipow2 k then (nan_ks k s) else i

  let is_nan f x = to_int_repr f x = nan f
  let is_ninf f x = Ok (to_int_repr f x) = ninf f
  let is_pinf f x = Ok (to_int_repr f x) = pinf f
  let is_inf f x = is_ninf f x || is_pinf f x

  (** 4.6.1 Decode *)
  let rec decode_aux (k : int) (p : int) (b : int) (s: Signedness.t) (d : Domain.t) (x : t) : (CER.t, string) Result.t =
    let open Util in
    let open Signedness in
    let open Domain in
    (* if k > 15 then Error "invalid format" else (* Note: termination checks go off the rails if k is unbounded *) *)
    match to_int_repr_k k x s with
    | x when x = ipow2 (k - 1)     && s = Signed -> Ok NaN
    | x when x = ipow2  k      - 1 && s = Unsigned -> Ok NaN

    | x when x = ipow2 (k - 1) - 1 && d = Extended && s = Signed -> Ok PINF
    | x when x = ipow2  k      - 1 && d = Extended && s = Signed -> Ok NINF
    | x when x = ipow2  k      - 2 && d = Extended && s = Unsigned -> Ok PINF

    | x when ipow2 (k - 1) < x && x < ipow2 k && s = Signed ->

      (match decode_aux k p b s d (of_int_repr_k k s (x - ipow2 (k - 1))) with
      | Ok r -> Ok CER.(~- r)
      | Error e -> Error e)

    | x ->
      let t = Real.of_int (x mod (ipow2 (p - 1))) in
      let e = Int.(Util.machine_idiv x (ipow2 (p - 1))) in

      let r = (
        if e = 0 then
          (0. +. t *. (pow2 (1 - p))) *. (pow2 (1 - b))
        else
          (1. +. t *. (pow2 (1 - p))) *. (pow2 (e - b))) in
      Ok CER.(R r)
    [@@timeout 3600]
    [@@measure Ordinal.of_int x]
    [@@by auto]

  let decode (f : Format.t) (x : t) : CER.t =
    let k, p, b, _, _, s, d = Format.parameters f in
    match decode_aux k p b s d x with
    | Ok r -> r
    | Error _ -> NaN (* unreachable by theorem_decode_ok *)

  (* 4.6.3 RoundToPrecision *)

  let internal_round_to_precision (p : int) (b : int) (rnd : RoundingMode.t) (x : CER.t) : (CER.t, string) Result.t =
    let open Util in
    let open RoundingMode in
    let rsign (x : real) : real = if x <. 0.0 then -1.0 else 1.0 [@@macro] in
    let is_even (x : int) : bool = x mod 2 = 0 [@@macro] in
    match x with
    | CER.NaN -> Ok NaN
    | NINF
    | PINF -> Ok x
    | R 0.0 -> Ok x
    | R x ->
      let e : int = (max (floor_log2_abs x 32768) (1 - b)) - p + 1 in (* TODO: is 32768 always enough? *)
      let s : real = Real.abs x *. pow2 (- e) in
      let delta : real = Real.(s - floor s) in
      let code_is_even : bool =
        if p > 1 then
          is_even (Real.to_int s)
        else
          floor s = 0.0 || is_even (e + b) in
      let rnite x =
          if (x <. (floor x) +. 0.5) || (x = (floor x) +. 0.5 && is_even (ifloor x)) then
            floor x
          else
            (floor x) +. 1.0
      in
      let rnte n x = rnite (x *. pow2 n) *. pow2 (- n) in
      let round_away (rnd : RoundingMode.t) : bool =
        match rnd with
        | NearestTiesToEven -> delta >. 0.5 || (delta = 0.5 && not code_is_even)
        | NearestTiesToAway -> delta >=. 0.5
        | TowardPositive -> delta >. 0.0 && x >. 0.0
        | TowardNegative -> delta >. 0.0 && x <. 0.0
        | TowardZero -> false
        | ToOdd -> delta >. 0.0 && code_is_even
        | Stochastic r -> (
          let delta' = rnte (num_bits r) s -. floor s in
          delta' >=. i2r r *. (2 ^. (- (num_bits r)))
          )
        | StochasticBiased1 r -> delta >. i2r r *. (2 ^. (- (num_bits r)))
        | StochasticBiased2 r -> delta >. (i2r r +. 0.5) *. (2 ^. (- (num_bits r)))
      in
      let i = if round_away rnd then (floor s) +. 1.0
              else floor s in
      let z = CER.R (rsign x *. i *. (2 ^ e)) in
      Ok z

  (** Convert extended real value [x] to a new extended real that is representable
      with a given precision [p]. The exponent is bounded below by [2 - p - b] and
      unbounded above. *)
  let round_to_precision (p : int) (b : int) (rnd : RoundingMode.t) (x : CER.t) : CER.t =
    match internal_round_to_precision p b rnd x with
    | Ok r -> r
    | Error _ -> R 0.0 (* unreachable by internal_round_to_precision_ok *)

  (** 4.6.4 Saturate *)

  let internal_saturate
    (m_lo : real) (m_hi : real) (sat : SaturationMode.t) (rnd : RoundingMode.t)
    (x : CER.t) (sigma : Signedness.t) (delta : Domain.t)
    : (CER.t, string) Result.t =
    let open RoundingMode in
    let open SaturationMode in
    let open Signedness in
    let open Domain in
    match sat, rnd, x, sigma, delta with
    | _, _, NaN, _, _ -> Ok NaN

    | _, _, R x, _, _ when m_lo <=. x && x <=. m_hi -> Ok (R x)

    | SatFinite, _, PINF, _, _ -> Ok (R m_hi)
    | SatFinite, _, NINF, _, _ -> Ok (R m_lo)
    | SatFinite, _, R x, _, _ when x <=. m_lo -> Ok (R m_lo)
    | SatFinite, _, R x, _, _ when x >=. m_hi -> Ok (R m_hi)

    | SatPropagate, _, PINF, _, Extended -> Ok PINF
    | SatPropagate, _, PINF, _, _ -> Ok (R m_hi)
    | SatPropagate, _, NINF, Signed, Extended -> Ok NINF
    | SatPropagate, _, NINF, _, _ -> Ok (R m_lo)
    | SatPropagate, _, R x, _, _ when x <=. m_lo -> Ok (R m_lo)
    | SatPropagate, _, R x, _, _ when x >=. m_hi -> Ok (R m_hi)

    | OvfInf, _, PINF, _, Extended -> Ok PINF
    | OvfInf, _, PINF, _, _ -> Ok (R m_hi)
    | OvfInf, _, NINF, Signed, Extended -> Ok NINF
    | OvfInf, _, NINF, _, _ -> Ok (R m_lo)
    | OvfInf, (TowardZero | TowardPositive), R x, _, _ when x <=. m_lo -> Ok (R m_lo)
    | OvfInf, (TowardZero | TowardNegative), R x, _, _ when x >=. m_hi -> Ok (R m_hi)
    | OvfInf, _, R x, Signed, Extended when x <=. m_lo -> Ok NINF
    | OvfInf, _, R x, _, _ when x <=. m_lo -> Ok (R m_lo)
    | OvfInf, _, R x, _, Extended when x >=. m_hi -> Ok PINF
    | OvfInf, _, R x, _, _ when x >=. m_hi -> Ok (R m_hi)

    | _ -> Error "unreachable"

  (** Saturate extended real [x] to +-INF, or to maximum value [m], according to projection specification [pi]. *)
  let saturate (m_lo : real) (m_hi : real) (sat : SaturationMode.t) (rnd : RoundingMode.t) (x : CER.t) (s : Signedness.t) (d : Domain.t) : CER.t =
    match internal_saturate m_lo m_hi sat rnd x s d with
    | Ok x -> x
    | Error _ -> R 0.0 (* unreachable by theorem internal_saturate_ok *)


  (** 4.6.5 Encode *)

  let rec encode (f : Format.t) (x : CER.t) : (t, string) Result.t =
    let open Util in
    let k, p, b, _, _, _, _ = Format.parameters f in
    if not (aug_real_is_within_range f x)  then
        Error "precondition violation"
    else
      match x with
      | NaN -> Ok (of_int_repr f (
        if f.s = Signedness.Signed then ipow2 (k - 1)
        else ipow2 k - 1
        ))
      | PINF
        (* when f.d = Domain.Extended  *)
        -> Ok (of_int_repr f (
        if f.s = Signedness.Signed then ipow2 (k - 1) - 1
        else ipow2 k - 2)
        )
      | NINF
        (* when Signedness.Signed && f.d = Domain.Extended *)
        ->
        Ok (of_int_repr f (ipow2 k - 1))

      | R x when x <. 0.0 ->

        (match encode f CER.(R (-. x)) with
        | Ok v -> Ok (of_int_repr f ((to_int_repr f v) + (ipow2 (k - 1))))
        | Error e -> Error e)

      | R x when x = 0.0 -> Ok zero

      | R x ->
        let e : int = Int.max (floor_log2_abs x 32768) (1 - b) in
        let s = x *. (2 ^. (- e)) *. (2 ^. (p - 1)) in
        (* [s] is an integer *)
        let s = Real.to_int s in
        let t = s mod (ipow2 (p - 1)) in
        let z =
          if s < ipow2 (p - 1) then
            t
          else
            t + (e + b) * ipow2 (p - 1) in
        Ok (of_int_repr f z)

      | _ -> Error "unreachable"


  (* 4.6.2 Project *)

  (** Project extended real value [x] to P3109 format [f]. *)
  let project (f : Format.t) (pi : Projection.t) (x : CER.t) : (t, string) Result.t =
    let _, p, b, m_lo, m_hi, _, _ = Format.parameters f in
    let sat, rnd = pi in
    let r : CER.t = round_to_precision p b rnd x in
    let s : CER.t = saturate m_lo m_hi sat rnd r f.s f.d in
    encode f s


  (** 4.7.1 Specification of IEEE Std 754 formats *)
  (* See also IEEE754.ml *)

  let encode754 (phi : IEEE754.Format.t) (x : CER.t) : IEEE754.t =
    IEEE754.round x phi IEEE754.RoundingMode.TowardZero


  (** 4.7.2 Conversion from IEEE Std 754 formats to P3109 *)

  let internal_convert_to_p3109 (phi: IEEE754.Format.t) (f : Format.t) (pi : Projection.t) (x : IEEE754.t) : (t, string) Result.t =
    let open CER in
    match IEEE754.as_aug_real phi x with
    | Ok NaN -> Ok (nan f)
    | Ok r -> project f pi r
    | Error e -> Error e

  let convert_to_p3109 (phi: IEEE754.Format.t) (f : Format.t) (pi : Projection.t) (x : IEEE754.t) : t =
    match internal_convert_to_p3109 phi f pi x with
    | Ok r -> r
    | _ -> nan f (* unreachable by theorem internal_convert_to_p3109_ok *)


  (** 4.7.3 Conversion from P3109 to IEEE Std 754 *)

  (* Convert [x] (in [f_x]) to IEEE−754 binary interchange format Binary{[k]} under IEEE−754 rounding mode [rnd754] *)
  let convert_to_ieee_754 (f : Format.t) (pi : Projection.t) (phi : IEEE754.Format.t) (x : t) : IEEE754.t =
    let open CER in
    if is_nan f x then (* canonical if defined else quiet *)
      IEEE754.canonical_nan phi
    else (
      match decode f x with
      | NaN -> IEEE754.quiet_nan phi
      | PINF -> IEEE754.pinf phi
      | NINF -> IEEE754.ninf phi
      | R y ->
        let _, _, _, _, _, p, b, m = IEEE754.Format.parameters phi in
        let r = round_to_precision p b (snd pi) (r2a y) in
        let x = saturate (-. m) m (fst pi) (snd pi) r f.s f.d in
        encode754 phi x)


  (** 4.7.4 Conversion from P3109 to P3109 *)

  (** Convert [x] (in [f_x]) to [f_z] with projection specification [pi] *)
  let convert_p3109_to_p3109 (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) : (t, string) Result.t =
    project f_z pi (decode f_x x)

  (** 4.8.1 Unary sign operations *)

  let aug_abs (x : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x with
    | NaN -> Ok NaN
    | NINF -> Ok PINF
    | PINF -> Ok PINF
    | R x -> Ok (R (Real.abs x))
    | _ -> Error "undefined"

  let internal_abs (f : Format.t) (x : t) : (t, string) Result.t =
    let open Signedness in
    if f.s = Unsigned then
      Error "precondition failure"
    else
      match aug_abs (decode f x) with
      | Ok r -> encode f r
      | Error e -> Error e

  (** Return the absolute value of [x] in [f] *)
  let abs (f : Format.t) (x : t) : t =
    match internal_abs f x  with
    | Ok x -> x
    | Error _ -> nan f (* unreachable by theorem internal_abs_ok *)


  let aug_negate (x : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x with
    | NaN -> Ok NaN
    | NINF -> Ok PINF
    | PINF -> Ok NINF
    | R x -> Ok (R (-. x))
    | _ -> Error "undefined"

  let internal_negate (f : Format.t) (x : t) : (t, string) Result.t =
    let open Signedness in
    if f.s = Unsigned then
      Error "precondition failure"
    else
      match aug_negate (decode f x) with
      | Ok r -> encode f r
      | Error e -> Error e

  (** Return the negation of [x] in [f] *)
  let negate (f : Format.t) (x : t) : t =
    match internal_negate f x with
    | Ok r -> r
    | Error _ -> nan f (* unreachable by theorem internal_negate_ok *)


  (** 4.8.2 Binary sign operations *)

  let aug_copy_sign (x : CER.t) (y : CER.t) : (CER.t, string) Result.t =
    match x, y with
    | NaN, _ -> Ok NaN
    | _, NaN -> Ok NaN
    | (PINF | NINF), PINF -> Ok PINF
    | (PINF | NINF), NINF -> Ok NINF
    | (PINF | NINF), R y when y >=. 0.0 -> Ok PINF
    | (PINF | NINF), R y when y <. 0.0 -> Ok NINF
    | R x,  PINF  -> Ok (R (Real.abs x))
    | R x,  NINF -> Ok (R (-. (Real.abs x)))
    | R x,  R y when y >=. 0.0 -> Ok (R (Real.abs x))
    | R x,  R y when y <. 0.0 -> Ok (R (-. (Real.abs x)))
    | _ -> Error "undefined"

  let internal_copy_sign (f : Format.t) (x : t) (y : t) : (t, string) Result.t =
    match aug_copy_sign (decode f x) (decode f y) with
    | Ok r -> encode f r
    | Error e -> Error e

  let copy_sign (f : Format.t) (x : t) (y : t) : t =
    match internal_copy_sign f x y with
    | Ok x -> x
    | Error _ -> nan f (* unreachable by theorem internal_copy_sign_ok *)


  (** 4.8.3 Binary arithmetic operations *)

  let aug_add (x : CER.t) (y : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y with
    | NaN, _ -> Ok NaN
    | _, NaN -> Ok NaN
    | PINF, NINF -> Ok NaN
    | NINF, PINF -> Ok NaN
    | PINF, _ -> Ok PINF
    | _, PINF -> Ok PINF
    | NINF, _ -> Ok NINF
    |  _, NINF -> Ok NINF
    | R x, R y -> Ok (R (x +. y))
    | _ -> Error "undefined"

  let internal_add (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) (y : t)  : (t, string) Result.t =
    match aug_add (decode f_x x) (decode f_y y) with
    | Ok r -> project f_z pi r
    | Error e -> Error e

  (** Add [x] (in [f_x]) to [y] (in [f_y]), and return in [f_z] under projection specification [pi] *)
  let add (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) (y : t)  : t =
    match internal_add f_x f_y f_z pi x y with
    | Ok z -> z
    | Error _ -> nan f_z (* unreachable by theorem internal_add_ok *)

  let aug_subtract (x : CER.t) (y : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y with
    | NaN, _ -> Ok NaN
    | _, NaN -> Ok NaN
    | PINF, PINF -> Ok NaN
    | NINF, NINF -> Ok NaN
    | _, PINF -> Ok NINF
    | PINF, _ -> Ok PINF
    | _, NINF -> Ok PINF
    | NINF, _ -> Ok NINF
    | R x, R y -> Ok (R (x -. y))
    | _ -> Error "undefined"

  let internal_subtract (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) (y : t) : (t, string) Result.t =
    match aug_subtract (decode f_x x) (decode f_y y) with
    | Ok r -> project f_z pi r
    | Error e -> Error e

  (** For [x] (in [f_x]), [y] (in [f_y]) compute [x-y] and return in [f_z],
      with projection specification [pi] *)
  let subtract (f_x : Format.t) (f_y : Format.t) (x : t) (y : t)
      (f_z : Format.t) (pi : Projection.t) :
      t =
    match internal_subtract f_x f_y f_z pi x y with
    | Ok x -> x
    | Error _ -> nan f_z (* unreachable by theorem internal_subtract_ok *)

  let aug_multiply (x : CER.t) (y : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y with
    | NaN, _ -> Ok NaN
    | _, NaN -> Ok NaN
    | PINF, PINF -> Ok PINF
    | NINF, NINF -> Ok PINF
    | NINF, PINF -> Ok NINF
    | PINF, NINF -> Ok NINF
    | PINF, R y when y >. 0.0 -> Ok PINF
    | PINF, R y when y = 0.0 -> Ok NaN
    | PINF, R y when y <. 0.0 -> Ok NINF
    | R x, PINF when x >. 0.0 -> Ok PINF
    | R x, PINF when x = 0.0 -> Ok NaN
    | R x, PINF when x <. 0.0 -> Ok NINF
    | NINF, R y when y >. 0.0 -> Ok NINF
    | NINF, R y when y = 0.0 -> Ok NaN
    | NINF, R y when y <. 0.0 -> Ok PINF
    | R x, NINF when x >. 0.0 -> Ok NINF
    | R x, NINF when x = 0.0 -> Ok NaN
    | R x, NINF when x <. 0.0 -> Ok PINF
    | R x, R y -> Ok (R (x *. y))
    | _ -> Error "undefined"

  let internal_multiply (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) (y : t) : (t, string) Result.t =
    match aug_multiply (decode f_x x) (decode f_y y) with
    | Ok r -> project f_z pi r
    | Error e -> Error e

  (** For [x] (in [f_x]), [y] (in [f_y]) compute x * y and return in [f_z],
      with rounding mode [rnd] and saturation mode [ovf] *)
  let multiply (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) (y : t) : t =
    match internal_multiply f_x f_y f_z pi x y with
    | Ok x -> x
    | Error _ -> nan f_z (* unreachable by theorem internal_multiply_ok *)

  let aug_divide (x : CER.t) (y : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y with
    | NaN, _ -> Ok NaN
    | _, NaN -> Ok NaN
    | (PINF | NINF), (PINF | NINF) -> Ok NaN
    | _, R y when y = 0.0 -> Ok NaN
    | PINF, R y when y >. 0.0 -> Ok PINF
    | PINF, R y when y <. 0.0 -> Ok NINF
    | NINF, R y when y >. 0.0 -> Ok NINF
    | NINF, R y when y <. 0.0 -> Ok PINF
    | _, (PINF | NINF) -> Ok (R 0.0)
    | R x, R y -> Ok (R (x /. y))
    | _ -> Error "undefined"

  let internal_divide (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) (y : t) : (t, string) Result.t =
    match aug_divide (decode f_x x) (decode f_y y) with
    | Ok r -> project f_z pi r
    | Error e -> Error e

  (** For [x] (in [f_x]), [y] (in [f_y]) compute x / y and return in [f_z],
      with rounding mode [rnd] and saturation mode [ovf] *)
  let divide (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) (y : t) : t =
  match internal_divide f_x f_y  f_z pi x y with
  | Ok x -> x
  | Error _ -> nan f_z (* unreachable by theorem internal_divide_ok *)


  (** 4.8.4 Fused Multiply Add *)

  let aug_fma (x : CER.t) (y : CER.t) (z : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y, z with
    | NaN, _ , _ -> Ok NaN
    | _ , NaN, _ -> Ok NaN
    | _ , _, NaN -> Ok NaN

    | R 0.0, (PINF | NINF), _ -> Ok NaN
    | (PINF | NINF), R 0.0, _ -> Ok NaN

    | R x, PINF, PINF when x <. 0.0 -> Ok NaN
    | R x, NINF, PINF when x >. 0.0 -> Ok NaN
    | PINF, R y, PINF when y <. 0.0 -> Ok NaN
    | NINF, R y, PINF when y >. 0.0 -> Ok NaN

    | R x, NINF, NINF when x <. 0.0 -> Ok NaN
    | R x, PINF, NINF when x >. 0.0 -> Ok NaN
    | NINF, R y, NINF when y <. 0.0 -> Ok NaN
    | PINF, R y, NINF when y >. 0.0 -> Ok NaN

    | NINF, PINF, PINF -> Ok NaN
    | PINF, NINF, PINF -> Ok NaN
    | PINF, PINF, NINF -> Ok NaN
    | NINF, NINF, NINF -> Ok NaN

    | PINF, PINF, _ -> Ok PINF
    | NINF, NINF, _ -> Ok PINF
    | PINF, NINF, _ -> Ok NINF
    | NINF, PINF, _ -> Ok NINF

    | _, _, NINF -> Ok NINF
    | R x, NINF, R z when x >=. 0.0 -> Ok NINF
    | R x, NINF, R z when x <. 0.0 -> Ok PINF

    | _, _, PINF -> Ok PINF
    | R x, PINF, R z when x >=. 0.0 -> Ok PINF
    | R x, PINF, R z when x <. 0.0 -> Ok NINF

    | PINF, R y, R z when y >=. 0.0 -> Ok PINF
    | PINF, R y, R z when y <. 0.0 -> Ok NINF

    | NINF, R y, R z when y >=. 0.0 -> Ok NINF
    | NINF, R y, R z when y <. 0.0 -> Ok PINF

    | R x, R y, R z -> Ok (R (x *. y +. z))

    | _ -> Error "undefined"

  let internal_fma (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (f_r: Format.t) (pi : Projection.t) (x : t) (y : t) (z : t): (t, string) Result.t =
    match aug_fma (decode f_x x) (decode f_y y) (decode f_z z) with
    | Ok r -> project f_r pi r
    | Error e -> Error e

  let fma (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (f_r: Format.t) (pi : Projection.t) (x : t) (y : t) (z : t): t =
    match internal_fma f_x f_y f_z f_r pi x y z with
    | Ok r -> r
    | Error _ -> (nan f_r) (* unreachable by theorem internal_fma_ok *)


  (** 4.8.xx Fused Add Add *)

  let aug_faa (x : CER.t) (y : CER.t) (z : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y, z with
    | NaN, _ , _ -> Ok NaN
    | _ , NaN, _ -> Ok NaN
    | _ , _, NaN -> Ok NaN
    | PINF, NINF, _ -> Ok NaN
    | NINF, PINF, _ -> Ok NaN
    | PINF, _, NINF -> Ok NaN
    | NINF, _, PINF -> Ok NaN
    | _, PINF, NINF -> Ok NaN
    | _, NINF, PINF -> Ok NaN
    | PINF, PINF, PINF -> Ok PINF
    | NINF, NINF, NINF -> Ok NINF
    | _, PINF, PINF -> Ok PINF
    | PINF, _, PINF -> Ok PINF
    | PINF, PINF, _ -> Ok PINF
    | _, NINF, NINF -> Ok NINF
    | NINF, _, NINF -> Ok NINF
    | NINF, NINF, _ -> Ok NINF
    | PINF, _, _ -> Ok PINF
    | _, PINF, _ -> Ok PINF
    | _, _, PINF -> Ok PINF
    | NINF, _, _ -> Ok NINF
    | _, NINF, _ -> Ok NINF
    | _, _, NINF -> Ok NINF
    | R x, R y, R z -> Ok (R (x +. y +. z))
    | _ -> Error "undefined"

  let internal_faa (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (f_r: Format.t) (pi : Projection.t) (x : t) (y : t) (z : t): (t, string) Result.t =
    match aug_faa (decode f_x x) (decode f_y y) (decode f_z z) with
    | Ok r -> project f_r pi r
    | Error e -> Error e

  let faa (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (f_r: Format.t) (pi : Projection.t) (x : t) (y : t) (z : t): t =
    match internal_faa f_x f_y f_z f_r pi x y z with
    | Ok r -> r
    | Error _ -> (nan f_r) (* unreachable by theorem internal_faa_ok *)


  (** 4.8.5 Unary mathematical operations *)

  let aug_recip (x : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x with
    | NaN -> Ok NaN
    | R x when x = 0.0 -> Ok NaN
    | (PINF | NINF) -> Ok (R 0.0)
    | R x -> Ok (R (1.0 /. x))
    | _ -> Error "undefined"

  let internal_recip  (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) : (t, string) Result.t =
    match aug_recip (decode f_x x) with
    | Ok r -> project f_z pi r
    | Error e -> Error e

  let recip (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) : t =
    match internal_recip f_x f_z pi x with
    | Ok x -> x
    | Error _ -> (nan f_z) (* unreachable by theorem internal_recip_ok *)

  let aug_sqrt (x : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x with
    | NaN -> Ok NaN
    | NINF -> Ok NaN
    | R x when x <. 0.0 -> Ok NaN
    | PINF -> Ok PINF
    | R x ->
      (match Sqrt.sqrt x 8 with (* TODO: Proof that 8 is enough *)
      | Ok r -> Ok (R r)
      | Error e -> Error e)
    | _ -> Error "undefined"

  let internal_sqrt (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) : (t, string) Result.t =
    match aug_sqrt (decode f_x x) with
    | Ok r -> project f_z pi r
    | Error e -> Error e

  let sqrt (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) : t =
    match internal_sqrt f_x f_z pi x with
    | Ok x -> x
    | Error _ -> (nan f_z) (* unreachable by theorem internal_sqrt_ok *)

  let aug_rsqrt (x : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x with
    | NaN -> Ok NaN
    | NINF -> Ok NaN
    | R x when x <=. 0.0 -> Ok NaN
    | PINF -> Ok (R 0.0)
    | R x ->
      (match Util.reciprocal (Sqrt.sqrt x 8) with (* TODO: Proof that 8 is enough *)
      | Ok r -> Ok (R r)
      | Error e -> Error e)
    | _ -> Error "undefined"

  let internal_rsqrt (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) : (t, string) Result.t =
    match aug_rsqrt (decode f_x x) with
    | Ok r -> project f_z pi r
    | Error e -> Error e

  let rsqrt (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) : t =
  match internal_rsqrt f_x f_z pi x with
  | Ok x -> x
  | Error _ -> (nan f_z) (* unreachable by theorem internal_rsqrt_ok *)

  let aug_hypot (x : CER.t) (y : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y with
    | NaN, _ -> Ok NaN
    | _, NaN -> Ok NaN
    | _, (PINF | NINF) -> Ok PINF
    | (PINF | NINF), _ -> Ok PINF
    | R x, R y ->
      (match Sqrt.sqrt ((Util.ripow (Real.abs x) 2) +. (Util.ripow (Real.abs y) 2)) 8 with (* TODO: Proof that 8 is enough *)
      | Ok r -> Ok (R r)
      | Error e -> Error e)
    | _ -> Error "undefined"

  let internal_hypot (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) (y : t) : (t, string) Result.t =
    match aug_hypot (decode f_x x) (decode f_y y) with
    | Ok z -> project f_z pi z
    | Error e -> Error e

  let hypot (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) (y : t): t =
    match internal_hypot f_x f_y f_z pi x y with
    | Ok r -> r
    | Error _ -> nan f_z (* unreachable by theorem internal_hypot_ok *)

  let aug_exp (x : CER.t) : (CER.t, string) Result.t =
    match x with
    | NaN -> Ok NaN
    | PINF -> Ok PINF
    | NINF -> Ok (R 0.0)
    | R x -> Ok (R (Exp.exp x 9)) (* TODO: Proof that 9 is enough *)
    | _ -> Error "undefined"

  let internal_exp (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) : (t, string) Result.t =
    match aug_exp (decode f_x x) with
    | Ok z -> project f_z pi z
    | Error e -> Error e

  let exp (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) : t =
    match internal_exp f_x f_z pi x with
    | Ok x -> x
    | Error _ -> (nan f_z) (* unreachable by theorem internal_exp_ok *)

  let aug_exp2 (x : CER.t) : (CER.t, string) Result.t =
    match x with
    | NaN -> Ok NaN
    | PINF -> Ok PINF
    | NINF -> Ok (R 0.0)
    | R x -> (
      match Exp.exp2 x 9 with (* TODO: Proof that 9 is enough *)
      | Ok r -> Ok (R r)
      | Error e -> Error e)
    | _ -> Error "undefined"

  let internal_exp2 (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) : (t, string) Result.t =
    match aug_exp2 (decode f_x x) with
    | Ok z -> project f_z pi z
    | Error e -> Error e

  let exp2 (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) : t =
    match internal_exp2 f_x f_z pi x with
    | Ok x -> x
    | Error _ -> nan f_z (* unreachable by theorem internal_exp2_ok *)

  let aug_log (x : CER.t) : (CER.t, string) Result.t =
    match x with
    | NaN -> Ok NaN
    | NINF -> Ok NaN
    | PINF -> Ok PINF
    | R x when x <. 0.0 -> Ok NaN
    | R x when x = 0.0 -> Ok NINF
    | R x -> (
      match Log.ln x 9 with (* TODO: Proof that 9 is enough *)
      | Ok r -> Ok (R r)
      | Error e -> Error e)
    | _ -> Error "undefined"

  let internal_log (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) : (t, string) Result.t =
    match aug_log (decode f_x x) with
    | Ok z -> project f_z pi z
    | Error e -> Error e

  let log (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) : t =
    match internal_log f_x f_z pi x with
    | Ok x -> x
    | Error _ -> nan f_z (* unreachable by theorem internal_log_ok *)

  let aug_log2 (x : CER.t) : (CER.t, string) Result.t =
    match x with
    | NaN -> Ok NaN
    | NINF -> Ok NaN
    | PINF -> Ok PINF
    | R x when x <. 0.0 -> Ok NaN
    | R x when x = 0.0 -> Ok NINF
    | R x -> (
      match Log.log2 x 9 with (* TODO: Proof that 9 is enough *)
      | Ok r -> Ok (R r)
      | Error e -> Error e)
    | _ -> Error "undefined"

  let internal_log2 (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) : (t, string) Result.t =
    match aug_log2 (decode f_x x) with
    | Ok z -> project f_z pi z
    | Error e -> Error e

  let log2 (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : t) : t =
    match internal_log2 f_x f_z pi x with
    | Ok x -> x
    | Error _ -> nan f_z (* unreachable by theorem internal_log2_ok *)


  (** 4.8.6 Scaled addition *)

  let aug_scaled_add (x : CER.t) (s_x : int) (y : CER.t) (s_y : int) : (CER.t, string) Result.t =
    match x, s_x, y, s_y with
    | NaN, _ , _, _  -> Ok NaN
    | _, _ , NaN, _  -> Ok NaN
    | PINF, _ , NINF, _  -> Ok NaN
    | NINF, _ , PINF, _  -> Ok NaN
    | PINF, _ , _, _  -> Ok PINF
    | NINF, _ , _, _  -> Ok NINF
    | _, _ , PINF, _  -> Ok PINF
    | _, _ , NINF, _  -> Ok NINF
    | R x, s_x , R y, s_y  -> Ok (R (x *. (Util.pow2 s_x) +. y *. (Util.pow2 s_y)))
    | _ -> Error "undefined"

  let internal_scaled_add (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (pi : Projection.t)
      (x : t) (s_x : int) (y : t) (s_y : int)
      : (t, string) Result.t =
    match aug_scaled_add (decode f_x x) s_x (decode f_y y) s_y with
    | Ok z -> project f_z pi z
    | Error e -> Error e

  (** For [x] (in [f_x]), [y] (in [f_y]), [xscale], [yscale],
      compute [x] * 2^[xscale] + [y] * 2^[yscale] and return in [f_z],
      with projection [pi] *)
  let scaled_add (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (pi : Projection.t)
      (x : t) (s_x : int) (y : t) (s_y : int)  : t =
    match internal_scaled_add f_x f_y f_z pi x s_x y s_y with
    | Ok x -> x
    | Error _ -> nan f_z (* unreachable by theorem internal_scaled_add_ok *)


  (** 4.8.7 Scaled multiplication *)

  let aug_scaled_multiply (x : CER.t) (y : CER.t) (s : int) : (CER.t, string) Result.t =
    match x, y, s with
    | NaN, _, _ -> Ok NaN
    | _, NaN, _ -> Ok NaN

    | (PINF | NINF), R y, _ when y = 0.0 -> Ok NaN
    | R x, (PINF | NINF), _ when x = 0.0 -> Ok NaN

    | NINF, NINF, _ -> Ok PINF
    | PINF, PINF, _ -> Ok PINF
    | NINF, PINF, _ -> Ok NINF
    | PINF, NINF, _ -> Ok NINF

    | PINF, R x, _ when x >. 0.0 -> Ok PINF
    | R x, PINF, _ when x >. 0.0 -> Ok PINF
    | PINF, R x, _ when x <. 0.0 -> Ok NINF
    | R x, PINF, _ when x <. 0.0 -> Ok NINF

    | NINF, R x, _ when x >. 0.0 -> Ok NINF
    | R x, NINF, _ when x >. 0.0 -> Ok NINF
    | NINF, R x, _ when x <. 0.0 -> Ok PINF
    | R x, NINF, _ when x <. 0.0 -> Ok PINF

    | R x, R y, s -> Ok (R (x *. y *. (Util.pow2 s)))
    | _ -> Error "undefined"

  let internal_scaled_multiply (f_x : Format.t) (f_y : Format.t) (f_z : Format.t)  (pi : Projection.t)
      (x : t) (y : t) (s : int) : (t, string) Result.t =
    match aug_scaled_multiply (decode f_x x) (decode f_y y) s with
    | Ok z -> project f_z pi z
    | Error e -> Error e


  (** For [x] (in [f_x]), [y] (in [f_y]), [scale], compute
      [x] * [y] * 2^[scale] and return in [f_z],
      with rounding mode [rnd] and saturation mode [ovf] *)
  let scaled_multiply (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (pi : Projection.t)
      (x : t) (y : t) (s : int)  : t =
    match internal_scaled_multiply f_x f_y f_z pi x y s with
    | Ok x -> x
    | Error _ -> nan f_z (* unreachable by theorem internal_scaled_multiply_ok *)


  (** 4.9 Mixed IEEE Std 754 and P3109 operations *)
  let aug_scaled_fma (x : CER.t) (y : CER.t) (s_xy : int) (z : CER.t) (s_z : int) : (CER.t, string) Result.t =
    let open CER in
    match x, y, s_xy, z, s_z with
    | NaN, _, _,  _ , _ -> Ok NaN
    | _, NaN, _,  _ , _ -> Ok NaN
    | _, _, _ , NaN, _ -> Ok NaN

    | PINF, PINF, _ , NINF, _ -> Ok NaN
    | NINF, PINF, _ , PINF, _ -> Ok NaN
    | PINF, NINF, _ , PINF, _ -> Ok NaN
    | NINF, NINF, _ , NINF, _ -> Ok NaN

    | PINF, R 0.0, _, _, _ -> Ok NaN
    | NINF, R 0.0, _, _, _ -> Ok NaN
    | R 0.0, PINF, _, _, _ -> Ok NaN
    | R 0.0, NINF, _, _, _ -> Ok NaN

    | PINF, R y, _, NINF, _ when y >. 0.0 -> Ok NaN
    | R x, PINF, _, NINF, _ when x >. 0.0 -> Ok NaN

    | NINF, R y, _, NINF, _ when y <. 0.0 -> Ok NaN
    | R x, NINF, _, NINF, _ when x <. 0.0 -> Ok NaN

    | PINF, R y, _, PINF, _ when y <. 0.0 -> Ok NaN
    | R x, PINF, _, PINF, _ when x <. 0.0 -> Ok NaN

    | NINF, R y, _, PINF, _ when y >. 0.0 -> Ok NaN
    | R x, NINF, _, PINF, _ when x >. 0.0 -> Ok NaN

    | PINF, PINF, _, _, _ -> Ok PINF
    | _, PINF, _, PINF, _ -> Ok PINF
    | NINF, PINF, _, _, _ -> Ok NINF
    | _, NINF, _, NINF, _ -> Ok NINF
    | PINF, NINF, _, _, _ -> Ok NINF
    | NINF, NINF, _, _, _ -> Ok PINF
    | _, _, _, PINF, _ -> Ok PINF
    | _, _, _, NINF, _ -> Ok NINF

    | PINF, R y, _, _, _ when y >=. 0.0 -> Ok PINF
    | PINF, R y, _, _, _ when y <. 0.0 -> Ok NINF

    | NINF, R y, _, _, _ when y >=. 0.0 -> Ok NINF
    | NINF, R y, _, _, _ when y <. 0.0 -> Ok PINF

    | R x, PINF, _, _, _ when x >=. 0.0 -> Ok PINF
    | R x, PINF, _, _, _ when x <. 0.0 -> Ok NINF

    | R x, NINF, _, _, _ when x >=. 0.0 -> Ok NINF
    | R x, NINF, _, _, _ when x <. 0.0 -> Ok PINF

    | R x, R y, s_xy, R z, s_z ->
      let open Util in
      Ok (R (x *. y *. (2 ^. s_xy) +. z *. (2 ^. s_z)))

    | _ -> Error "undefined"

  let internal_scaled_fma
    (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (f_r : Format.t)
    (pi : Projection.t)
    (x : t) (y : t) (s_xy : int) (z : t) (s_z : int) :
    (t, string) Result.t =
    let open CER in
    let open Signedness in
    let cx = decode f_x x in
    let cy = decode f_y y in
    let cz = decode f_z z in
    match aug_scaled_fma cx cy s_xy cz s_z with
    | Ok r -> project f_r pi r
    | Error e -> Error e

  let scaled_fma
    (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (f_r : Format.t)
    (pi : Projection.t)
    (x : t) (y : t) (s_xy : int) (z : t) (s_z : int) : t =
    match internal_scaled_fma f_x f_y f_z f_r pi x y s_xy z s_z  with
    | Ok r -> r
    | _ -> nan f_r (* unreachable by theorem internal_scaled_fma_ok *)


  (** 4.10.1 Minimum and Maximum *)

  let aug_minimum (x : CER.t) (y : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y with
    | NaN, _ -> Ok NaN
    | _, NaN -> Ok NaN
    | PINF, PINF -> Ok PINF
    | NINF, NINF -> Ok NINF
    | PINF, NINF -> Ok NINF
    | NINF, PINF -> Ok NINF
    | PINF, R y -> Ok (R y)
    | R x, PINF -> Ok (R x)
    | NINF, _ -> Ok NINF
    | _, NINF -> Ok NINF
    | R x, R y -> Ok (if x <. y then (R x) else (R y))
    | _ -> Error "undefined"

  let internal_minimum (f : Format.t) (x : t) (y : t) : (t, string) Result.t =
    match aug_minimum (decode f x) (decode f y) with
    | Ok r -> encode f r
    | Error e -> Error e

  let minimum (f : Format.t) (x : t) (y : t)  : t =
    match internal_minimum f x y  with
    | Ok r -> r
    | Error _ -> nan f (* unreachable by theorem internal_minimum_ok *)

  let aug_maximum (x : CER.t) (y : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y with
    | NaN, _ -> Ok NaN
    | _, NaN -> Ok NaN
    | PINF, PINF -> Ok PINF
    | NINF, NINF -> Ok NINF
    | PINF, NINF -> Ok PINF
    | NINF, PINF -> Ok PINF
    | PINF, _ -> Ok PINF
    | _, PINF -> Ok PINF
    | NINF, R y -> Ok (R y)
    | R x, NINF -> Ok (R x)
    | R x, R y -> Ok (if x <. y then (R y) else (R x))
    | _ -> Error "undefined"

  let internal_maximum (f : Format.t) (x : t) (y : t) : (t, string) Result.t =
    match aug_maximum (decode f x) (decode f y) with
    | Ok r -> encode f r
    | Error e -> Error e

  let maximum (f : Format.t) (x : t) (y : t) : t =
    match internal_maximum f x y  with
    | Ok r -> r
    | Error _ -> nan f (* unreachable by theorem internal_maximum_ok *)

  (** 4.xx Minimum, Maximum, and 'Number' variants *)

  let aug_minimum_number (x : CER.t) (y : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y with
    | NaN, NaN -> Ok NaN
    | x, NaN -> Ok x
    | NaN, y -> Ok y
    | x, y -> aug_minimum x y
    | _ -> Error "undefined"

  let internal_minimum_number (f : Format.t) (x : t) (y : t) : (t, string) Result.t =
    match aug_minimum_number (decode f x) (decode f y) with
    | Ok r -> encode f r
    | Error e -> Error e

  let minimum_number (f : Format.t) (x : t) (y : t) : t =
    match internal_minimum_number f x y with
    | Ok r -> r
    | Error _ -> nan f (* unreachable by theorem internal_minimum_number_ok *)

  let aug_maximum_number (x : CER.t) (y : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y with
    | NaN, NaN -> Ok NaN
    | x, NaN -> Ok x
    | NaN, y -> Ok y
    | x, y -> aug_maximum x y
    | _ -> Error "undefined"

  let internal_maximum_number (f : Format.t) (x : t) (y : t) : (t, string) Result.t =
    match aug_maximum_number (decode f x) (decode f y) with
    | Ok r -> encode f r
    | Error e -> Error e

  let maximum_number (f : Format.t) (x : t) (y : t) : t =
    match internal_maximum_number f x y with
    | Ok r -> r
    | Error _ -> nan f (* unreachable by theorem internal_maximum_number_ok *)

  (** 4.xx MinimumMagnitude, MaximumMagnitude, and 'Number' variants *)

  let aug_minimum_magnitude (x : CER.t) (y : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y with
    | NaN, _ -> Ok NaN
    | _, NaN -> Ok NaN
    | PINF, PINF -> Ok PINF
    | NINF, NINF -> Ok NINF
    | PINF, NINF -> Ok NINF
    | NINF, PINF -> Ok NINF
    | (PINF | NINF), R y  -> Ok (R y)
    | R x, (PINF | NINF)  -> Ok (R x)
    | R x, R y when Real.abs x <. Real.abs y -> Ok (R x)
    | R x, R y when Real.abs x >. Real.abs y -> Ok (R y)
    | R x, R y when Real.abs x = Real.abs y -> Ok (if x <. y then (R x) else (R y))
    | _ -> Error "undefined"

  let internal_minimum_magnitude (f : Format.t) (x : t) (y : t) : (t, string) Result.t =
    match aug_minimum_magnitude (decode f x) (decode f y) with
    | Ok r -> encode f r
    | Error e -> Error e

  let minimum_magnitude (f : Format.t) (x : t) (y : t)  : t =
    match internal_minimum_magnitude f x y  with
    | Ok r -> r
    | Error _ -> nan f (* unreachable by theorem internal_minimum_magnitude_ok *)

  let aug_maximum_magnitude (x : CER.t) (y : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y with
    | NaN, _ -> Ok NaN
    | _, NaN -> Ok NaN
    | PINF, _ -> Ok PINF
    | _, PINF -> Ok PINF
    | NINF, _ -> Ok NINF
    | _, NINF  -> Ok NINF
    | R x, R y when Real.abs x >. Real.abs y -> Ok (R x)
    | R x, R y when Real.abs x <. Real.abs y -> Ok (R y)
    | R x, R y when Real.abs x = Real.abs y -> Ok (if x <. y then (R y) else (R x))
    | _ -> Error "undefined"

  let internal_maximum_magnitude (f : Format.t) (x : t) (y : t) : (t, string) Result.t =
    match aug_maximum_magnitude (decode f x) (decode f y) with
    | Ok r -> encode f r
    | Error e -> Error e

  let maximum_magnitude (f : Format.t) (x : t) (y : t) : t =
    match internal_maximum_magnitude f x y  with
    | Ok r -> r
    | Error _ -> nan f (* unreachable by theorem internal_maximum_magnitude_ok *)

  let minimum_magnitude_number (f : Format.t) (x : t) (y : t) : t =
    match x, y with
    | _, _ when is_nan f x -> x
    | _, _ when is_nan f y -> y
    | _, _ -> minimum_magnitude f x y

  let maximum_magnitude_number (f : Format.t) (x : t) (y : t) : t =
    match x, y with
    | _, _ when is_nan f x -> x
    | _, _ when is_nan f y -> y
    | _, _ -> maximum_magnitude f x y


  (** 4.10.2 MinimumFinite, MaximumFinite *)

  let aug_minimum_finite (x : CER.t) (y : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y with
    | NaN, NaN -> Ok NaN
    | NaN, y -> Ok y
    | x, NaN -> Ok x
    | PINF, PINF -> Ok PINF
    | NINF, NINF -> Ok NINF
    | PINF, NINF -> Ok NINF
    | NINF, PINF -> Ok NINF
    | PINF, R y -> Ok (R y)
    | R x, PINF -> Ok (R x)
    | NINF, R y -> Ok (R y)
    | R x, NINF -> Ok (R x)
    | R x, R y -> Ok (if x <. y then (R x) else (R y))
    | _ -> Error "undefined"

  let internal_minimum_finite (f : Format.t) (x : t) (y : t) : (t, string) Result.t =
    match aug_minimum_finite (decode f x) (decode f y) with
    | Ok r -> encode f r
    | Error e -> Error e

  let minimum_finite (f : Format.t) (x : t) (y : t) : t =
    match internal_minimum_finite f x y  with
    | Ok r -> r
    | Error _ -> nan f (* unreachable by theorem internal_minimum_finite_ok *)

  let aug_maximum_finite (x : CER.t) (y : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, y with
    | NaN, NaN -> Ok NaN
    | NaN, y -> Ok y
    | x, NaN -> Ok x
    | PINF, PINF -> Ok PINF
    | NINF, NINF -> Ok NINF
    | PINF, NINF -> Ok PINF
    | NINF, PINF -> Ok PINF
    | PINF, R y -> Ok (R y)
    | R x, PINF -> Ok (R x)
    | NINF, R y -> Ok (R y)
    | R x, NINF -> Ok (R x)
    | R x, R y -> Ok (if x <. y then (R y) else (R x))
    | _ -> Error "undefined"

  let internal_maximum_finite (f : Format.t) (x : t) (y : t) : (t, string) Result.t =
    match aug_maximum_finite (decode f x) (decode f y) with
    | Ok r -> encode f r
    | Error e -> Error e

  let maximum_finite (f : Format.t) (x : t) (y : t) : t =
    match internal_maximum_finite f x y  with
    | Ok r -> r
    | Error _ -> nan f (* unreachable by theorem internal_maximum_finite_ok *)

  (**  4.9.3 Clamp *)

  let aug_clamp (x : CER.t) (lo : CER.t) (hi : CER.t) : (CER.t, string) Result.t =
    let open CER in
    match x, lo, hi with
    | NaN, _, _ -> Ok NaN
    | _, NaN, _ -> Ok NaN
    | _, _, NaN -> Ok NaN

    | _, R lo, R hi when lo >. hi -> Ok NaN

    | _, PINF, PINF -> Ok PINF
    | _, NINF, NINF -> Ok NINF
    | _, _, NINF -> Ok NaN
    | _, PINF, _ -> Ok NaN

    | PINF, _, PINF -> Ok PINF
    | PINF, _, R hi -> Ok (R hi)
    | NINF, NINF, _ -> Ok NINF
    | NINF, R lo, _ -> Ok (R lo)
    | R x, NINF, PINF -> Ok (R x)

    | R x, NINF, R hi when x <=. hi -> Ok (R x)
    | R x, NINF, R hi when x >. hi -> Ok (R hi)
    | R x, R lo, PINF when x <=. lo -> Ok (R lo)
    | R x, R lo, PINF when x >. lo -> Ok (R x)

    | R x, R lo, R hi -> Ok (R (
        if x <=. lo then lo
        else if x >=. hi then hi
        else x))
    | _ -> Error "undefined"

  let internal_clamp (f : Format.t) (x : t) (lo : t) (hi : t) : (t, string) Result.t =
    match aug_clamp (decode f x) (decode f lo) (decode f hi) with
    | Ok r -> encode f r
    | Error e -> Error e

  let clamp (f : Format.t) (x : t) (lo : t) (hi : t) : t =
    match internal_clamp f x lo hi with
    | Ok r -> r
    | Error _ -> nan f (* unreachable by theorem internal_clamp_ok *)


  (** 4.10.2 Comparisons *)

  let aug_compare_less (x : CER.t) (y : CER.t) : (bool, string) Result.t =
    let open CER in
    match x, y with
    | NaN, _ -> Ok false
    | _, NaN -> Ok false
    | PINF, _ -> Ok false
    | _, PINF -> Ok true
    | NINF, NINF -> Ok false
    | NINF, _ -> Ok true
    | _, NINF -> Ok false
    | R x, R y -> Ok (x <. y)
    | _ -> Error "undefined"

  let internal_compare_less (f_x : Format.t) (f_y : Format.t)  (x : t) (y : t) : (bool, string) Result.t =
    aug_compare_less (decode f_x x) (decode f_y y)

  let compare_less (f_x : Format.t) (f_y : Format.t) (x : t) (y : t)  : bool =
    match internal_compare_less f_x f_y x y  with
    | Ok r -> r
    | Error _ -> false (* unreachable by theorem internal_compare_less_ok *)


  let aug_compare_less_equal (x : CER.t) (y : CER.t) : (bool, string) Result.t =
    let open CER in
    match x, y with
    | NaN, _ -> Ok false
    | _, NaN -> Ok false
    | _, PINF -> Ok true
    | NINF, _ -> Ok true
    | PINF, _ -> Ok false
    | _, NINF -> Ok false
    | R x, R y -> Ok (x <=. y)
    | _ -> Error "undefined"

  let internal_compare_less_equal (f_x : Format.t) (f_y : Format.t)  (x : t) (y : t) : (bool, string) Result.t =
    aug_compare_less_equal (decode f_x x) (decode f_y y)

  let compare_less_equal (f_x : Format.t) (f_y : Format.t) (x : t) (y : t)  : bool =
    match internal_compare_less_equal f_x f_y x y  with
    | Ok r -> r
    | Error _ -> false (* unreachable by theorem internal_compare_less_equal_ok *)


  let aug_compare_equal (x : CER.t) (y : CER.t) : (bool, string) Result.t =
    let open CER in
    match x, y with
    | NaN, _ -> Ok false
    | _, NaN -> Ok false
    | PINF, PINF -> Ok true
    | NINF, NINF -> Ok true
    | PINF, _ -> Ok false
    | NINF, _ -> Ok false
    | _, NINF -> Ok false
    | _, PINF -> Ok false
    | R x, R y -> Ok (x = y)
    | _ -> Error "undefined"

  let internal_compare_equal (f_x : Format.t) (f_y : Format.t)  (x : t) (y : t) : (bool, string) Result.t =
    aug_compare_equal (decode f_x x) (decode f_y y)

  let compare_equal (f_x : Format.t) (f_y : Format.t) (x : t) (y : t)  : bool =
    match internal_compare_equal f_x f_y x y  with
    | Ok r -> r
    | Error _ -> false (* unreachable by theorem internal_compare_equal_ok *)


  let aug_compare_greater (x : CER.t) (y : CER.t) : (bool, string) Result.t =
    let open CER in
    match x, y with
    | NaN, _ -> Ok false
    | _, NaN -> Ok false
    | _, PINF -> Ok false
    | NINF, NINF -> Ok false
    | _, NINF -> Ok true
    | PINF, _ -> Ok true
    | NINF, _ -> Ok false
    | R x, R y -> Ok (x >. y)
    | _ -> Error "undefined"

  let internal_compare_greater (f_x : Format.t) (f_y : Format.t)  (x : t) (y : t) : (bool, string) Result.t =
    aug_compare_greater (decode f_x x) (decode f_y y)

  let compare_greater (f_x : Format.t) (f_y : Format.t) (x : t) (y : t)  : bool =
    match internal_compare_greater f_x f_y x y  with
    | Ok r -> r
    | Error _ -> false (* unreachable by theorem internal_compare_greater_ok *)


  let aug_compare_greater_equal (x : CER.t) (y : CER.t) : (bool, string) Result.t =
    let open CER in
    match x, y with
    | NaN, _ -> Ok false
    | _, NaN -> Ok false
    | PINF, _ -> Ok true
    | NINF, NINF -> Ok true
    | NINF, _ -> Ok false
    | _, PINF -> Ok false
    | _, NINF -> Ok true
    | R x, R y -> Ok (x >=. y)
    | _ -> Error "undefined"

  let internal_compare_greater_equal (f_x : Format.t) (f_y : Format.t)  (x : t) (y : t) : (bool, string) Result.t =
    aug_compare_greater_equal (decode f_x x) (decode f_y y)

  let compare_greater_equal (f_x : Format.t) (f_y : Format.t) (x : t) (y : t)  : bool =
    match internal_compare_greater_equal f_x f_y x y  with
    | Ok r -> r
    | Error _ -> false (* unreachable by theorem internal_compare_greater_equal_ok *)


  (** 4.10.3 Predicates and classification *)

  let aug_is_zero (x : CER.t) : (bool, string) Result.t =
    match x with
    | NaN -> Ok false
    | (PINF | NINF) -> Ok false
    | R x -> Ok (x = 0.0)
    | _ -> Error "undefined"

  let internal_is_zero (f : Format.t) (x : t) : (bool, string) Result.t =
    aug_is_zero (decode f x)

  let is_zero (f : Format.t) (x : t) : bool =
    match internal_is_zero f x with
    | Ok r -> r
    | _ -> false (* unreachable by theorem internal_is_zero_ok *)


  let aug_is_one (x : CER.t) : (bool, string) Result.t =
    match x with
    | NaN -> Ok false
    | (PINF | NINF) -> Ok false
    | R x -> Ok (x = 1.0)
    | _ -> Error "undefined"

  let internal_is_one (f : Format.t) (x : t) : (bool, string) Result.t =
    aug_is_one (decode f x)

  let is_one (f : Format.t) (x : t) : bool =
    match internal_is_one f x with
    | Ok r -> r
    | _ -> false (* unreachable by theorem internal_is_one_ok *)

  let is_nan (f : Format.t) (x : t) : bool = is_nan f x [@@macro]

  let aug_is_sign_minus (x : CER.t) : (bool, string) Result.t =
    match x with
    | NaN -> Ok false
    | PINF -> Ok false
    | NINF -> Ok true
    | R x -> Ok (x <. 0.0)
    | _ -> Error "undefined"

  let internal_is_sign_minus (f : Format.t) (x : t) : (bool, string) Result.t =
    aug_is_sign_minus (decode f x)

  let is_sign_minus (f : Format.t) (x : t) : bool =
    match internal_is_sign_minus f x with
    | Ok r -> r
    | _ -> false (* unreachable by theorem internal_is_sign_minus_ok *)

  let is_normal (f : Format.t) (x : t) : bool =
    let open Signedness in
    let k, p, _, _, _, _, _ = Format.parameters f in
    match x with
    | _ when is_zero f x || is_ninf f x || is_pinf f x || is_nan f x -> false
    | _ ->
      let x = to_int_repr f x in
      (match f.s with
      | Signed -> Util.machine_idiv (x mod (Util.ipow2 (k - 1))) (Util.ipow2 (p - 1)) > 0
      | Unsigned -> Util.machine_idiv x (Util.ipow2 (p - 1)) > 0
      )

  let is_subnormal (f : Format.t) (x : t) : bool =
    match x with
    | _ when is_zero f x || is_ninf f x || is_pinf f x || is_nan f x -> false
    | _ -> not (is_normal f x)

  let is_finite (f : Format.t) (x : t) : bool = not (is_ninf f x) && not (is_pinf f x) && not (is_nan f x) [@@macro]

  let is_infinite (f : Format.t) (x : t) : bool = is_ninf f x || is_pinf f x [@@macro]

  let is_signaling (_f : Format.t) (_x : t) : bool = false

  let is_canonical (_f : Format.t) (_x : t) : bool = true

  (** Classifier *)

  type class_ =
    | NaN
    | NegativeInfinity
    | NegativeNormal
    | NegativeSubnormal
    | Zero
    | PositiveSubnormal
    | PositiveNormal
    | PositiveInfinity

  let internal_class (f : Format.t) (x : t) : (class_, string) Result.t =
    if is_nan f x then Ok NaN
    else if is_infinite f x && is_sign_minus f x then Ok NegativeInfinity
    else if is_normal f x && is_sign_minus f x then Ok NegativeNormal
    else if is_subnormal f x && is_sign_minus f x then Ok NegativeSubnormal
    else if is_zero f x then Ok Zero
    else if is_subnormal f x && not (is_sign_minus f x) then Ok PositiveSubnormal
    else if is_normal f x && not (is_sign_minus f x) then Ok PositiveNormal
    else if is_infinite f x && not (is_sign_minus f x) then Ok PositiveInfinity
    else Error "unclassified"

  let class_ (f : Format.t) (x : t) : class_ =
    match internal_class f x with
    | Ok c -> c
    | Error _ -> NaN (* Unchreable by thm_class_internal_ok *)


  (** 4.10.5 Total order predicate *)

  let total_order (f_x : Format.t) (f_y : Format.t) (x : t) (y: t) : bool =
    match x, y with
    | _, _ when is_nan f_x x -> true
    | _, _ when is_nan f_y y -> false
    | _ -> compare_less_equal f_x f_y x y


  (** 4.10.6 Comparison predicates *)

  let equal f_x f_y x y = compare_equal f_x f_y x y

  let greater f_x f_y x y = compare_greater f_x f_y x y

  let greater_equal f_x f_y x y = compare_greater_equal f_x f_y x y

  let less f_x f_y x y = compare_less f_x f_y x y

  let less_equal f_x f_y x y = compare_less_equal f_x f_y x y

  let ordered f_x f_y x y = total_order f_x f_y x y

  let not_equal f_x f_y x y = not (compare_equal f_x f_y x y)

  let not_greater f_x f_y x y = not (compare_greater f_x f_y x y)

  let not_greater_equal f_x f_y x y = not (compare_greater_equal f_x f_y x y)

  let not_less f_x f_y x y = not (compare_less f_x f_y x y)

  let not_less_equal f_x f_y x y = not (compare_less_equal f_x f_y x y)

  let unordered f_x f_y x y = not (total_order f_x f_y x y)


  (** Convert [x] to a string *)
  let to_string (f : Format.t) (x : t) : string =
    CER.to_string (decode f x)
  [@@program]


  (** 6 Block operations *)

  open ErrorPropagation

  let rec fold (f : 'a -> 'a -> ('a, string) Result.t) (x: 'a list) : ('a, string) Result.t =
    match x with
    | [] -> Error "invalid fold"
    | [x1] -> Error "invalid fold"
    | [x1; x2] -> f x1 x2
    | x1 :: rest ->
      let* x2 = fold f rest in
      f x1 x2
    | _ -> Error "invalid fold"


  (** 6.0.1 DecodeBlock *)

  let map_aug_multiply (f_s : Format.t) (f_x : Format.t) (s : t) (x : t list) : (CER.t, string) Result.t list =
    List.map (fun x_i -> aug_multiply (decode f_s s) (decode f_x x_i)) x

  let decode_block (f_s : Format.t) (f_x : Format.t) (b : int) (s, x : t * t list) : (CER.t list, string) Result.t =
    if b < 2 || b <> List.length x then
      Error "invalid block size"
    else
      let@ cz = map_aug_multiply f_s f_x s x in
      Ok cz

  (** 6.0.2 EncodeBlock *)

  let map_project (f : Format.t) (pi : Projection.t) (x : CER.t list) : (t, string) Result.t list =
    List.map (project f pi) x

  let encode_block_map_cz cs x =
    List.map
      (fun x_i ->
        match cs with
        | CER.NaN | _ when x_i = CER.NaN -> Ok CER.NaN
        | R 0.0 -> Ok (R 0.0)
        | (PINF | NINF) -> Ok (R 1.0)
        | _ -> aug_divide x_i cs)
      x

  let encode_block
    (b : int)
    (f_s : Format.t) (f_z : Format.t) (pi_z : Projection.t)
    (s, x : t * CER.t list) :
    (t list, string) Result.t =
    if b < 0 || b <> List.length x then
      Error "invalid block size"
    else
      let open CER in
      let cs = decode f_s s in
      let@ cz = encode_block_map_cz cs x in
      let@ z = map_project f_z pi_z cz in
      Ok z

  (** 6.0.3 ConvertFromBlock *)

  let convert_from_block
    (b : int)
    (f_s : Format.t) (f_x : Format.t) (f_z : Format.t)
    (pi_s : Projection.t) (pi_z : Projection.t)
    (s, x : t * t list) :
    (t list, string) Result.t =
    if b < 0 || b <> List.length x then
      Error "invalid block size"
    else
      let* cz = decode_block f_s f_x b (s, x) in
      let@ z = map_project f_z pi_z cz in
      Ok z

  (** 6.0.4 ConvertToBlock *)

  let map_decode f_x x = List.map (decode f_x) x

  let convert_to_block
    (b : int)
    (f_s : Format.t) (f_x : Format.t) (f_z : Format.t) (pi_z : Projection.t)
    (x, s : t list * t) :
    (t * t list, string) Result.t =
    let cx = map_decode f_x x in
    let* z = encode_block b f_s f_z pi_z (s, cx) in
    Ok (s, z)

  (** 6.0.5 ConvertToBlockMaxAbsFinite *)

  let map_aug_abs (x : CER.t list) : (CER.t, string) Result.t list = List.map aug_abs x

  let fold_aug_maximum_finite (x : CER.t list) : (CER.t, string) Result.t = fold aug_maximum_finite x

  let map_convert_maf s' cx =
    List.map (fun cx_i -> if s' = CER.zero then Ok CER.zero else aug_divide cx_i s') cx

  let convert_to_block_max_abs_finite
    (b : int)
    (f_s : Format.t) (f_x : Format.t) (f_z : Format.t)
    (pi_s : Projection.t) (pi_z : Projection.t)
    (x : t list) :
    (t * t list, string) Result.t =
    if (b < 2 || b <> List.length x) then
      Error "invalid block size"
    else
      let cx = map_decode f_x x in
      let@ m = map_aug_abs cx in
      let* cs = fold_aug_maximum_finite m in
      let* s = project f_s pi_s cs in
      let s' = decode f_s s in
      let@ cz = map_convert_maf s' cx in
      let@ z = map_project f_z pi_z cz in
      Ok (s, z)


  (** 6.0.3 DotBlock *)

  let map2_aug_multiply (cx : CER.t list) (cy : CER.t list) : ((CER.t, string) Result.t list, string) Result.t =
    List.map2 aug_multiply cx cy

  let fold_aug_add (cp : CER.t list) : (CER.t, string) Result.t =
    fold aug_add cp

  let dot_block
    (b : int)
    (f_sx : Format.t) (f_x : Format.t)
    (f_sy : Format.t) (f_y : Format.t)
    (f_z : Format.t)
    (pi_z : Projection.t)
    (s_x, x : t * t list)
    (s_y, y : t * t list) :
    (t, string) Result.t =
    let* cx = decode_block f_sx f_x b (s_x, x) in
    let* cy = decode_block f_sy f_y b (s_y, y) in
    let*@ cp = map2_aug_multiply cx cy in
    let* cz = fold_aug_add cp in
    let* z = project f_z pi_z cz in
    Ok z


  (** 6.0.4 AddBlock *)

  let map2_aug_add cx cy = List.map2 aug_add cx cy

  let map_add_block f_z pi_z cs cz = List.map (fun cz_i -> let* d = aug_divide cz_i cs in project f_z pi_z d) cz

  let add_block
    (b : int)
    (f_sx : Format.t) (f_x : Format.t)
    (f_sy : Format.t) (f_y : Format.t)
    (f_s : Format.t)
    (f_z : Format.t)
    (pi_s : Projection.t)
    (pi_z : Projection.t)
    (s_x, x : t * t list)
    (s_y, y : t * t list)
    (s_z : t) :
    (t list, string) Result.t =
    let* cx = decode_block f_sx f_x b (s_x, x) in
    let* cy = decode_block f_sy f_y b (s_y, y) in
    let*@ cz = map2_aug_add cx cy in
    let cs = decode f_s s_z in
    let@ z = map_add_block f_z pi_z cs cz in
    Ok z

end