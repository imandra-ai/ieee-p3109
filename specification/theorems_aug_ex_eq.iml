[@@@import Util, "dune:math"]
[@@@import ExReal, "dune:math"]
[@@@import CER, "dune:math"]
[@@@import Sqrt, "dune:math"]
[@@@import Exp, "dune:math"]
[@@@import Log, "dune:math"]
[@@@import Specification, "specification.iml"]
[@@@import Theorems_pow2, "theorems_pow2.iml"]

let unroll_nonlin qt nqt steps = Tactic.unroll ~smt:"z3-full-nonlinear" ~query_timeout:qt ~no_asm_query_timeout:nqt steps

open Specification
open Theorems_pow2

(* A number of equivalence proofs between augmented-real definitions and their corresponding extended-real definitions. *)

(* First, some templates to check equivalence between CER and ExReal functions. *)

let t_aug_eq1 (x : CER.t)
  (aug_f : CER.t -> (CER.t, string) Result.t)
  (ex_f : ExReal.t -> (ExReal.t, string) Result.t) =
  let open CER in
  match a2e x with
  | Ok xe ->
    let ar = aug_f x in
    (match ex_f xe with
    | Ok x -> ar2er ar = Ok x
    | Error _ -> ar = Ok NaN)
  | _ -> true

let t_aug_eq1b (x : CER.t)
  (aug_f : CER.t -> (bool, string) Result.t)
  (ex_f : ExReal.t -> (bool, string) Result.t) =
  let open CER in
  match a2e x with
  | Ok xe -> aug_f x = ex_f xe
  | _ -> true

let t_aug_eq2 (x : CER.t) (y : CER.t)
  (aug_f : CER.t -> CER.t -> (CER.t, string) Result.t)
  (ex_f : ExReal.t -> ExReal.t -> (ExReal.t, string) Result.t) =
  let open CER in
  match a2e x, a2e y with
  | Ok xe, Ok ye ->
    let ar = aug_f x y in
    (match ex_f xe ye with
    | Ok x -> ar2er ar = Ok x
    | Error _ -> ar = Ok NaN)
  | _ -> true

let t_aug_eq2r (x : CER.t) (y : CER.t)
  (aug_f : CER.t -> CER.t -> (CER.t, string) Result.t)
  (ex_f : (ExReal.t, string) Result.t -> (ExReal.t, string) Result.t -> (ExReal.t, string) Result.t) =
  let open CER in
  match a2e x, a2e y with
  | Ok xe, Ok ye ->
    let ar = aug_f x y in
    (match ex_f (Ok xe) (Ok ye) with
    | Ok x -> ar2er ar = Ok x
    | Error _ -> ar = Ok NaN)
  | _ -> true

let t_aug_eq2b (x : CER.t) (y : CER.t)
  (aug_f : CER.t -> CER.t -> (bool, string) Result.t)
  (ex_f : ExReal.t -> ExReal.t -> (bool, string) Result.t) =
  let open CER in
  match a2e x, a2e y with
  | Ok xe, Ok ye -> aug_f x y = ex_f xe ye
  | _ -> true

let t_aug_eq3 (x : CER.t) (y : CER.t) (z : CER.t)
  (aug_f : CER.t -> CER.t -> CER.t -> (CER.t, string) Result.t)
  (ex_f : ExReal.t -> ExReal.t -> ExReal.t -> (ExReal.t, string) Result.t) =
  let open CER in
  match a2e x, a2e y, a2e z with
  | Ok xe, Ok ye, Ok ze ->
    let ar = aug_f x y z in
    (match ex_f xe ye ze with
    | Ok x -> ar2er ar = Ok x
    | Error _ -> ar = Ok NaN)
  | _ -> true

let t_aug_eq3r (x : CER.t) (y : CER.t) (z : CER.t)
  (aug_f : CER.t -> CER.t -> CER.t -> (CER.t, string) Result.t)
  (ex_f : (ExReal.t, string) Result.t -> (ExReal.t, string) Result.t -> (ExReal.t, string) Result.t -> (ExReal.t, string) Result.t) =
  let open CER in
  match a2e x, a2e y, a2e z with
  | Ok xe, Ok ye, Ok ze ->
    let ar = aug_f x y z in
    (match ex_f (Ok xe) (Ok ye) (Ok ze) with
    | Ok x -> ar2er ar = Ok x
    | Error _ -> ar = Ok NaN)
  | _ -> true



(* Now the theorems. *)



theorem abs_aug_ex_eq (x : CER.t) =
  let open ExReal.ResultInfix in
  t_aug_eq1 x Float.aug_abs (fun xe -> Ok (ExReal.abs xe))
  [@@by auto]

theorem negate_aug_ex_eq (x : CER.t) =
  let open ExReal.ResultInfix in
  t_aug_eq1 x Float.aug_negate (fun xe -> Ok (ExReal.neg xe))
  [@@by auto]

theorem copy_sign_aug_ex_eq (x : CER.t) (y : CER.t) =
  t_aug_eq2 x y Float.aug_copy_sign
  (fun xe ye ->
    let open ExReal.Infix in
    if ye >=. ExReal.zero then
      Ok (ExReal.abs xe)
    else
      Ok (ExReal.neg (ExReal.abs xe))
  )
  [@@by auto]

theorem add_aug_ex_eq (x : CER.t) (y : CER.t) =
  let open ExReal.ResultInfix in
  t_aug_eq2r x y Float.aug_add (fun xe ye -> xe +. ye)
  [@@by auto]

theorem subtract_aug_ex_eq (x : CER.t) (y : CER.t) =
  let open ExReal.ResultInfix in
  t_aug_eq2r x y Float.aug_subtract (fun xe ye -> xe -. ye)
  [@@by auto]

theorem multiply_aug_ex_eq (x : CER.t) (y : CER.t) =
  let open ExReal.ResultInfix in
  t_aug_eq2r x y Float.aug_multiply (fun xe ye -> xe *. ye)
  [@@by auto]

theorem divide_aug_ex_eq (x : CER.t) (y : CER.t) =
  let open ExReal.ResultInfix in
  t_aug_eq2r x y Float.aug_divide (fun xe ye -> xe /. ye)
  [@@by auto]

theorem fma_aug_ex_eq (x : CER.t) (y : CER.t) (z : CER.t) =
  let open ExReal.ResultInfix in
  t_aug_eq3r x y z Float.aug_fma (fun xe ye ze -> (xe *. ye) +. ze)
  [@@by auto]

theorem faa_aug_ex_eq (x : CER.t) (y : CER.t) (z : CER.t) =
  let open ExReal.ResultInfix in
  t_aug_eq3r x y z Float.aug_faa (fun xe ye ze -> xe +. ye +. ze)
  [@@by auto]

theorem recip_aug_ex_eq (x : CER.t) =
  let open ExReal.Infix in
  t_aug_eq1 x Float.aug_recip (fun xe -> ExReal.one /. xe)
  [@@by auto]

theorem sqrt_aug_ex_eq (x : CER.t) =
  let open ExReal.ResultInfix in
  t_aug_eq1 x Float.aug_sqrt (fun xe -> ExReal.sqrt xe 8)
  [@@by auto]

theorem rsqrt_aug_ex_eq (x : CER.t) =
  t_aug_eq1 x Float.aug_rsqrt (fun xe ->
    let open ExReal in
    match xe with
    | NINF -> Error "undefined"
    | PINF -> Ok (R 0.0)
    | R x when x <=. 0.0 -> Error "undefined"
    | R x ->
      let open ExReal.ResultInfix in
      (Ok ExReal.one) /. (ExReal.sqrt xe 8))
  [@@timeout 60]
  [@@by auto]

theorem hypot_helper x =
  ((Util.ripow (Real.abs x) 2) [@trigger]) >=. 0.0
  [@@by auto]
  [@@fc]

theorem hypot_aug_ex_eq (x : CER.t) (y : CER.t) =
  t_aug_eq2 x y Float.aug_hypot (fun xe ye ->
    let open ExReal.Infix in
    let open ExReal.ResultInfix in
    ExReal.ResultInfix.sqrt (((ExReal.abs xe) ^ 2) +. ((ExReal.abs ye) ^ 2)) 8
  )
  [@@timeout 120]
  [@@disable Sqrt.sqrt, Util.ripow, Real.abs]
  [@@by auto]

theorem exp_aug_ex_eq (x : CER.t) =
  t_aug_eq1 x Float.aug_exp (fun xe -> ExReal.exp xe 9)
  [@@by auto]

theorem exp2_aug_ex_eq (x : CER.t) =
  t_aug_eq1 x Float.aug_exp2 (fun xe -> ExReal.exp2 xe 9)
  [@@by auto]

theorem log_aug_ex_eq (x : CER.t) =
  t_aug_eq1 x Float.aug_log (fun xe -> ExReal.ln xe 9)
  [@@by unroll_nonlin 10 10 100]

theorem log2_aug_ex_eq (x : CER.t) =
  t_aug_eq1 x Float.aug_log2 (fun xe -> ExReal.log2 xe 9)
  [@@by unroll_nonlin 10 10 100]

theorem minimum_aug_ex_eq (x : CER.t) (y : CER.t) =
  t_aug_eq2 x y Float.aug_minimum (fun xe ye -> Ok (ExReal.min xe ye))
  [@@by auto]

theorem maximum_aug_ex_eq (x : CER.t) (y : CER.t) =
  t_aug_eq2 x y Float.aug_maximum (fun xe ye -> Ok (ExReal.max xe ye))
  [@@by auto]

theorem minimum_magnitude_aug_ex_eq (x : CER.t) (y : CER.t) =
  t_aug_eq2 x y Float.aug_minimum_magnitude (fun x y ->
    let open ExReal.Infix in
    match x, y with
    | _, _ when ExReal.abs x <. ExReal.abs y -> Ok x
    | _, _ when ExReal.abs x >. ExReal.abs y -> Ok y
    | _, _ when ExReal.abs x = ExReal.abs y -> Ok (ExReal.min x y)
    | _ -> Error "unreachable"
    )
  [@@by auto]

theorem maximum_magnitude_aug_ex_eq (x : CER.t) (y : CER.t) =
  t_aug_eq2 x y Float.aug_maximum_magnitude (fun x y ->
    let open ExReal.Infix in
    match x, y with
    | _, _ when ExReal.abs x >. ExReal.abs y -> Ok x
    | _, _ when ExReal.abs x <. ExReal.abs y -> Ok y
    | _, _ when ExReal.abs x = ExReal.abs y -> Ok (ExReal.max x y)
    | _ -> Error "unreachable"
    )
  [@@by auto]

theorem clamp_aug_ex_eq (x : CER.t) (lo : CER.t) (hi : CER.t) =
  let open ExReal.ResultInfix in
  t_aug_eq3 x lo hi Float.aug_clamp (fun x lo hi ->
    let open ExReal.Infix in
    if lo >. hi then Error "undefined"
    else if x <=. lo then Ok lo
    else if x >=. hi then Ok hi
    else Ok x)
  [@@by auto]

theorem compare_less_aug_ex_eq (x : CER.t) (y : CER.t) =
  t_aug_eq2b x y Float.aug_compare_less (fun x y -> Ok ExReal.Infix.(x <. y))
  [@@by auto]

theorem compare_less_equal_aug_ex_eq (x : CER.t) (y : CER.t) =
  t_aug_eq2b x y Float.aug_compare_less_equal (fun x y -> Ok ExReal.Infix.(x <=. y))
  [@@by auto]

theorem compare_equal_aug_ex_eq (x : CER.t) (y : CER.t) =
  t_aug_eq2b x y Float.aug_compare_equal (fun x y -> Ok ExReal.Infix.(x = y))
  [@@by auto]

theorem compare_greater_aug_ex_eq (x : CER.t) (y : CER.t) =
  t_aug_eq2b x y Float.aug_compare_greater (fun x y -> Ok ExReal.Infix.(x >. y))
  [@@by auto]

theorem compare_greater_equal_aug_ex_eq (x : CER.t) (y : CER.t) =
  t_aug_eq2b x y Float.aug_compare_greater_equal (fun x y -> Ok ExReal.Infix.(x >=. y))
  [@@by auto]

theorem is_zero_aug_ex_eq (x : CER.t) =
  let open ExReal.ResultInfix in
  t_aug_eq1b x Float.aug_is_zero (fun x -> Ok (x = ExReal.zero))
  [@@by auto]

theorem is_one_aug_ex_eq (x : CER.t) =
  let open ExReal.ResultInfix in
  t_aug_eq1b x Float.aug_is_one (fun x -> Ok (x = ExReal.one))
  [@@by auto]

theorem is_sign_minus_aug_ex_eq (x : CER.t) =
  let open ExReal.ResultInfix in
  t_aug_eq1b x Float.aug_is_sign_minus (fun x ->
    let open ExReal.Infix in
    Ok (x <. ExReal.zero))
  [@@by auto]


let old_internal_saturate (m_lo : ExReal.t) (m_hi : ExReal.t) (s : Signedness.t) (sat : SaturationMode.t) (rnd : RoundingMode.t) (x : ExReal.t) : (ExReal.t, string) Result.t =
  let open ExReal.Infix in
  let open RoundingMode in
  let open SaturationMode in
  let open Signedness in
  match (sat, rnd), x with
  | (_, _), x when m_lo <=. x && x <=. m_hi -> Ok (x)

  | (SatFinite, _), x when x <=. m_lo -> Ok m_lo
  | (SatFinite, _), x when x >=. m_hi -> Ok m_hi

  | (SatPropagate, _), (PINF | NINF) -> Ok (x)
  | (SatPropagate, _), x when x <=. m_lo -> Ok m_lo
  | (SatPropagate, _), x when x >=. m_hi -> Ok m_hi

  | (OvfInf, _), (PINF | NINF) -> Ok (x)
  | (OvfInf, _), x when (rnd = TowardZero || rnd = TowardPositive) && x <=. m_lo -> Ok m_lo
  | (OvfInf, _), x when (rnd = TowardZero || rnd = TowardNegative) && x >=. m_hi -> Ok m_hi

  | (OvfInf, _), x when x <=. m_lo -> if s = Signed then Ok ExReal.NINF else Ok m_lo
  | (OvfInf, _), x when x >=. m_hi -> Ok ExReal.PINF

  | _ -> Error "unreachable"

theorem saturate_aug_ex_eq (m_lo : real) (m_hi : real) (s : Signedness.t) (d : Domain.t) (sat : SaturationMode.t) (rnd : RoundingMode.t) (x : CER.t) =
  let open ExReal.ResultInfix in
  not (x = CER.NINF && s = Signedness.Unsigned) &&
  not (d = Domain.Finite && sat <> SaturationMode.SatFinite) ==>
  t_aug_eq1 x
    (fun x -> Float.internal_saturate m_lo m_hi sat rnd x s d)
    (old_internal_saturate (ExReal.R m_lo) (ExReal.R m_hi) s sat rnd)
  (* [@@by auto] *)
  [@@by unroll 100]
