[@@@import Util, "dune:math"]
[@@@import ExReal, "dune:math"]
[@@@import AugReal, "dune:math"]
[@@@import Sqrt, "dune:math"]
[@@@import Exp, "dune:math"]
[@@@import Log, "dune:math"]
[@@@import Specification, "specification.iml"]
[@@@import Theorems_pow2, "theorems_pow2.iml"]

let unroll_nonlin qt nqt steps = Tactic.unroll ~smt:"z3-full-nonlinear" ~query_timeout:qt ~no_asm_query_timeout:nqt steps

open Specification
open Theorems_pow2

(* A number of equivalence proofs between augmented-real definitions and their corresponding extended-real definitions. *)

(* First, some templates to check equivalence between AugReal and ExReal functions. *)

let t_aug_eq1 (x : AugReal.t)
  (aug_f : AugReal.t -> (AugReal.t, string) Result.t)
  (ex_f : ExReal.t -> (ExReal.t, string) Result.t) =
  let open AugReal in
  match a2e x with
  | Ok xe ->
    let ar = aug_f x in
    (match ex_f xe with
    | Ok x -> ar2er ar = Ok x
    | Error _ -> ar = Ok NaN)
  | _ -> true

let t_aug_eq1b (x : AugReal.t)
  (aug_f : AugReal.t -> (bool, string) Result.t)
  (ex_f : ExReal.t -> (bool, string) Result.t) =
  let open AugReal in
  match a2e x with
  | Ok xe -> aug_f x = ex_f xe
  | _ -> true

let t_aug_eq2 (x : AugReal.t) (y : AugReal.t)
  (aug_f : AugReal.t -> AugReal.t -> (AugReal.t, string) Result.t)
  (ex_f : ExReal.t -> ExReal.t -> (ExReal.t, string) Result.t) =
  let open AugReal in
  match a2e x, a2e y with
  | Ok xe, Ok ye ->
    let ar = aug_f x y in
    (match ex_f xe ye with
    | Ok x -> ar2er ar = Ok x
    | Error _ -> ar = Ok NaN)
  | _ -> true

let t_aug_eq2r (x : AugReal.t) (y : AugReal.t)
  (aug_f : AugReal.t -> AugReal.t -> (AugReal.t, string) Result.t)
  (ex_f : (ExReal.t, string) Result.t -> (ExReal.t, string) Result.t -> (ExReal.t, string) Result.t) =
  let open AugReal in
  match a2e x, a2e y with
  | Ok xe, Ok ye ->
    let ar = aug_f x y in
    (match ex_f (Ok xe) (Ok ye) with
    | Ok x -> ar2er ar = Ok x
    | Error _ -> ar = Ok NaN)
  | _ -> true

let t_aug_eq2b (x : AugReal.t) (y : AugReal.t)
  (aug_f : AugReal.t -> AugReal.t -> (bool, string) Result.t)
  (ex_f : ExReal.t -> ExReal.t -> (bool, string) Result.t) =
  let open AugReal in
  match a2e x, a2e y with
  | Ok xe, Ok ye -> aug_f x y = ex_f xe ye
  | _ -> true

let t_aug_eq3 (x : AugReal.t) (y : AugReal.t) (z : AugReal.t)
  (aug_f : AugReal.t -> AugReal.t -> AugReal.t -> (AugReal.t, string) Result.t)
  (ex_f : ExReal.t -> ExReal.t -> ExReal.t -> (ExReal.t, string) Result.t) =
  let open AugReal in
  match a2e x, a2e y, a2e z with
  | Ok xe, Ok ye, Ok ze ->
    let ar = aug_f x y z in
    (match ex_f xe ye ze with
    | Ok x -> ar2er ar = Ok x
    | Error _ -> ar = Ok NaN)
  | _ -> true

let t_aug_eq3r (x : AugReal.t) (y : AugReal.t) (z : AugReal.t)
  (aug_f : AugReal.t -> AugReal.t -> AugReal.t -> (AugReal.t, string) Result.t)
  (ex_f : (ExReal.t, string) Result.t -> (ExReal.t, string) Result.t -> (ExReal.t, string) Result.t -> (ExReal.t, string) Result.t) =
  let open AugReal in
  match a2e x, a2e y, a2e z with
  | Ok xe, Ok ye, Ok ze ->
    let ar = aug_f x y z in
    (match ex_f (Ok xe) (Ok ye) (Ok ze) with
    | Ok x -> ar2er ar = Ok x
    | Error _ -> ar = Ok NaN)
  | _ -> true



(* Now the theorems. *)



theorem abs_aug_ex_eq (x : AugReal.t) =
  let open ExReal.ResultInfix in
  t_aug_eq1 x Float.aug_abs (fun xe -> Ok (ExReal.abs xe))
  [@@by auto]

theorem negate_aug_ex_eq (x : AugReal.t) =
  let open ExReal.ResultInfix in
  t_aug_eq1 x Float.aug_negate (fun xe -> Ok (ExReal.neg xe))
  [@@by auto]

theorem copy_sign_aug_ex_eq (x : AugReal.t) (y : AugReal.t) =
  t_aug_eq2 x y Float.aug_copy_sign
  (fun xe ye ->
    let open ExReal.Infix in
    if ye >=. ExReal.zero then
      Ok (ExReal.abs xe)
    else
      Ok (ExReal.neg xe)
  )
  [@@by auto]

theorem add_aug_ex_eq (x : AugReal.t) (y : AugReal.t) =
  let open ExReal.ResultInfix in
  t_aug_eq2r x y Float.aug_add (fun xe ye -> xe +. ye)
  [@@by auto]

theorem subtract_aug_ex_eq (x : AugReal.t) (y : AugReal.t) =
  let open ExReal.ResultInfix in
  t_aug_eq2r x y Float.aug_subtract (fun xe ye -> xe -. ye)
  [@@by auto]

theorem multiply_aug_ex_eq (x : AugReal.t) (y : AugReal.t) =
  let open ExReal.ResultInfix in
  t_aug_eq2r x y Float.aug_multiply (fun xe ye -> xe *. ye)
  [@@by auto]

theorem divide_aug_ex_eq (x : AugReal.t) (y : AugReal.t) =
  let open ExReal.ResultInfix in
  t_aug_eq2r x y Float.aug_divide (fun xe ye -> xe /. ye)
  [@@by auto]

theorem fma_aug_ex_eq (x : AugReal.t) (y : AugReal.t) (z : AugReal.t) =
  let open ExReal.ResultInfix in
  t_aug_eq3r x y z Float.aug_fma (fun xe ye ze -> (xe *. ye) +. ze)
  [@@by auto]

theorem faa_aug_ex_eq (x : AugReal.t) (y : AugReal.t) (z : AugReal.t) =
  let open ExReal.ResultInfix in
  t_aug_eq3r x y z Float.aug_faa (fun xe ye ze -> xe +. ye +. ze)
  [@@by auto]

theorem sqrt_aug_ex_eq (x : AugReal.t) =
  let open ExReal.ResultInfix in
  t_aug_eq1 x Float.aug_sqrt (fun xe -> ExReal.sqrt xe 8)
  [@@by auto]

theorem rsqrt_aug_ex_eq (x : AugReal.t) =
  t_aug_eq1 x Float.aug_rsqrt (fun xe ->
    let open ExReal in
    match xe with
    | NINF -> Error "undefined"
    | PINF -> Ok (R 0.0)
    | R x when x <=. 0.0 -> Error "undefined"
    | R x ->
      let open ExReal.ResultInfix in
      (Ok ExReal.one) /. (ExReal.sqrt xe 8))
  [@@timeout 3600]
  [@@by unroll_nonlin 20 20 1000]

theorem hypot_aug_ex_eq (x : AugReal.t) (y : AugReal.t) =
  t_aug_eq2 x y Float.aug_hypot (fun xe ye ->
    let open ExReal.Infix in
    let open ExReal.ResultInfix in
    ExReal.ResultInfix.sqrt (((ExReal.abs xe) ^ 2) +. ((ExReal.abs ye) ^ 2)) 8
  )
  [@@timeout 3600]
  [@@by unroll_nonlin 10 10 100]

theorem exp_aug_ex_eq (x : AugReal.t) =
  t_aug_eq1 x Float.aug_exp (fun xe -> ExReal.exp xe 9)
  [@@by auto]

theorem exp2_aug_ex_eq (x : AugReal.t) =
  t_aug_eq1 x Float.aug_exp2 (fun xe -> ExReal.exp2 xe 9)
  [@@by auto]

theorem log_aug_ex_eq (x : AugReal.t) =
  t_aug_eq1 x Float.aug_log (fun xe -> ExReal.ln xe 9)
  [@@by unroll_nonlin 10 10 100]

theorem log2_aug_ex_eq (x : AugReal.t) =
  t_aug_eq1 x Float.aug_log2 (fun xe -> ExReal.log2 xe 9)
  [@@by unroll_nonlin 10 10 100]

theorem add_scaled_aug_ex_eq (x : AugReal.t) (s_x : int) (y : AugReal.t) (s_y : int) =
  let ex_f (ex : (ExReal.t, string) Result.t) (s_x : int) (ey : (ExReal.t, string) Result.t) (s_y : int) : (ExReal.t, string) Result.t=
    let open ExReal.ResultInfix in
    ex *. (2 ^. s_x) +. ey *. (2 ^. s_y)
  in
  let open AugReal in
  match a2e x, a2e y with
  | Ok xe, Ok ye ->
    let ar = Float.aug_add_scaled x s_x y s_y in
    (match ex_f (Ok xe) s_x (Ok ye) s_y with
    | Ok x -> ar2er ar = Ok x
    | Error _ -> ar = Ok NaN)
  | _ -> true
  [@@by auto]

theorem multiply_scaled_aug_ex_eq (x : AugReal.t) (y : AugReal.t) (s : int) =
  let ex_f (x : (ExReal.t, string) Result.t) (y : (ExReal.t, string) Result.t) (s : int) : (ExReal.t, string) Result.t =
    let open ExReal.ResultInfix in
    x *. y *. (2 ^. s)
  in
  let open AugReal in
  match a2e x, a2e y with
  | Ok xe, Ok ye ->
    let ar = Float.aug_multiply_scaled x y s in
    (match ex_f (Ok xe) (Ok ye) s with
    | Ok x -> ar2er ar = Ok x
    | Error _ -> ar = Ok NaN)
  | _ -> true
  [@@by auto]

theorem scaled_fma_aug_ex_eq (a : AugReal.t) (s_a : int) (x : AugReal.t) (y : AugReal.t) (s : int) =
  let ex_f (a : (ExReal.t, string) Result.t) (s_a : int) (x : (ExReal.t, string) Result.t) (y : (ExReal.t, string) Result.t) (s : int) : (ExReal.t, string) Result.t =
    let open ExReal.ResultInfix in
    a *. (2 ^. s_a) +. x *. y *. (2 ^. s)
  in
  let open AugReal in
  match a2e a, a2e x, a2e y with
  | Ok ae, Ok xe, Ok ye ->
    let ar = Float.aug_scaled_fma a s_a x y s in
    (match ex_f (Ok ae) s_a (Ok xe) (Ok ye) s with
    | Ok x -> ar2er ar = Ok x
    | Error _ -> ar = Ok NaN)
  | _ -> true
  [@@timeout 60]
  [@@by auto]

theorem minimum_aug_ex_eq (x : AugReal.t) (y : AugReal.t) =
  t_aug_eq2 x y Float.aug_minimum (fun xe ye -> Ok (ExReal.min xe ye))
  [@@by auto]

theorem maximum_aug_ex_eq (x : AugReal.t) (y : AugReal.t) =
  t_aug_eq2 x y Float.aug_maximum (fun xe ye -> Ok (ExReal.max xe ye))
  [@@by auto]

theorem minimum_magnitude_aug_ex_eq (x : AugReal.t) (y : AugReal.t) =
  t_aug_eq2 x y Float.aug_minimum_magnitude (fun x y ->
    let open ExReal.Infix in
    match x, y with
    | _, _ when ExReal.abs x <. ExReal.abs y -> Ok x
    | _, _ when ExReal.abs x >. ExReal.abs y -> Ok y
    | _, _ when ExReal.abs x = ExReal.abs y -> Ok (ExReal.min x y)
    | _ -> Error "unreachable"
    )
  [@@by auto]

theorem maximum_magnitude_aug_ex_eq (x : AugReal.t) (y : AugReal.t) =
  t_aug_eq2 x y Float.aug_maximum_magnitude (fun x y ->
    let open ExReal.Infix in
    match x, y with
    | _, _ when ExReal.abs x >. ExReal.abs y -> Ok x
    | _, _ when ExReal.abs x <. ExReal.abs y -> Ok y
    | _, _ when ExReal.abs x = ExReal.abs y -> Ok (ExReal.max x y)
    | _ -> Error "unreachable"
    )
  [@@by auto]

theorem clamp_aug_ex_eq (x : AugReal.t) (lo : AugReal.t) (hi : AugReal.t) =
  let open ExReal.ResultInfix in
  t_aug_eq3 x lo hi Float.aug_clamp (fun x lo hi ->
    let open ExReal.Infix in
    if lo >. hi then Error "undefined"
    else if x <=. lo then Ok lo
    else if x >=. hi then Ok hi
    else Ok x)
  [@@by auto]

theorem compare_less_aug_ex_eq (x : AugReal.t) (y : AugReal.t) =
  t_aug_eq2b x y Float.aug_compare_less (fun x y -> Ok ExReal.Infix.(x <. y))
  [@@by auto]

theorem compare_less_equal_aug_ex_eq (x : AugReal.t) (y : AugReal.t) =
  t_aug_eq2b x y Float.aug_compare_less_equal (fun x y -> Ok ExReal.Infix.(x <=. y))
  [@@by auto]

theorem compare_equal_aug_ex_eq (x : AugReal.t) (y : AugReal.t) =
  t_aug_eq2b x y Float.aug_compare_equal (fun x y -> Ok ExReal.Infix.(x = y))
  [@@by auto]

theorem compare_greater_aug_ex_eq (x : AugReal.t) (y : AugReal.t) =
  t_aug_eq2b x y Float.aug_compare_greater (fun x y -> Ok ExReal.Infix.(x >. y))
  [@@by auto]

theorem compare_greater_equal_aug_ex_eq (x : AugReal.t) (y : AugReal.t) =
  t_aug_eq2b x y Float.aug_compare_greater_equal (fun x y -> Ok ExReal.Infix.(x >=. y))
  [@@by auto]

theorem is_zero_aug_ex_eq (x : AugReal.t) =
  let open ExReal.ResultInfix in
  t_aug_eq1b x Float.aug_is_zero (fun x -> Ok (x = ExReal.zero))
  [@@by auto]

theorem is_one_aug_ex_eq (x : AugReal.t) =
  let open ExReal.ResultInfix in
  t_aug_eq1b x Float.aug_is_one (fun x -> Ok (x = ExReal.one))
  [@@by auto]

theorem is_sign_minus_aug_ex_eq (x : AugReal.t) =
  let open ExReal.ResultInfix in
  t_aug_eq1b x Float.aug_is_sign_minus (fun x ->
    let open ExReal.Infix in
    Ok (x <. ExReal.zero))
  [@@by auto]
