[@@@import Util, "dune:math"]
[@@@import ExReal, "dune:math"]
[@@@import CER, "dune:math"]
[@@@import Sqrt, "dune:math"]
[@@@import Exp, "dune:math"]
[@@@import Log, "dune:math"]
[@@@import Specification, "specification.iml"]
[@@@import Theorems_pow2, "theorems_pow2.iml"]

let unroll_nonlin qt nqt steps = Tactic.unroll ~smt:"z3-full-nonlinear" ~query_timeout:qt ~no_asm_query_timeout:nqt steps

open Specification
open Theorems_pow2

(* A number of equivalence proofs between augmented-real definitions and their corresponding extended-real definitions. *)

(* First, some templates to check equivalence between CER and ExReal functions. *)

let t_wEq1 (x : CER.t)
  (wF : CER.t -> (CER.t, string) Result.t)
  (ex_f : ExReal.t -> (ExReal.t, string) Result.t) =
  let open CER in
  match a2e x with
  | Ok xe ->
    let ar = wF x in
    (match ex_f xe with
    | Ok x -> ar2er ar = Ok x
    | Error _ -> ar = Ok NaN)
  | _ -> true

let t_wEq1b (x : CER.t)
  (wF : CER.t -> (bool, string) Result.t)
  (ex_f : ExReal.t -> (bool, string) Result.t) =
  let open CER in
  match a2e x with
  | Ok xe -> wF x = ex_f xe
  | _ -> true

let t_wEq2 (x : CER.t) (y : CER.t)
  (wF : CER.t -> CER.t -> (CER.t, string) Result.t)
  (ex_f : ExReal.t -> ExReal.t -> (ExReal.t, string) Result.t) =
  let open CER in
  match a2e x, a2e y with
  | Ok xe, Ok ye ->
    let ar = wF x y in
    (match ex_f xe ye with
    | Ok x -> ar2er ar = Ok x
    | Error _ -> ar = Ok NaN)
  | _ -> true

let t_wEq2r (x : CER.t) (y : CER.t)
  (wF : CER.t -> CER.t -> (CER.t, string) Result.t)
  (ex_f : (ExReal.t, string) Result.t -> (ExReal.t, string) Result.t -> (ExReal.t, string) Result.t) =
  let open CER in
  match a2e x, a2e y with
  | Ok xe, Ok ye ->
    let ar = wF x y in
    (match ex_f (Ok xe) (Ok ye) with
    | Ok x -> ar2er ar = Ok x
    | Error _ -> ar = Ok NaN)
  | _ -> true

let t_wEq2b (x : CER.t) (y : CER.t)
  (wF : CER.t -> CER.t -> (bool, string) Result.t)
  (ex_f : ExReal.t -> ExReal.t -> (bool, string) Result.t) =
  let open CER in
  match a2e x, a2e y with
  | Ok xe, Ok ye -> wF x y = ex_f xe ye
  | _ -> true

let t_wEq3 (x : CER.t) (y : CER.t) (z : CER.t)
  (wF : CER.t -> CER.t -> CER.t -> (CER.t, string) Result.t)
  (ex_f : ExReal.t -> ExReal.t -> ExReal.t -> (ExReal.t, string) Result.t) =
  let open CER in
  match a2e x, a2e y, a2e z with
  | Ok xe, Ok ye, Ok ze ->
    let ar = wF x y z in
    (match ex_f xe ye ze with
    | Ok x -> ar2er ar = Ok x
    | Error _ -> ar = Ok NaN)
  | _ -> true

let t_wEq3r (x : CER.t) (y : CER.t) (z : CER.t)
  (wF : CER.t -> CER.t -> CER.t -> (CER.t, string) Result.t)
  (ex_f : (ExReal.t, string) Result.t -> (ExReal.t, string) Result.t -> (ExReal.t, string) Result.t -> (ExReal.t, string) Result.t) =
  let open CER in
  match a2e x, a2e y, a2e z with
  | Ok xe, Ok ye, Ok ze ->
    let ar = wF x y z in
    (match ex_f (Ok xe) (Ok ye) (Ok ze) with
    | Ok x -> ar2er ar = Ok x
    | Error _ -> ar = Ok NaN)
  | _ -> true



(* Now the theorems. *)



theorem abs_wEx_eq (x : CER.t) =
  let open ExReal.ResultInfix in
  t_wEq1 x Float.wAbs (fun xe -> Ok (ExReal.abs xe))
  [@@by auto]

theorem negate_wEx_eq (x : CER.t) =
  let open ExReal.ResultInfix in
  t_wEq1 x Float.wNegate (fun xe -> Ok (ExReal.neg xe))
  [@@by auto]

theorem copy_sign_wEx_eq (x : CER.t) (y : CER.t) =
  t_wEq2 x y Float.wCopySign
  (fun xe ye ->
    let open ExReal.Infix in
    if ye >=. ExReal.zero then
      Ok (ExReal.abs xe)
    else
      Ok (ExReal.neg (ExReal.abs xe))
  )
  [@@by auto]

theorem add_wEx_eq (x : CER.t) (y : CER.t) =
  let open ExReal.ResultInfix in
  t_wEq2r x y Float.wAdd (fun xe ye -> xe +. ye)
  [@@by auto]

theorem subtract_wEx_eq (x : CER.t) (y : CER.t) =
  let open ExReal.ResultInfix in
  t_wEq2r x y Float.wSubtract (fun xe ye -> xe -. ye)
  [@@by auto]

theorem multiply_wEx_eq (x : CER.t) (y : CER.t) =
  let open ExReal.ResultInfix in
  t_wEq2r x y Float.wMultiply (fun xe ye -> xe *. ye)
  [@@by auto]

theorem divide_wEx_eq (x : CER.t) (y : CER.t) =
  let open ExReal.ResultInfix in
  t_wEq2r x y Float.wDivide (fun xe ye -> xe /. ye)
  [@@by auto]

theorem fma_wEx_eq (x : CER.t) (y : CER.t) (z : CER.t) =
  let open ExReal.ResultInfix in
  t_wEq3r x y z Float.wFMA (fun xe ye ze -> (xe *. ye) +. ze)
  [@@by auto]

theorem faa_wEx_eq (x : CER.t) (y : CER.t) (z : CER.t) =
  let open ExReal.ResultInfix in
  t_wEq3r x y z Float.wFAA (fun xe ye ze -> xe +. ye +. ze)
  [@@by auto]

theorem recip_wEx_eq (x : CER.t) =
  let open ExReal.Infix in
  t_wEq1 x Float.wRecip (fun xe -> ExReal.one /. xe)
  [@@by auto]

theorem sqrt_wEx_eq (x : CER.t) =
  let open ExReal.ResultInfix in
  t_wEq1 x Float.wSqrt (fun xe -> ExReal.sqrt xe 8)
  [@@by auto]

theorem rsqrt_wEx_eq (x : CER.t) =
  t_wEq1 x Float.wRSqrt (fun xe ->
    let open ExReal in
    match xe with
    | NINF -> Error "undefined"
    | PINF -> Ok (R 0.0)
    | R x when x <=. 0.0 -> Error "undefined"
    | R x ->
      let open ExReal.ResultInfix in
      (Ok ExReal.one) /. (ExReal.sqrt xe 8))
  [@@timeout 60]
  [@@by auto]

theorem hypot_helper x =
  ((Util.ripow (Real.abs x) 2) [@trigger]) >=. 0.0
  [@@by auto]
  [@@fc]

theorem hypot_wEx_eq (x : CER.t) (y : CER.t) =
  t_wEq2 x y Float.wHypot (fun xe ye ->
    let open ExReal.Infix in
    let open ExReal.ResultInfix in
    ExReal.ResultInfix.sqrt (((ExReal.abs xe) ^ 2) +. ((ExReal.abs ye) ^ 2)) 8
  )
  [@@timeout 120]
  [@@disable Sqrt.sqrt, Util.ripow, Real.abs]
  [@@by auto]

theorem exp_wEx_eq (x : CER.t) =
  t_wEq1 x Float.wExp (fun xe -> ExReal.exp xe 9)
  [@@by auto]

theorem exp2_wEx_eq (x : CER.t) =
  t_wEq1 x Float.wExp2 (fun xe -> ExReal.exp2 xe 9)
  [@@by auto]

theorem log_wEx_eq (x : CER.t) =
  t_wEq1 x Float.wLog (fun xe -> ExReal.ln xe 9)
  [@@by unroll_nonlin 10 10 100]

theorem log2_wEx_eq (x : CER.t) =
  t_wEq1 x Float.wLog2 (fun xe -> ExReal.log2 xe 9)
  [@@by unroll_nonlin 10 10 100]

theorem minimum_wEx_eq (x : CER.t) (y : CER.t) =
  t_wEq2 x y Float.wMinimum (fun xe ye -> Ok (ExReal.min xe ye))
  [@@by auto]

theorem maximum_wEx_eq (x : CER.t) (y : CER.t) =
  t_wEq2 x y Float.wMaximum (fun xe ye -> Ok (ExReal.max xe ye))
  [@@by auto]

theorem minimum_magnitude_wEx_eq (x : CER.t) (y : CER.t) =
  t_wEq2 x y Float.wMinimumMagnitude (fun x y ->
    let open ExReal.Infix in
    match x, y with
    | _, _ when ExReal.abs x <. ExReal.abs y -> Ok x
    | _, _ when ExReal.abs x >. ExReal.abs y -> Ok y
    | _, _ when ExReal.abs x = ExReal.abs y -> Ok (ExReal.min x y)
    | _ -> Error "unreachable"
    )
  [@@by auto]

theorem maximum_magnitude_wEx_eq (x : CER.t) (y : CER.t) =
  t_wEq2 x y Float.wMaximumMagnitude (fun x y ->
    let open ExReal.Infix in
    match x, y with
    | _, _ when ExReal.abs x >. ExReal.abs y -> Ok x
    | _, _ when ExReal.abs x <. ExReal.abs y -> Ok y
    | _, _ when ExReal.abs x = ExReal.abs y -> Ok (ExReal.max x y)
    | _ -> Error "unreachable"
    )
  [@@by auto]

theorem clamp_wEx_eq (x : CER.t) (lo : CER.t) (hi : CER.t) =
  let open ExReal.ResultInfix in
  t_wEq3 x lo hi Float.wClamp (fun x lo hi ->
    let open ExReal.Infix in
    if lo >. hi then Error "undefined"
    else if x <=. lo then Ok lo
    else if x >=. hi then Ok hi
    else Ok x)
  [@@by auto]

theorem compare_less_wEx_eq (x : CER.t) (y : CER.t) =
  t_wEq2b x y Float.wCompareLess (fun x y -> Ok ExReal.Infix.(x <. y))
  [@@by auto]

theorem compare_less_equal_wEx_eq (x : CER.t) (y : CER.t) =
  t_wEq2b x y Float.wCompareLessEqual (fun x y -> Ok ExReal.Infix.(x <=. y))
  [@@by auto]

theorem compare_equal_wEx_eq (x : CER.t) (y : CER.t) =
  t_wEq2b x y Float.wCompareEqual (fun x y -> Ok ExReal.Infix.(x = y))
  [@@by auto]

theorem compare_greater_wEx_eq (x : CER.t) (y : CER.t) =
  t_wEq2b x y Float.wCompareGreater (fun x y -> Ok ExReal.Infix.(x >. y))
  [@@by auto]

theorem compare_greater_equal_wEx_eq (x : CER.t) (y : CER.t) =
  t_wEq2b x y Float.wCompareGreaterEqual (fun x y -> Ok ExReal.Infix.(x >=. y))
  [@@by auto]

theorem is_zero_wEx_eq (x : CER.t) =
  let open ExReal.ResultInfix in
  t_wEq1b x Float.wIsZero (fun x -> Ok (x = ExReal.zero))
  [@@by auto]

theorem is_one_wEx_eq (x : CER.t) =
  let open ExReal.ResultInfix in
  t_wEq1b x Float.wIsOne (fun x -> Ok (x = ExReal.one))
  [@@by auto]

theorem is_sign_minus_wEx_eq (x : CER.t) =
  let open ExReal.ResultInfix in
  t_wEq1b x Float.wIsSignMinus (fun x ->
    let open ExReal.Infix in
    Ok (x <. ExReal.zero))
  [@@by auto]


let old_internal_saturate (m_lo : ExReal.t) (m_hi : ExReal.t) (s : Signedness.t) (sat : SaturationMode.t) (rnd : RoundingMode.t) (x : ExReal.t) : (ExReal.t, string) Result.t =
  let open ExReal.Infix in
  let open RoundingMode in
  let open SaturationMode in
  let open Signedness in
  match (sat, rnd), x with
  | (_, _), x when m_lo <=. x && x <=. m_hi -> Ok (x)

  | (SatFinite, _), x when x <=. m_lo -> Ok m_lo
  | (SatFinite, _), x when x >=. m_hi -> Ok m_hi

  | (SatPropagate, _), (PINF | NINF) -> Ok (x)
  | (SatPropagate, _), x when x <=. m_lo -> Ok m_lo
  | (SatPropagate, _), x when x >=. m_hi -> Ok m_hi

  | (OvfInf, _), (PINF | NINF) -> Ok (x)
  | (OvfInf, _), x when (rnd = TowardZero || rnd = TowardPositive) && x <=. m_lo -> Ok m_lo
  | (OvfInf, _), x when (rnd = TowardZero || rnd = TowardNegative) && x >=. m_hi -> Ok m_hi

  | (OvfInf, _), x when x <=. m_lo -> if s = Signed then Ok ExReal.NINF else Ok m_lo
  | (OvfInf, _), x when x >=. m_hi -> Ok ExReal.PINF

  | _ -> Error "unreachable"

theorem saturate_wEx_eq (m_lo : real) (m_hi : real) (s : Signedness.t) (d : Domain.t) (sat : SaturationMode.t) (rnd : RoundingMode.t) (x : CER.t) =
  let open ExReal.ResultInfix in
  not (x = CER.NINF && s = Signedness.Unsigned) &&
  not (d = Domain.Finite && sat <> SaturationMode.SatFinite) ==>
  t_wEq1 x
    (fun x -> Float.internal_wSaturate m_lo m_hi sat rnd x s d)
    (old_internal_saturate (ExReal.R m_lo) (ExReal.R m_hi) s sat rnd)
  (* [@@by auto] *)
  [@@by unroll 100]
