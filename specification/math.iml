[@@@import Exreal, "exreal.iml"]

module ExReal = Exreal

let is_even (x : int) : bool = x mod 2 = 0 [@@macro]

let is_odd (x : int) : bool = x mod 2 <> 0 [@@macro]

let rec pow2 (x : int) : real =
  match x with
  | 0 -> 1.0
  | 1 -> 2.0
  | 2 -> 4.0
  | 3 -> 8.0
  | 4 -> 16.0
  | 5 -> 32.0
  | 6 -> 64.0
  | 7 -> 128.0
  | 8 -> 256.0
  | x -> if x > 0 then 2.0 *. pow2 (x - 1) else (* x < 0 *)
                                             pow2 (x + 1) /. 2.0
  [@@measure Ordinal.of_int (abs x)]
  [@@unroll 5]

let rec ipow2 (x : int) : int =
  match x with
  | 0 -> 1
  | 1 -> 2
  | 2 -> 4
  | 3 -> 8
  | 4 -> 16
  | 5 -> 32
  | 6 -> 64
  | 7 -> 128
  | 8 -> 256
  | x -> if x <= 0 then 1 else 2 * ipow2 (x - 1)
  [@@unroll 5]

let floor (x : real) : int = Real.to_int x [@@macro]

let rec ilog2 (x : int) : int =
  (* Ugly hack, replace with dedicated number_of_digits function? *)
  let x = abs x in
  match x with
  | 0 -> 0
  | 1 -> 0
  | _ -> 1 + ilog2 ((x + 1) / 2)
  [@@measure Ordinal.of_int (abs x)]
  [@@unroll 5]

let rec floor_log2_abs (x : real) (max_depth : int) : int =
  if max_depth <= 0 then 0
  else (
    let x = Real.abs x in
    if x = 0.0 then 0
    else if x >. 1.0 then (
      let nx = x /. 2.0 in
      if nx >=. 1.0 then floor_log2_abs nx (max_depth - 1) + 1 else 0)
    else if x = 1.0 then 0
    else if x <. 1.0 then (
      let nx = x *. 2.0 in
      if nx <=. 1.0 then floor_log2_abs nx (max_depth - 1) - 1 else -1)
    else 0)
  [@@adm max_depth]
  [@@unroll 5]
