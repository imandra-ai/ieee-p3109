(** Some math utility functions *)

let is_even (x : int) : bool = x mod 2 = 0 [@@macro]

let is_odd (x : int) : bool = x mod 2 <> 0 [@@macro]

let rec pow2 (n:int) : real =
  if n > 0 then
    2.0 *. pow2 (n - 1)
  else if n < 0 then
    1.0 /. (2.0 *. (pow2 (- (n + 1))))
  else
    1.0
  [@@measure Ordinal.of_int (abs n)]

let rec pow (x : int) (n : int) : real =
  if (x = 0) then 0.0 else
  match n with
  | 0 -> 1.0
  | 1 -> Real.of_int x
  | _ when n >= 0 ->
      let x2 = x * x in
      if is_even n then
        pow x2 (n / 2)
      else
        (Real.of_int x) *. (pow x2 ((n-1) / 2))
  | _ ->
      1.0 /. ((Real.of_int x) *. (pow x (- (n + 1))))
  [@@measure Ordinal.of_int (abs n)]

let rec ipow2 (x : int) : int =
  match x with
  | 0 -> 1
  | 1 -> 2
  | x -> if x <= 0 then 1 else 2 * ipow2 (x - 1)
  [@@unroll 5]

let floor (x : real) : int = Real.to_int x [@@macro]

let rec ilog2 (x : int) : int =
  (* Ugly hack, replace with dedicated number_of_digits function? *)
  let x = abs x in
  match x with
  | 0 -> 0
  | 1 -> 0
  | _ -> 1 + ilog2 ((x + 1) / 2)
  [@@measure Ordinal.of_int (abs x)]
  [@@unroll 5]

let rec floor_log2_abs (x : real) (max_depth : int) : int =
  if max_depth <= 0 then 0
  else (
    let x = Real.abs x in
    if x = 0.0 then 0
    else if x >. 1.0 then (
      let nx = x /. 2.0 in
      if nx >=. 1.0 then floor_log2_abs nx (max_depth - 1) + 1 else 0)
    else if x = 1.0 then 0
    else if x <. 1.0 then (
      let nx = x *. 2.0 in
      if nx <=. 1.0 then floor_log2_abs nx (max_depth - 1) - 1 else -1)
    else 0)
  [@@adm max_depth]
  [@@unroll 5]
