[@@@import Util, "dune:math"]
[@@@import Log, "dune:math"]
[@@@import ErrorPropagation, "dune:basic"]
[@@@import Specification, "specification.iml"]
[@@@import Theorems_pow2, "theorems_pow2.iml"]
[@@@import Theorems_format_ranges, "theorems_format_ranges.iml"]
[@@@import Theorems_IEEE754, "theorems_ieee754.iml"]
[@@@import Theorems_exp, "theorems_exp.iml"]

open Specification
open ErrorPropagation

let unroll_nonlin qt nqt steps = Tactic.unroll ~smt:"z3-full-nonlinear" ~query_timeout:qt ~no_asm_query_timeout:nqt steps

(** Formats *)

theorem format_parameter_limits (f : Format.t) =
  let k, p, b, _, _, s, d = (Format.parameters f [@trigger]) in
  0 < k && k <= 15 &&
  0 < p && p <= 15 &&
  b <= Util.ipow2 (k - p)
  [@@timeout 600]
  [@@by unroll_nonlin 20 10 100]
  [@@fc]

theorem m_hi_gt_0 (f : Format.t) =
  let _, _, _, m_lo, m_hi, _, _ = Format.parameters f in
  m_hi >. 0.0
  [@@timeout 20]
  [@@by enumerate ["f"] @> ground_eval ()]

theorem m_lo_lt_m_hi (f : Format.t) =
  let _, _, _, m_lo, m_hi, _, _ = Format.parameters f [@trigger] in
  m_lo <. m_hi
  [@@disable Format.parameters, Util.ipow2, Util.pow2]
  [@@by [%use m_hi_gt_0 f] @> auto]
  [@@fc]


(** 4.6 Functions *)

theorem internal_wSaturate_ok (m_lo : real) (m_hi : real) (sat : SaturationMode.t) (rnd : RoundingMode.t) (x : CER.t)  (s : Signedness.t) (d : Domain.t) =
  Result.is_ok (Float.internal_wSaturate m_lo m_hi sat rnd x s d  [@trigger])
  [@@by auto]
  [@@fc]

theorem internal_wRoundToPrecision_ok (p : int) (b : int) (rnd : RoundingMode.t) (x : CER.t) =
  Result.is_ok (Float.internal_wRoundToPrecision p b rnd x)

(* [decode_aux] never throws an error *)
theorem wDecodeAux_ok (k : int) (p : int) (b : int) (s: Signedness.t) (d : Domain.t) (x : Float.t) =
  Result.is_ok ((Float.wDecodeAux k p b s d x) [@trigger])
  [@@timeout 240]
  [@@by auto]
  [@@fc]

(* [decode] always produces numbers within the format range *)
theorem decode_within_range (f : Format.t) (x : Float.t) =
  cer_is_within_range f ((Float.wDecode f x) [@trigger])
  [@@timeout 600]
  [@@disable Float.wDecode, Float.wDecodeAux, Format.parameters]
  [@@by [%use Theorems_format_ranges.within_format_range f x] @> auto]
  [@@fc]

(* [wEncode] is ok if the input is within the format range *)
theorem wEncode_ok_within_range (f : Format.t) (x : CER.t) =
  let _, _, _, m_lo, m_hi, s, _ = Format.parameters f in
  let encoded = Float.wEncode f x [@@trigger] in
  if cer_is_within_range f x then
    Result.is_ok encoded
  else
    Result.is_error encoded
  [@@by unroll_nonlin 10 2 100]
  [@@timeout 60]
  [@@fc]

(* Encoding a decoded number is always ok *)
theorem decode_encode_ok (f : Format.t)  (x : Float.t) =
  Result.is_ok (Float.wEncode f (Float.wDecode f x) [@trigger])
  [@@disable Float.wDecode, Float.wDecodeAux, Float.wEncode, Util.pow2, Util.ipow2]
  [@@timeout 3600]
  [@@by [%use Theorems_format_ranges.within_format_range f x] @> auto]
  [@@fc]

(* [saturate] always produces a number within the format range *)
theorem wSaturate_is_within_range (f : Format.t) (x : CER.t) (sat : SaturationMode.t) (rnd : RoundingMode.t) =
  let _, _, _, m_lo, m_hi, _, _ = Format.parameters f in
  let s = (Float.wSaturate m_lo m_hi sat rnd x f.s f.d [@trigger]) in
  cer_is_within_range f s
  [@@timeout 3600]
  [@@disable Format.parameters, Util.ipow2, Util.pow2]
  [@@by auto]
  [@@fc]

(* Encoding after saturation is always ok *)
theorem saturate_encode_ok (f : Format.t) (x : CER.t) (sat : SaturationMode.t) (rnd : RoundingMode.t) =
  let _, _, _, m_lo, m_hi, _, _ = Format.parameters f in
  Result.is_ok (Float.wEncode f (Float.wSaturate m_lo m_hi sat rnd x f.s f.d) [@trigger])
  [@@disable Float.wEncode, Float.wSaturate, Format.parameters]
  [@@by [%use wSaturate_is_within_range f x sat rnd] @> auto]
  [@@fc]

let rounded f rnd x =
  let _, p, b, _, _, _, _ = Format.parameters f in
  Float.wRoundToPrecision p b rnd x

(** [project] never returns an error *)
theorem wProject_ok (f : Format.t) (pi : Projection.t) (x : CER.t) =
  Result.is_ok ((Float.wProject f pi x) [@trigger])
  [@@timeout 30]
  [@@by
    [%use saturate_encode_ok f (rounded f (snd pi) x) (fst pi) (snd pi)]
    @> unroll_nonlin 10 10 1]
  [@@fc]


(** Some helpers *)

theorem pinf_decodes_to_pinf (f : Format.t) (x : Float.t) =
  let open CER in
  Float.is_pinf f x <==> ((Float.wDecode f x = PINF) [@trigger])
  [@@timeout 360]
  [@@by unroll_nonlin 10 10 100]
  [@@fc]

theorem ninf_decodes_to_ninf (f : Format.t) (x : Float.t) =
  let open CER in
  Float.is_ninf f x <==> ((Float.wDecode f x = NINF) [@trigger])
  [@@timeout 360]
  [@@by unroll_nonlin 10 10 100]
  [@@fc]

theorem inf_decodes_to_inf (f : Format.t) (x : Float.t) =
  let open CER in
  ((Float.is_inf f x) [@trigger]) <==> (Float.wDecode f x = NINF || Float.wDecode f x = PINF)
  [@@by
    [%use pinf_decodes_to_pinf f x] @>
    [%use ninf_decodes_to_ninf f x] @>
    unroll 1]
  [@@fc]

theorem nan_decodes_to_nan (f : Format.t) (x : Float.t) =
  let open CER in
  Float.is_nan f x <==> ((Float.wDecode f x = NaN) [@trigger])
  [@@timeout 120]
  [@@by unroll 50]
  [@@fc]

theorem zero_decodes_to_zero (f : Format.t) (x : Float.t) =
  let open CER in
  Float.isZero f x <==> (Float.wDecode f x = R 0.0) [@trigger]
  [@@timeout 60]
  [@@by unroll 25]
  [@@fc]

theorem ipow2_gt_0 (n:int) =
  (Util.ipow2 n) [@trigger] > 0
  [@@timeout 10]
  [@@by auto]
  [@@fc]

theorem decode_0_is_0 (f : Format.t)  =
  let open CER in
  (Float.wDecode f 0) [@trigger] = R 0.0
  [@@timeout 60]
  [@@by enumerate ["f"] @> ground_eval ()]
  [@@fc]

theorem zero_means_is_zero (f : Format.t) (x : Float.t) =
  let open CER in
  x = 0 ==> ((Float.isZero f x) [@trigger])
  [@@timeout 3600]
  [@@disable Util.ipow2, Util.pow2]
  [@@by unroll_nonlin 10 10 1000]
  [@@fc]

(* theorem zero_is_zero_fwd (f : Format.t) (x : Float.t) =
  let open CER in
  x = 0 ==> ((Float.wDecode f x = R 0.0) [@trigger])
  [@@timeout 360]
  [@@by enumerate ["f"] @> auto]

theorem zero_is_zero_bwd (f : Format.t) (x : Float.t) =
  let open CER in
  x = 0 <== ((Float.wDecode f x = R 0.0) [@trigger])
  [@@timeout 1200]
  (* [@@by enumerate ["f"] @> auto] *)
  [@@by auto]


theorem zero_is_zero (f : Format.t) (x : Float.t) =
  let open CER in
  x = 0 <==> ((Float.wDecode f x = R 0.0) [@trigger])
  [@@timeout 60]
  [@@disable Float.wDecode, Float.wDecodeAux]
  [@@by
    [%use zero_is_zero_fwd f x] @>
    [%use zero_is_zero_bwd f x] @>
    auto]
  [@@fc] *)

(* theorem decode_specials (f : Format.t) (x : Float.t) =
  let open CER in
  ((Float.is_pinf f x) <==> (Float.wDecode f x = PINF)) &&
  ((Float.is_ninf f x) <==> (Float.wDecode f x = NINF)) &&
  ((Float.is_nan f x) <==> (Float.wDecode f x = NaN)) &&
  ((Float.is_zero f x) <==> (Float.wDecode f x = R 0.0)) &&
  ((x = 0) <==> (Float.wDecode f x = R 0.0))
  [@@timeout 3600]
  [@@disable Float.wDecode, Float.wDecodeAux, Util.pow2, Util.ipow2, Float.is_pinf, Float.is_ninf, Float.is_nan, Float.is_zero]
  [@@by
    [%use pinf_decodes_to_pinf f x] @>
    [%use ninf_decodes_to_ninf f x] @>
    [%use nan_decodes_to_nan f x] @>
    [%use zero_decodes_to_zero f x] @>
    [%use zero_is_zero f x] @>
    auto] *)

(** 4.7.1 Specification of IEEE Std 754 formats *)

(* (Nothing) *)


(** 4.7.2 Conversion from IEEE Std 754 formats to P3109 *)

(* TODO: proof that the IEEE754 rounding mode in wEncode754 is irrelevant for our [x]s *)

(** [internal_convertFromIEEE754] never returns an error *)
theorem internal_convert_from_ieee754_ok (phi: IEEE754.Format.t) (f : Format.t) (pi : Projection.t) (x : IEEE754.t) =
  Result.is_ok (Float.internal_convertFromIEEE754 phi f pi x)
  [@@disable Float.wProject, Float.wRoundToPrecision, Float.wSaturate, Util.pow2, Util.ipow2, Format.parameters]
  [@@by auto]

(** 4.7.3 Conversion from P3109 to IEEE Std 754 *)

(** 4.8.1 Unary sign operations *)

(** [internal_abs] never returns an error *)
theorem internal_abs_ok (f : Format.t) (x : Float.t) =
  f.s = Signedness.Signed ==>
  Result.is_ok (Float.internal_abs f x)
  [@@timeout 60]
  [@@by
    [%use decode_encode_ok f x]
    @> unroll_nonlin 10 10 1000]

(** [internal_negate] never returns an error *)
theorem internal_negate_ok (f : Format.t) (x : Float.t) =
  f.s = Signedness.Signed ==>
  Result.is_ok (Float.internal_negate f x)
  [@@timeout 120]
  [@@by
    [%use decode_encode_ok f x]
    @> unroll_nonlin 10 10 1000]


(** 4.8.2 Binary sign operations *)

(** [internal_copy_sign] never returns an error *)
theorem internal_copySign_ok (f : Format.t) (x : Float.t) (y : Float.t) =
  Result.is_ok (Float.internal_copySign f x y)
  [@@disable Float.wEncode, Float.wDecodeAux, Util.pow2, Util.ipow2, Format.parameters]
  [@@timeout 120]
  [@@by
    [%use decode_within_range f x] @>
    [%use decode_within_range f y] @>
    [%use wEncode_ok_within_range f (Float.wDecode f x)] @>
    [%use wEncode_ok_within_range f CER.(~- (Float.wDecode f x))] @>
    [%use wEncode_ok_within_range f CER.NaN] @>
    auto]


(** 4.8.3 Binary arithmetic operations *)

(** [internal_add] never returns an error *)
theorem internal_add_ok (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (pi : Projection.t)
  (x : Float.t) (y : Float.t) =
  Result.is_ok (Float.internal_add f_x f_y f_z pi x y)
  [@@disable Specification.Float.wProject, Float.wDecodeAux, Util.pow2, Util.ipow2, Format.parameters]
  [@@timeout 60]
  [@@by auto]

(** [internal_subtract] never returns an error *)
theorem internal_subtract_ok (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (pi : Projection.t)
  (x : Float.t) (y : Float.t) =
  Result.is_ok (Float.internal_subtract f_x f_y f_z pi x y)
  [@@disable Specification.Float.wProject, Float.wDecodeAux, Util.pow2, Util.ipow2, Format.parameters]
  [@@timeout 3600]
  [@@by auto]

(** [internal_multiply] never returns an error *)
theorem internal_multiply_ok (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) (y : Float.t)  =
  Result.is_ok (Float.internal_multiply f_x f_y f_z pi x y)
  [@@disable Specification.Float.wProject, Float.wDecodeAux, Util.pow2, Util.ipow2, Format.parameters]
  [@@timeout 60]
  [@@by auto]

(** [internal_divide] never returns an error *)
theorem internal_divide_ok (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) (y : Float.t)  =
  Result.is_ok (Float.internal_divide f_x f_y f_z pi x y)
  [@@disable Specification.Float.wProject, Specification.Float.wDecode, Float.wDecodeAux, Util.pow2, Util.ipow2, Format.parameters]
  [@@timeout 60]
  [@@by auto]


(** 4.8.4 Unary mathematical operations *)

(** [internal_fma] never returns an error *)
theorem internal_fma_ok (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (f_r : Format.t) (pi : Projection.t)
  (x : Float.t) (y : Float.t) (z : Float.t) =
  Result.is_ok (Float.internal_fma f_x f_y f_z f_r pi x y z)
  [@@disable Float.wProject, Float.wDecode, Float.wRoundToPrecision, Float.wSaturate, Util.pow2, Util.ipow2,
    Format.parameters, Float.internal_fma]
  [@@by auto]


(** 4.8.xx Fused Add Add *)

(** [internal_faa] never returns an error *)
theorem internal_faa_ok (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (f_r : Format.t) (pi : Projection.t)
  (x : Float.t) (y : Float.t) (z : Float.t) =
  Result.is_ok (Float.internal_faa f_x f_y f_z f_r pi x y z)
  [@@disable Float.wProject, Float.wDecode, Float.wDecodeAux, Float.wRoundToPrecision, Float.wSaturate, Util.pow2, Util.ipow2, Format.parameters]
  [@@by auto]

(** 4.8.5 Unary mathematical operations *)

(** [internal_recip] never returns an error *)
theorem internal_recip_ok (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) =
  Result.is_ok (Float.internal_recip f_x f_z pi x)
  [@@timeout 60]
  [@@disable Float.wProject, Float.wDecode, Float.wDecodeAux, Float.wRoundToPrecision, Float.wSaturate, Util.pow2, Util.ipow2, Format.parameters, Sqrt.sqrt]
  [@@by auto]

(** [internal_sqrt] never returns an error *)
theorem internal_sqrt_ok (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) =
  Result.is_ok (Float.internal_sqrt f_x f_z pi x)
  [@@timeout 60]
  [@@disable Float.wProject, Float.wDecode, Float.wDecodeAux, Float.wRoundToPrecision, Float.wSaturate, Util.pow2, Util.ipow2, Format.parameters, Sqrt.sqrt]
  [@@by auto]

(** [internal_rsqrt] never returns an error *)
theorem internal_rsqrt_ok (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) =
  Result.is_ok (Float.internal_rsqrt f_x f_z pi x)
  [@@timeout 3600]
  [@@disable Float.wProject, Float.wDecode, Float.wDecodeAux, Float.wRoundToPrecision, Float.wSaturate, Util.pow2, Util.ipow2, Format.parameters, Sqrt.sqrt]
  [@@by auto]

(** [internal_exp] never returns an error *)
theorem internal_exp_ok (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) =
  Result.is_ok (Float.internal_exp f_x f_z pi x)
  [@@disable Specification.Float.wProject, Specification.Float.wDecode, Float.wDecodeAux, Format.parameters]
  [@@by auto]

(** [internal_exp2] never returns an error *)
theorem internal_exp2_ok (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) =
  Result.is_ok (Float.internal_exp2 f_x f_z pi x)
  [@@disable Float.wProject, Float.wDecode, Float.wDecodeAux, Float.wRoundToPrecision, Float.wSaturate, Exp.exp2, Format.parameters]
  [@@by auto]

(** [internal_log] never returns an error *)
theorem internal_log_ok (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) =
  Result.is_ok (Float.internal_log f_x f_z pi x)
  [@@disable Float.wProject, Float.wDecode, Float.wDecodeAux, Log.log, Log.ln, Format.parameters]
  [@@by auto]

(** [internal_log2] never returns an error *)
theorem internal_log2_ok (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) =
  Result.is_ok (Float.internal_log2 f_x f_z pi x)
  [@@disable Float.wProject, Float.wDecode, Float.wDecodeAux, Log.log2, Log.log, Log.ln, Format.parameters]
  [@@by auto]


(** 4.x.x Hypothenuse *)

(* whypot wants a few helpers *)
theorem h1 (x : real) =
  ((Util.ripow (Real.abs x) 2) [@trigger]) >=. 0.0
  [@@timeout 10]
  [@@by auto]
  [@@fc]

theorem h2 (x : real) (y : real) =
  x >=. 0.0 && y >=. 0.0 ==> x +. y >=. 0.0
  [@@timeout 10]
  [@@by auto]
  [@@fc]

theorem h2 (x : real) (y : real) =
  (((Util.ripow (Real.abs x) 2) +. (Util.ripow (Real.abs y) 2)) [@trigger]) >=. 0.0
  [@@timeout 10]
  [@@by auto]
  [@@fc]

(** [whypot] never returns an error *)
theorem whypot_ok (x : CER.t) (y : CER.t) =
  Result.is_ok ((Float.wHypot x y) [@trigger])
  [@@timeout 60]
  [@@disable Sqrt.sqrt]
  [@@by auto]
  [@@fc]

theorem internal_hypot_ok (f_x : Format.t) (f_y : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) (y : Float.t) =
  Result.is_ok (Float.internal_hypot f_x f_y f_z pi x y)
  [@@timeout 60]
  [@@disable Float.wProject, Float.wDecode, Float.wDecodeAux, Float.wRoundToPrecision, Float.wSaturate, Util.pow2, Util.ipow2, Format.parameters]
  [@@by [%use whypot_ok (Float.wDecode f_x x) (Float.wDecode f_y y)] @> auto]


(** 4.10.1 Minimum and Maximum *)

(** [internal_minimum] never returns an error *)
theorem internal_minimum_ok (f : Format.t) (x : Float.t) (y : Float.t) =
  Result.is_ok (Float.internal_minimum f x y)
  [@@timeout 600]
  [@@disable Float.wDecode, Float.wDecodeAux, Float.wEncode]
  [@@by auto]

(** [internal_maximum] never returns an error *)
theorem internal_maximum_ok (f : Format.t) (x : Float.t) (y : Float.t) =
  Result.is_ok (Float.internal_maximum f x y)
  [@@timeout 600]
  [@@disable Float.wDecode, Float.wDecodeAux, Float.wEncode]
  [@@by auto]

(** [internal_minimum_number] never returns an error *)
theorem internal_minimum_number_ok (f : Format.t) (x : Float.t) (y : Float.t) =
  Result.is_ok (Float.internal_minimumMagnitude f x y)
  [@@disable Float.wDecode, Float.wDecodeAux, Float.wEncode]
  [@@by auto]

(** [internal_maximum_number] never returns an error *)
theorem internal_maximum_number_ok (f : Format.t) (x : Float.t) (y : Float.t) =
  Result.is_ok (Float.internal_maximumNumber f x y)
  [@@disable Float.wDecode, Float.wDecodeAux, Float.wEncode]
  [@@by auto]

(** 4.xx MinimumMagnitude, MaximumMagnitude, and 'Number' variants *)

(** [internal_minimum_magnitude] never returns an error *)
theorem internal_minimum_magnitude_ok (f : Format.t) (x : Float.t) (y : Float.t) =
  Result.is_ok (Float.internal_minimumMagnitude f x y)
  [@@disable Float.wDecode, Float.wDecodeAux, Float.wEncode]
  [@@by auto]

(** [internal_maximum_magnitude] never returns an error *)
theorem internal_maximum_magnitude_ok (f : Format.t) (x : Float.t) (y : Float.t) =
  Result.is_ok (Float.internal_maximumMagnitude f x y)
  [@@disable Float.wDecode, Float.wDecodeAux, Float.wEncode]
  [@@by auto]

(** [internal_minimum_magnitude_number] never returns an error *)
theorem internal_minimum_magnitude_number_ok (f : Format.t) (x : Float.t) (y : Float.t) =
  Result.is_ok (Float.internal_minimumMagnitudeNumber f x y)
  [@@disable Float.wDecode, Float.wDecodeAux, Float.wEncode]
  [@@by auto]

(** [internal_maximum_magnitude] never returns an error *)
theorem internal_maximum_magnitude_number_ok (f : Format.t) (x : Float.t) (y : Float.t) =
  Result.is_ok (Float.internal_maximumMagnitudeNumber f x y)
  [@@disable Float.wDecode, Float.wDecodeAux, Float.wEncode]
  [@@by auto]

(** 4.xx MinimumFinite, MaximumFinite *)

(** [internal_minimum_finite] never returns an error *)
theorem internal_minimum_finite_ok (f : Format.t) (x : Float.t) (y : Float.t) =
  Result.is_ok (Float.internal_minimumFinite f x y)
  [@@disable Float.wDecode, Float.wDecodeAux, Float.wEncode]
  [@@by auto]

(** [internal_maximum_finite] never returns an error *)
theorem internal_maximum_finite_ok (f : Format.t) (x : Float.t) (y : Float.t) =
  Result.is_ok (Float.internal_maximumFinite f x y)
  [@@disable Float.wDecode, Float.wDecodeAux, Float.wEncode]
  [@@by auto]

(** 4.9.3 Clamp *)

(** [internal_clamp] never returns an error *)
theorem internal_clamp_ok (f : Format.t) (x : Float.t) (lo : Float.t) (hi : Float.t) =
  Result.is_ok (Float.internal_clamp f x lo hi)
  [@@timeout 360]
  [@@disable Float.wDecode, Float.wDecodeAux, Float.wEncode]
  [@@by auto]


(** 4.10.2 Comparisons *)

(** [internal_compare_less] never returns an error *)
theorem internal_compare_less_ok (f_x : Format.t) (f_y : Format.t) (x : Float.t) (y : Float.t)  =
  Result.is_ok (Float.internal_compareLess f_x f_y x y)
  [@@disable Float.wDecode, Float.wDecodeAux, Float.wEncode]
  [@@by auto]

theorem internal_compare_less_equal_ok (f_x : Format.t) (f_y : Format.t) (x : Float.t) (y : Float.t)  =
  Result.is_ok (Float.internal_compareLessEqual f_x f_y x y)
  [@@disable Float.wDecode, Float.wDecodeAux, Float.wEncode]
  [@@by auto]

theorem internal_compare_equal_ok (f_x : Format.t) (f_y : Format.t) (x : Float.t) (y : Float.t)  =
  Result.is_ok (Float.internal_compareEqual f_x f_y x y)
  [@@disable Float.wDecode, Float.wDecodeAux, Float.wEncode]
  [@@by auto]

theorem internal_compare_greater_ok (f_x : Format.t) (f_y : Format.t) (x : Float.t) (y : Float.t)  =
  Result.is_ok (Float.internal_compareGreater f_x f_y x y)
  [@@disable Float.wDecode, Float.wDecodeAux, Float.wEncode]
  [@@by auto]


theorem internal_compare_greater_equal_ok (f_x : Format.t) (f_y : Format.t) (x : Float.t) (y : Float.t)  =
  Result.is_ok (Float.internal_compareGreaterEqual f_x f_y x y)
  [@@disable Float.wDecode, Float.wDecodeAux, Float.wEncode]
  [@@by auto]


(** 4.10.3 Predicates and classification *)

theorem internal_is_zero_ok (f : Format.t) (x : Float.t) =
  Result.is_ok (Float.internal_isZero f x)
  [@@disable Float.wDecode, Float.wDecodeAux, Float.wEncode]
  [@@by auto]

theorem internal_is_one_ok (f : Format.t) (x : Float.t) =
  Result.is_ok (Float.internal_isOne f x)
  [@@disable Float.wDecode, Float.wDecodeAux, Float.wEncode]
  [@@by auto]

theorem internal_is_sign_minus_ok (f : Format.t) (x : Float.t) =
  Result.is_ok (Float.internal_isSignMinus f x)
  [@@disable Float.wDecode, Float.wDecodeAux, Float.wEncode]
  [@@by auto]


(** 4.10.4 Classifier operation *)

theorem predicate_coverage (f : Format.t) (x : Float.t) =
  Float.isNaN f x ||
  Float.isInfinite f x ||
  Float.isZero f x ||
  Float.isNormal f x ||
  Float.isSubnormal f x
  [@@timeout 3600]
  [@@by unroll_nonlin 600 10 250]
  [@@fc]

(** All [Float.t] are classified *)
theorem internal_class_ok (f : Format.t) (x : Float.t) =
  Result.is_ok (Float.internal_class f x)
  [@@disable Float.internal_class]
  [@@by auto]

(** 4.10.5 Total order predicate *)

(** 4.10.6 Comparison predicates *)

(* (Nothing) *)

(** 4.5 Format-level operations *)

theorem maxFiniteOf_ok (f : Format.t) =
  Result.is_ok (Float.maxFiniteOf f)
  [@@disable Format.parameters, Float.wEncode]
  [@@by auto]

theorem minFiniteOf_ok (f : Format.t) =
  Result.is_ok (Float.minFiniteOf f) [@trigger]
  [@@disable Format.parameters, Float.wEncode]
  [@@by auto]
  [@@fc]

(* It's always ok to get minPositiveOf *)
theorem minPositiveOf_ok (f : Format.t) =
  let open Float in
  Result.is_ok ((minPositiveOf f) [@trigger])
  [@@disable Util.pow2, Util.ipow2, Format.parameters]
  [@@by auto]
  [@@fc]

(* The result of minPositiveOf is never negative, zero, or NaN *)
theorem minPositiveOf_positive (f : Format.t) =
  let open Float in
  match minPositiveOf f with
  | Ok r -> not (isSignMinus f r) && not (isZero f r) && not (is_nan f r)
  | Error _ -> false
  [@@by enumerate ["f"] @> ground_eval ()]

(* It's always ok to get minNormalOf *)
theorem minNormalOf_ok (f : Format.t) =
  let open Float in
  Result.is_ok ((minNormalOf f) [@trigger])
  [@@disable Util.pow2, Util.ipow2, Format.parameters]
  [@@by auto]
  [@@fc]

(* The result of minNormalOf is normal, with some exceptions *)
theorem minNormalOf_normal (f : Format.t) =
  let open Float in
  let k, p, _, _, _, s, d = Format.parameters f in
  match k, p, s, d with
  | k, p, Signed, _ when k = p -> true (* Signed k = p is not a valid format *)
  | 2, 1, Signed, Extended -> minNormalOf f = Ok (nan f)
  | 2, 2, Unsigned, Extended -> minNormalOf f = Ok (nan f)
  | _ ->
    (match minNormalOf f with
      | Ok r -> isNormal f r
      | Error _ -> true)
  [@@timeout 60]
  [@@by enumerate ["f"] @> ground_eval ()]

(** [internal_expm1] never returns an error *)
theorem internal_expMinusOne_ok (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) =
  Result.is_ok (Float.internal_expMinusOne f_x f_z pi x)
  [@@disable Specification.Float.wProject, Specification.Float.wDecode, Float.wDecodeAux, Format.parameters]
  [@@by auto]

(** [internal_log1p] never returns an error *)
theorem internal_logOnePlus_ok (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) =
  Result.is_ok (Float.internal_logOnePlus f_x f_z pi x)
  [@@disable Float.wProject, Float.wDecode, Float.wDecodeAux, Log.log, Log.ln, Format.parameters]
  [@@by auto]

(** [internal_sin] never returns an error *)
theorem internal_sin_ok (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) =
  Result.is_ok (Float.internal_sin f_x f_z pi x)
  [@@disable Specification.Float.wProject, Specification.Float.wDecode, Float.wDecodeAux, Format.parameters]
  [@@by auto]

(** [internal_cos] never returns an error *)
theorem internal_cos_ok (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) =
  Result.is_ok (Float.internal_cos f_x f_z pi x)
  [@@disable Specification.Float.wProject, Specification.Float.wDecode, Float.wDecodeAux, Format.parameters]
  [@@by auto]

(** [internal_tan] never returns an error *)
theorem internal_tan_ok (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) =
  Result.is_ok (Float.internal_tan f_x f_z pi x)
  [@@disable Specification.Float.wProject, Specification.Float.wDecode, Float.wDecodeAux, Format.parameters, Trigonometric.sin, Trigonometric.cos]
  [@@by auto]

(** [internal_sinh] never returns an error *)
theorem internal_sinh_ok (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) =
  Result.is_ok (Float.internal_sinh f_x f_z pi x)
  [@@disable Specification.Float.wProject, Specification.Float.wDecode, Float.wDecodeAux, Format.parameters]
  [@@by auto]

(** [internal_cosh] never returns an error *)
theorem internal_cosh_ok (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) =
  Result.is_ok (Float.internal_cosh f_x f_z pi x)
  [@@disable Specification.Float.wProject, Specification.Float.wDecode, Float.wDecodeAux, Format.parameters]
  [@@by auto]

(** [internal_tanh] never returns an error *)
theorem internal_tanh_ok (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) =
  Result.is_ok (Float.internal_tanh f_x f_z pi x)
  [@@disable Specification.Float.wProject, Specification.Float.wDecode, Float.wDecodeAux, Format.parameters]
  [@@by auto]

(** [internal_arcsin] never returns an error *)
theorem internal_arcsin_ok (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) =
  Result.is_ok (Float.internal_arcsin f_x f_z pi x)
  [@@disable Specification.Float.wProject, Specification.Float.wDecode, Float.wDecodeAux, Format.parameters]
  [@@by auto]

(** [internal_arccos] never returns an error *)
theorem internal_arccos_ok (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) =
  Result.is_ok (Float.internal_arccos f_x f_z pi x)
  [@@disable Specification.Float.wProject, Specification.Float.wDecode, Float.wDecodeAux, Format.parameters]
  [@@by auto]

(** [internal_arctan] never returns an error *)
theorem internal_arctan_ok (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) =
  Result.is_ok (Float.internal_arctan f_x f_z pi x)
  [@@disable Specification.Float.wProject, Specification.Float.wDecode, Float.wDecodeAux, Format.parameters, Pi.pi]
  [@@by auto]

(** [internal_arcsinh] never returns an error *)
theorem internal_arcsinh_ok (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) =
  Result.is_ok (Float.internal_arcsinh f_x f_z pi x)
  [@@disable Specification.Float.wProject, Specification.Float.wDecode, Float.wDecodeAux, Format.parameters]
  [@@by auto]

(** [internal_arccosh] never returns an error *)
theorem internal_arccosh_ok (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) =
  Result.is_ok (Float.internal_arccosh f_x f_z pi x)
  [@@disable Specification.Float.wProject, Specification.Float.wDecode, Float.wDecodeAux, Format.parameters]
  [@@by auto]

(** [internal_arctanh] never returns an error *)
theorem internal_arctanh_ok (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) =
  Result.is_ok (Float.internal_arctanh f_x f_z pi x)
  [@@disable Specification.Float.wProject, Specification.Float.wDecode, Float.wDecodeAux, Format.parameters]
  [@@by auto]

(** [internal_softplus] never returns an error *)
theorem internal_softplus_ok (f_x : Format.t) (f_z : Format.t) (pi : Projection.t) (x : Float.t) =
  Result.is_ok (Float.internal_softplus f_x f_z pi x)
  [@@disable Specification.Float.wProject, Specification.Float.wDecode, Float.wDecodeAux, Format.parameters, Log.log, Log.ln, Exp.exp]
  [@@by auto]

(** [internal_softmax] never returns an error *)
theorem map_project_ok f pi x =
  Result.is_ok (extract_error ((Float.map_project f pi x) [@trigger]))
  [@@disable Float.wProject]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]
  [@@fc]

theorem internal_softmax_ok (f_x : Format.t) (f_r : Format.t) (pi : Projection.t) (xs : Float.t list) =
  Result.is_ok (Float.internal_softmax f_x f_r pi xs)
  [@@disable Specification.Float.wProject, Specification.Float.wDecode, Float.wDecodeAux, Format.parameters, Log.log, Log.ln, Exp.exp, Float.map_decode, Float.map_project]
  [@@timeout 3600]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]

(** [internal_nextGreaterThan] never returns an error *)
theorem internal_nextGreaterThan_ok (f : Format.t) (x : Float.t) =
  Result.is_ok (Float.internal_nextGreaterThan f x)
  [@@disable Format.parameters, Float.minFiniteOf]
  [@@by auto]

(** [internal_nextLessThan] never returns an error *)
theorem internal_nextLessThan_ok (f : Format.t) (x : Float.t) =
  Result.is_ok (Float.internal_nextLessThan f x)
  [@@disable Format.parameters, Float.minFiniteOf]
  [@@by auto]

(* Some extras *)

theorem wExp_is_positive (x : CER.t) =
  let open CER in
  match Float.wExp x with
  | Ok CER.NaN -> true
  | Ok CER.PINF -> true
  | Ok CER.NINF -> false
  | Ok (R x) -> x >=. 0.0
  | Error _ -> false
  [@@timeout 3600]
  [@@disable Format.parameters, Util.pow2, Util.ipow2, Util.ripow, Exp.exp]
  [@@by auto]

theorem wRoundToPrecision_preserves_positivity (p : int) (b : int) (rnd : RoundingMode.t) (x : CER.t) =
  let open CER.Infix in
  x >= CER.zero ==> (Float.wRoundToPrecision p b rnd x) [@trigger] >= CER.zero
  [@@disable Util.pow2, Util.ipow2, Util.floor_log2_abs, Util.floor, Util.ifloor]
  [@@by auto]
  [@@fc]

theorem wSaturate_preserves_positivity (m_lo : real) (m_hi : real) (sat : SaturationMode.t) (rnd : RoundingMode.t) (x : CER.t) (s : Signedness.t) (d : Domain.t) =
  let open CER.Infix in
  m_lo <=. 0.0 && m_hi >. 0.0 ==>
  x >= CER.zero ==> (Float.wSaturate m_lo m_hi sat rnd x s d) [@trigger] >= CER.zero
  [@@disable Float.wDecode, Float.wDecodeAux, Format.parameters, Util.pow2, Util.ipow2, Util.floor_log2_abs, Util.floor, Util.ifloor]
  [@@by auto]
  [@@fc]
