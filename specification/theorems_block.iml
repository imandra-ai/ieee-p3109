[@@@import Util, "dune:math"]
[@@@import Log, "dune:math"]
[@@@import Exp, "dune:math"]
[@@@import ErrorPropagation, "dune:basic"]
[@@@import Specification, "specification.iml"]
[@@@import Theorems, "theorems.iml"]
[@@@import Theorems_pow2, "theorems_pow2.iml"]
[@@@import Theorems_format_ranges, "theorems_format_ranges.iml"]
[@@@import Theorems_IEEE754, "theorems_ieee754.iml"]

open Specification
open Float
open ErrorPropagation
open Theorems

let unroll_nonlin qt nqt steps = Tactic.unroll ~smt:"z3-full-nonlinear" ~query_timeout:qt ~no_asm_query_timeout:nqt steps

theorem list_map_preserves_length (f : 'a -> 'b) (xs : 'a list) =
  List.length ((List.map f xs) [@trigger]) = List.length xs
  [@@by auto]
  [@@fc]

theorem list_map2_preserves_length (f : 'a -> 'b -> 'c) (xs : 'a list) (ys : 'b list) =
  List.length xs = List.length ys ==>
  match (List.map2 f xs ys) [@trigger] with
  | Ok r -> List.length r = List.length xs
  | _ -> false
  [@@by auto]
  [@@fc]

theorem list_tl_shorter (xs : 'a list) =
  xs <> [] ==> List.length xs > List.length (List.tl xs) [@trigger]
  [@@by auto]
  [@@fc]

theorem listcons xs =
  (List.length xs) [@trigger] > 0 ==> (match xs with | _ :: _ -> true | _ -> false)
  [@@fc]

theorem cons_longer_than_1 (xs : 'a list) =
  match xs with
  | _ :: _ -> ((List.length xs) [@trigger]) >= 1
  | _ -> true
  [@@by auto]
  [@@fc]

theorem match_list_lens (xs : 'a list) (ys : 'a list) =
  match xs, ys with
  | [p1], [a1] -> ((List.length xs = List.length ys) [@trigger])
  | [p1; p2], [a1; a2] -> ((List.length xs = List.length ys) [@trigger])
  | [p1; p2; p3], [a1; a2; a3] -> ((List.length xs = List.length ys) [@trigger])
  | _ -> true
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]
  [@@fc]

theorem map2_ok (f : 'a -> 'b -> 'c) (xs : 'a list) (ys : 'b list) =
  List.length xs = List.length ys ==> Result.is_ok ((List.map2 f xs ys) [@trigger])
  [@@by auto]
  [@@fc]

(** [wAdd] never returns an error *)
theorem wAdd_ok (x : CER.t) (y : CER.t) =
  Result.is_ok ((Float.wAdd x y) [@trigger])
  [@@by auto]
  [@@fc]

(** [wMultiply] never returns an error *)
theorem wMultiply_ok (x : CER.t) (y : CER.t) =
  Result.is_ok ((Float.wMultiply x y) [@trigger])
  [@@by auto]
  [@@fc]

(** [wDivide] never returns an error *)
theorem wDivide_ok (x : CER.t) (y : CER.t) =
  Result.is_ok ((Float.wDivide x y) [@trigger])
  [@@by auto]
  [@@fc]

(** [wMaximumFinite] never returns an error *)
theorem wMaximumFinite_ok (x : CER.t) (y : CER.t) =
  Result.is_ok ((Float.wMaximumFinite x y) [@trigger])
  [@@by auto]
  [@@fc]

(** [wCopySign] never returns an error *)
theorem wCopySign_ok (x : CER.t) (y : CER.t) =
  Result.is_ok ((Float.wCopySign x y) [@trigger])
  [@@by auto]
  [@@fc]

(* theorem reduce_wAdd_ok (x : CER.t list) =
  List.length x >= 1 ==>
  Result.is_ok ((Float.reduce_wAdd x) [@trigger])
  [@@disable Float.wAdd]
  [@@by auto]
  [@@fc] *)

theorem reduce_trivial_ok (x: 'a list) =
  List.length x >= 2 ==> Result.is_ok ((reduce (fun x y -> Ok CER.zero) x))
  [@@by auto]

theorem reduce_wAdd_ok (x : CER.t list) =
  List.length x >= 2 ==> Result.is_ok ((reduce Float.wAdd x) [@trigger])
  [@@by auto]
  [@@fc]

theorem reduce_wMaximumFinite_ok (x : CER.t list) =
  List.length x >= 2 ==> Result.is_ok ((Float.reduce Float.wMaximumFinite x) [@trigger])
  [@@by auto]
  [@@fc]

(** 6.0.1 DecodeBlock *)

(* theorem map_wMultiply_ok (f_s : Format.t) (f_x : Format.t) (s, x : Float.t * Float.t list) =
  Result.is_ok ((extract_error ((Float.map_wMultiply f_s f_x s x) [@trigger])))
  [@@disable Float.wDecode, Float.wMultiply, List.map]
  [@@by auto]
  [@@fc] *)

theorem wMultiplyLambda_ok (x : CER.t) (y : CER.t) =
  Result.is_ok ((fun z -> wMultiply x z) y)
  [@@by auto]

theorem map_wMultiply_ok (f_s : Format.t) (f_x : Format.t) (s : Float.t) (x :  Float.t list) =
  Result.is_ok ((extract_error ((List.map (fun x_i -> wMultiply (wDecode f_s s) (wDecode f_x x_i)) x))))
  [@@disable Float.wDecode, Float.wMultiply, List.map]
  [@@by
    [%cases
      (Result.is_ok
        (([? at (List.map (_ : Float.t -> (CER.t, string) Result.t) x) index(1)])
          s))]
    @>
      (*
      [%use ErrorPropagation.extract_error_empty ([] : (Float.t, string) Result.t list)] @> simplify ();
      [%use wMultiply_ok
        [? at (wMultiply (_) (_)) index(1)]
        [? at (wMultiply (_) (_)) index(2)] ] @>
      (* simplify () *)
      ] *)
    skip
  ]
  (* [@@fc] *)

(* theorem map_wMultiply_preserves_length (f_s : Format.t) (f_x : Format.t) (s, x : Float.t * Float.t list) =
  List.length ((Float.map_wMultiply f_s f_x s x) [@trigger]) = List.length x
  [@@disable Float.wDecode, Float.wMultiply, List.map]
  [@@by auto]
  [@@fc] *)

(*
theorem wBlockDecode_ok (b : int) (f_s : Format.t) (f_x : Format.t) (s : Float.t) (x : Float.t list) =
  b = List.length x && b >= 1 ==>
  Result.is_ok ((Float.wBlockDecode b f_s f_x (s, x)) [@trigger])
  [@@timeout 10]
  [@@disable Float.wDecode, Float.wMultiply, List.map]
  [@@by
    (* [%use map_wMultiply_ok f_s f_x (s, x)] @> *)
    [%expand "Specification.Float.wBlockDecode"] @>
    simplify ()]
  [@@fc]

theorem wBlockDecode_preserves_length (b : int)  (f_s : Format.t) (f_x : Format.t) (s : Float.t) (x : Float.t list) =
  b = List.length x && b >= 1 ==>
  match (Float.wBlockDecode b f_s f_x (s, x)) [@trigger] with
  | Ok r -> List.length r = b
  | _ -> false
  [@@timeout 10]
  [@@disable Float.wDecode, Float.wMultiply, Float.map_wMultiply, List.map]
  [@@by
    [%use map_wMultiply_ok f_s f_x (s, x)] @>
    induct ~do_not:["gen"; "fert"; "delim"] ()
  ]
  [@@fc]

(** 6.0.2 EncodeBlock *)

theorem wBlockProject_map_ok (cs : CER.t) (x : CER.t list) =
  Result.is_ok (extract_error (List.map
        (fun x_i ->
          match cs with
          | CER.NaN
          | _ when x_i = CER.NaN -> Ok CER.NaN
          | R 0.0 -> Ok (R 0.0)
          | (PINF | NINF) -> Ok (R 1.0)
          | _ -> wDivide x_i cs)
        x))
  [@@disable Float.wDecode, Float.wDivide, List.map]
  [@@by auto]

theorem map_project_ok f pi x =
  Result.is_ok (extract_error ((Float.map_project f pi x) [@trigger]))
  [@@disable Float.wProject]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]
  [@@fc]

theorem wBlockProject_map_cz_ok cs x =
  Result.is_ok (extract_error ((wBlockProject_map_cz cs x) [@trigger]))
  [@@by auto]
  [@@fc]

theorem wBlockProject_ok (b : int) (f_s : Format.t) (f_z : Format.t) (pi_z : Projection.t) (s : t) (x : CER.t list) =
  b = List.length x ==>
  Result.is_ok ((Float.wBlockProject b f_s f_z pi_z (s, x)) [@trigger])
  [@@timeout 60]
  [@@disable Float.wDecode, Float.wDivide, Float.wProject, List.map, Float.map_project]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]
  [@@fc]

(** 6.0.3 ConvertFromBlock *)

theorem convertFromBlock_ok
  (b : int)
  (f_s : Format.t) (f_x : Format.t) (f_z : Format.t)
  (pi_s : Projection.t) (pi_z : Projection.t)
  (s, x : t * t list) =
  b = List.length x && b >= 1 ==>
  Result.is_ok (Float.convertFromBlock b f_s f_x f_z pi_s pi_z (s, x))
  [@@timeout 10]
  [@@disable Float.wDecode, Float.map_project, Float.wBlockDecode]
  [@@by auto]

(** 6.0.4 ConvertToBlock *)

theorem convertToBlock_ok
  (b : int)
  (f_s : Format.t) (f_x : Format.t) (f_z : Format.t) (pi_z : Projection.t)
  (x, s : t list * t) =
  b = List.length x ==>
  Result.is_ok (Float.convertToBlock b f_s f_x f_z pi_z (x, s))
  [@@disable Float.wDecode, Float.map_project, Float.map_decode, Float.wBlockProject]
  [@@by auto]

(** 6.0.5 ConvertToBlockMaxAbsFinite *)

theorem map_wabs_ok (xs : CER.t list) =
  Result.is_ok ((extract_error (map_wabs xs)) [@trigger])
  [@@disable Float.wDecode, Float.wAbs, List.map]
  [@@by auto]
  [@@fc]

theorem reduce_wMaximumFinite_ok (x : CER.t list) =
  List.length x >= 1 ==>
  Result.is_ok ((Float.reduce_wMaximumFinite x) [@trigger])
  [@@by auto]
  [@@fc]

theorem map_convert_maf_ok s' (x : CER.t list) =
  Result.is_ok (extract_error ((Float.map_convert_maf s' x) [@trigger]))
  [@@disable Float.wDivide, List.map]
  [@@by auto]
  [@@fc]

theorem convert_to_block_max_abs_finite_ok
  (b : int)
  (f_s : Format.t) (f_x : Format.t) (f_z : Format.t)
  (pi_s : Projection.t) (pi_z : Projection.t)
  (x : t list) =
  b >= 1 && b = List.length x ==>
  Result.is_ok (convertToBlockMaxAbsFinite b f_s f_x f_z pi_s pi_z x)
  [@@disable Float.reduce, Float.wMaximumFinite, Float.wDivide, Float.wProject, Float.wDecode,
    Float.map_wabs, Float.map_decode, Float.map_project, Float.reduce_wMaximumFinite,
    Float.map_convert_maf, List.length, Format.parameters]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]

(** 6.0.3 DotBlock *)

theorem reduce_wAdd_confl_ok (x : CER.t list) =
  List.length x >= 1 ==> Result.is_ok ((reduce_wAdd x) [@trigger])
  [@@by auto]
  [@@fc]

theorem reduce_wMaximumFinite_extract_ok (xs : (CER.t, 'e) Result.t list) =
  List.length xs >= 2 ==>
  let r = (
    let* ys = extract_error xs in
    Float.reduce Float.wMaximumFinite ys) in
  Result.is_ok (extract_error xs) [@trigger] ==> Result.is_ok r
  [@@disable Float.reduce, Float.wMaximumFinite, List.map]
  [@@by auto]
  [@@fc]

theorem map2_wMultiply_elems_ok cx cy =
  List.length cx = List.length cy ==>
  match (Float.map2_wMultiply cx cy) [@trigger] with
  | Ok q -> Result.is_ok (extract_error q)
  | _ -> false
  [@@disable Float.wMultiply, List.map2]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]
  [@@fc]

theorem map2_wMultiply_preserves_length cx cy =
  List.length cx = List.length cy ==>
  match (Float.map2_wMultiply cx cy) [@trigger] with
  | Ok q -> (
    match extract_error q with
    | Ok r -> List.length r = List.length cx
    | _ -> false)
  | _ -> false
  [@@disable Float.wMultiply, List.map2]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]
  [@@fc]

theorem block_dot_product_ok
  (b : int)
  (f_sx : Format.t) (f_x : Format.t)
  (f_sy : Format.t) (f_y : Format.t)
  (f_z : Format.t)
  (pi_z : Projection.t)
  (s_x, x : Float.t * Float.t list)
  (s_y, y : Float.t * Float.t list) =
  b = List.length x && b = List.length y && b >= 1 ==>
  Result.is_ok (Float.blockDotProduct b f_sx f_x f_sy f_y f_z pi_z (s_x, x) (s_y, y))
  [@@disable Float.wAdd, Float.reduce_wAdd, Float.map2_wMultiply, Float.wBlockDecode, Float.wProject, Format.parameters]
  [@@by auto]

let rec equal_block_sizes (b : int) (args : block_op_argument list) : bool =
  match args with
  | [] -> true
  | a_i :: args -> b = List.length a_i.x && equal_block_sizes b args

let rec equal_list_lengths (b : int) (xs : 'a list list) : bool =
  match xs with
  | [] -> true
  | x :: xs -> List.length x = b && equal_list_lengths b xs

let decode_lb b p a = wBlockDecode b p.f_s p.f_x (a.s, a.x)

theorem decode_lb_ok b p a =
  b >= 1 && List.length a.x = b ==>
  Result.is_ok ((decode_lb b p a) [@trigger])
  [@@disable Float.wBlockDecode]
  [@@by auto]
  [@@fc]

theorem decode_lb_ok b p a =
  b >= 1 && List.length a.x = b ==>
  Result.is_ok ((decode_lb b) p a)
  [@@disable Float.wBlockDecode, List.exists, List.for_all, List.length, List.map2]
  [@@by auto]
  (* [@@fc] *)

theorem block_op_map2_wBlockDecode_ok b params args =
  b >= 1 &&
  List.length params = List.length args &&
  equal_block_sizes b args
  ==>
  Result.is_ok ((block_op_map2_wBlockDecode b params args) [@trigger])
  [@@disable Float.wBlockDecode, List.map2, List.exists, List.for_all, List.length]
  [@@by simplify ()]
  [@@fc]

theorem block_op_map2_wBlockDecode_elems_ok b params args =
  b >= 1 &&
  List.length params = List.length args &&
  equal_block_sizes b args
  ==>
  match (block_op_map2_wBlockDecode b params args) [@trigger] with
  | Ok q -> Result.is_ok (extract_error q)
  | _ -> false
  [@@disable Float.wBlockDecode]
  (* This one fails non-determinstically, apparently because of different
    ordering of constraints from the simplifier. *)
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]
  [@@fc]

theorem block_op_map2_wBlockDecode_preserves_length b params args =
  List.length params = List.length args
  ==>
  match (block_op_map2_wBlockDecode b params args) [@trigger] with
  | Ok r -> (
    match extract_error r with
    | Ok decoded -> List.length decoded = List.length args
    | Error _ -> true)
  | Error _ -> true
  [@@disable Float.wBlockDecode]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]
  [@@fc]

theorem block_op_map2_wBlockDecode_preserves_block_size b params args =
  List.length params = List.length args
  ==>
  match (block_op_map2_wBlockDecode b params args) [@trigger] with
  | Ok r -> (
    match extract_error r with
    | Ok decoded -> List.for_all (fun d_i -> List.length d_i = b) decoded
    | Error _ -> true)
  | Error _ -> true
  [@@disable Float.wBlockDecode]
  [@@timeout 120]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]
  [@@fc]

theorem block_op_map2_wBlockDecode_preserves_elems_length b params args =
  List.length params = List.length args
  ==>
  match (block_op_map2_wBlockDecode b params args) [@trigger] with
  | Ok r -> (
    match extract_error r with
    | Ok decoded -> equal_list_lengths b decoded
    | Error _ -> true)
  | Error _ -> true
  [@@disable Float.wBlockDecode]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]
  [@@fc]

theorem nth_r_ok (n : int) (xs : 'a list) =
  0 <= n && n < List.length xs ==> Result.is_ok ((Float.nth_r n xs) [@trigger])
  [@@by auto]
  [@@fc]

theorem block_op_map2_wop_unary_ok wop x1 =
  Result.is_ok ((Float.block_op_map2_wop_unary wop x1) [@trigger])
  [@@by auto]

theorem block_op_map2_wop_binary_ok wop x1 x2 =
  List.length x1 = List.length x2 ==>
  Result.is_ok ((Float.block_op_map2_wop_binary wop x1 x2) [@trigger])
  [@@by auto]

theorem block_op_map2_wop_ternary_ok wop x1 x2 x3 =
  List.length x1 = List.length x2 &&
  List.length x2 = List.length x3 ==>
  Result.is_ok ((Float.block_op_map2_wop_ternary wop x1 x2 x3) [@trigger])
  [@@by auto]

theorem block_op_map2_abs_elems_ok x1 =
  match (Float.block_op_map2_wop_unary Float.wAbs x1) [@trigger] with
  | Ok r -> Result.is_ok (extract_error r)
  | Error _ -> false
  [@@disable Float.wAbs]
  [@@by auto]
  [@@fc]

theorem block_op_map2_negate_elems_ok x1 =
  match (Float.block_op_map2_wop_unary Float.wNegate x1) [@trigger] with
  | Ok r -> Result.is_ok (extract_error r)
  | Error _ -> false
  [@@disable Float.wNegate]
  [@@by auto]
  [@@fc]

theorem block_op_map2_exp_elems_ok x1 =
  match (Float.block_op_map2_wop_unary Float.wExp x1) [@trigger] with
  | Ok r -> Result.is_ok (extract_error r)
  | Error _ -> false
  [@@disable Float.wExp]
  [@@by auto]
  [@@fc]

theorem block_op_map2_sqrt_elems_ok x1 =
  match (Float.block_op_map2_wop_unary Float.wSqrt x1) [@trigger] with
  | Ok r -> Result.is_ok (extract_error r)
  | Error _ -> false
  [@@disable Float.wSqrt]
  [@@by auto]
  [@@fc]

theorem block_op_map2_rsqrt_elems_ok x1 =
  match (Float.block_op_map2_wop_unary Float.wRSqrt x1) [@trigger] with
  | Ok r -> Result.is_ok (extract_error r)
  | Error _ -> false
  [@@disable Float.wRSqrt]
  [@@by auto]
  [@@fc]

theorem block_op_map2_exp2_elems_ok x1 =
  match (Float.block_op_map2_wop_unary Float.wExp2 x1) [@trigger] with
  | Ok r -> Result.is_ok (extract_error r)
  | Error _ -> false
  [@@disable Float.wExp2]
  [@@by auto]
  [@@fc]

theorem block_op_map2_log2_elems_ok x1 =
  match (Float.block_op_map2_wop_unary Float.wLog2 x1) [@trigger] with
  | Ok r -> Result.is_ok (extract_error r)
  | Error _ -> false
  [@@disable Float.wLog2]
  [@@by auto]
  [@@fc]

theorem block_op_map2_log_elems_ok x1 =
  match (Float.block_op_map2_wop_unary Float.wLog2 x1) [@trigger] with
  | Ok r -> Result.is_ok (extract_error r)
  | Error _ -> false
  [@@disable Float.wLog2]
  [@@by auto]
  [@@fc]

theorem block_op_map2_recip_elems_ok x1 =
  match (Float.block_op_map2_wop_unary Float.wRecip x1) [@trigger] with
  | Ok r -> Result.is_ok (extract_error r)
  | Error _ -> false
  [@@disable Float.wRecip]
  [@@by auto]
  [@@fc]

theorem block_op_map2_CopySign_elems_ok x1 x2 =
  List.length x1 = List.length x2 ==>
  match (Float.block_op_map2_wop_binary Float.wCopySign x1 x2) [@trigger] with
  | Ok r -> Result.is_ok (extract_error r)
  | Error _ -> false
  [@@disable Float.wCopySign]
  [@@by auto]
  [@@fc]

theorem block_op_map2_add_elems_ok x1 x2 =
  List.length x1 = List.length x2 ==>
  match (Float.block_op_map2_wop_binary Float.wAdd x1 x2) [@trigger] with
  | Ok r -> Result.is_ok (extract_error r)
  | Error _ -> false
  [@@disable Float.wAdd]
  [@@by auto]
  [@@fc]

theorem block_op_map2_subtract_elems_ok x1 x2 =
  List.length x1 = List.length x2 ==>
  match (Float.block_op_map2_wop_binary Float.wSubtract x1 x2) [@trigger] with
  | Ok r -> Result.is_ok (extract_error r)
  | Error _ -> false
  [@@disable Float.wSubtract]
  [@@by auto]
  [@@fc]

theorem block_op_map2_multiply_elems_ok x1 x2 =
  List.length x1 = List.length x2 ==>
  match (Float.block_op_map2_wop_binary Float.wMultiply x1 x2) [@trigger] with
  | Ok r -> Result.is_ok (extract_error r)
  | Error _ -> false
  [@@disable Float.wMultiply]
  [@@by auto]
  [@@fc]

theorem block_op_map2_divide_elems_ok x1 x2 =
  List.length x1 = List.length x2 ==>
  match (Float.block_op_map2_wop_binary Float.wDivide x1 x2) [@trigger] with
  | Ok r -> Result.is_ok (extract_error r)
  | Error _ -> false
  [@@disable Float.wDivide]
  [@@by auto]
  [@@fc]

theorem block_op_map2_hypot_elems_ok x1 x2 =
  List.length x1 = List.length x2 ==>
  match (Float.block_op_map2_wop_binary Float.wHypot x1 x2) [@trigger] with
  | Ok r -> Result.is_ok (extract_error r)
  | Error _ -> false
  [@@disable Float.wHypot]
  [@@by auto]
  [@@fc]

theorem block_op_map2_minimum_elems_ok x1 x2 =
  List.length x1 = List.length x2 ==>
  match (Float.block_op_map2_wop_binary Float.wMinimum x1 x2) [@trigger] with
  | Ok r -> Result.is_ok (extract_error r)
  | Error _ -> false
  [@@disable Float.wMinimum]
  [@@by auto]
  [@@fc]

theorem block_op_map2_minimum_magnitude_elems_ok x1 x2 =
  List.length x1 = List.length x2 ==>
  match (Float.block_op_map2_wop_binary Float.wMinimumMagnitude x1 x2) [@trigger] with
  | Ok r -> Result.is_ok (extract_error r)
  | Error _ -> false
  [@@disable Float.wMinimumMagnitude]
  [@@by auto]
  [@@fc]

theorem block_op_map2_minimum_magnitude_number_elems_ok x1 x2 =
  List.length x1 = List.length x2 ==>
  match (Float.block_op_map2_wop_binary Float.wMinimumMagnitudeNumber x1 x2) [@trigger] with
  | Ok r -> Result.is_ok (extract_error r)
  | Error _ -> false
  [@@disable Float.wMinimumMagnitudeNumber]
  [@@by auto]
  [@@fc]

theorem block_op_map2_minimum_number_elems_ok x1 x2 =
  List.length x1 = List.length x2 ==>
  match (Float.block_op_map2_wop_binary Float.wMinimumNumber x1 x2) [@trigger] with
  | Ok r -> Result.is_ok (extract_error r)
  | Error _ -> false
  [@@disable Float.wMinimumNumber]
  [@@by auto]
  [@@fc]

theorem block_op_map2_maximum_elems_ok x1 x2 =
  List.length x1 = List.length x2 ==>
  match (Float.block_op_map2_wop_binary Float.wMaximum x1 x2) [@trigger] with
  | Ok r -> Result.is_ok (extract_error r)
  | Error _ -> false
  [@@disable Float.wMaximum]
  [@@by auto]
  [@@fc]

theorem block_op_map2_maximum_magnitude_elems_ok x1 x2 =
  List.length x1 = List.length x2 ==>
  match (Float.block_op_map2_wop_binary Float.wMaximumMagnitude x1 x2) [@trigger] with
  | Ok r -> Result.is_ok (extract_error r)
  | Error _ -> false
  [@@disable Float.wMaximumMagnitude]
  [@@by auto]
  [@@fc]

theorem block_op_map2_maximum_magnitude_number_elems_ok x1 x2 =
  List.length x1 = List.length x2 ==>
  match (Float.block_op_map2_wop_binary Float.wMaximumMagnitudeNumber x1 x2) [@trigger] with
  | Ok r -> Result.is_ok (extract_error r)
  | Error _ -> false
  [@@disable Float.wMaximumMagnitudeNumber]
  [@@by auto]
  [@@fc]


theorem block_op_map2_maximum_number_elems_ok x1 x2 =
  List.length x1 = List.length x2 ==>
  match (Float.block_op_map2_wop_binary Float.wMaximumNumber x1 x2) [@trigger] with
  | Ok r -> Result.is_ok (extract_error r)
  | Error _ -> false
  [@@disable Float.wMaximumNumber]
  [@@by auto]
  [@@fc]

theorem block_op_map2_fma_elems_ok x1 x2 x3 =
  List.length x1 = List.length x2 &&
  List.length x2 = List.length x3 ==>
  match (Float.block_op_map2_wop_ternary Float.wFMA x1 x2 x3) [@trigger] with
  | Ok r -> Result.is_ok (extract_error r)
  | Error _ -> false
  [@@disable Float.wFMA]
  [@@by auto]
  [@@fc]

theorem block_op_map2_faa_elems_ok x1 x2 x3 =
  List.length x1 = List.length x2 &&
  List.length x2 = List.length x3 ==>
  match (Float.block_op_map2_wop_ternary Float.wFAA x1 x2 x3) [@trigger] with
  | Ok r -> Result.is_ok (extract_error r)
  | Error _ -> false
  [@@disable Float.wFAA]
  [@@by auto]
  [@@fc]

theorem block_op_map2_wop_binary_preserves_length wop x1 x2 =
  List.length x1 = List.length x2 ==>
  match (Float.block_op_map2_wop_binary wop x1 x2) [@trigger] with
  | Ok r -> (
    match extract_error r with
    | Ok r -> List.length r = List.length x1
    | Error _ -> true
  )
  | Error _ -> false
  [@@by auto]
  [@@fc]

theorem block_op_map2_wop_ternary_preserves_length wop x1 x2 x3 =
  List.length x1 = List.length x2 &&
  List.length x2 = List.length x3 ==>
  match (Float.block_op_map2_wop_ternary wop x1 x2 x3) [@trigger] with
  | Ok r -> (
    match extract_error r with
    | Ok r -> List.length r = List.length x1
    | Error _ -> true
  )
  | Error _ -> false
  [@@by auto]
  [@@fc]

let block_preconditions_unary b f_sx f_x f_s f_z pi_s pi_z (s_x, x) s_z =
  let params = [{f_s = f_sx; f_x}] in
  let args = [{s = s_x; x}] in
  b >= 1 &&
  List.length params = List.length args &&
  List.length x = b &&
  equal_block_sizes b args
  [@@macro]

theorem block_abs_ok
  (b : int)
  (f_sx : Format.t) (f_x : Format.t)
  (f_s : Format.t)
  (f_z : Format.t)
  (pi_s : Projection.t)
  (pi_z : Projection.t)
  (s_x, x : Float.t * Float.t list)
  (s_z : Float.t) =
  block_preconditions_unary b f_sx f_x f_s f_z pi_s pi_z (s_x, x) s_z ==>
  Result.is_ok (Float.blockAbs b f_sx f_x f_s f_z pi_s pi_z (s_x, x) s_z)
  [@@timeout 3600]
  [@@disable
    Float.reduce, Float.wAbs, Float.map2_wMultiply,
    Float.wBlockDecode, Float.wProject, Format.parameters, List.map, List.map2,
    Float.wBlockProject, Float.block_op_map2_wop_unary]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]

theorem block_negate_ok
  (b : int)
  (f_sx : Format.t) (f_x : Format.t)
  (f_s : Format.t)
  (f_z : Format.t)
  (pi_s : Projection.t)
  (pi_z : Projection.t)
  (s_x, x : Float.t * Float.t list)
  (s_z : Float.t) =
  block_preconditions_unary b f_sx f_x f_s f_z pi_s pi_z (s_x, x) s_z ==>
  Result.is_ok (Float.blockNegate b f_sx f_x f_s f_z pi_s pi_z (s_x, x) s_z)
  [@@timeout 3600]
  [@@disable
    Float.reduce, Float.wNegate, Float.map2_wMultiply,
    Float.wBlockDecode, Float.wProject, Format.parameters, List.map, List.map2,
    Float.wBlockProject, Float.block_op_map2_wop_unary]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]

theorem block_exp_ok
  (b : int)
  (f_sx : Format.t) (f_x : Format.t)
  (f_s : Format.t)
  (f_z : Format.t)
  (pi_s : Projection.t)
  (pi_z : Projection.t)
  (s_x, x : Float.t * Float.t list)
  (s_z : Float.t) =
  block_preconditions_unary b f_sx f_x f_s f_z pi_s pi_z (s_x, x) s_z ==>
  Result.is_ok (Float.blockExp b f_sx f_x f_s f_z pi_s pi_z (s_x, x) s_z)
  [@@timeout 3600]
  [@@disable
    Float.reduce, Float.wExp, Float.map2_wMultiply,
    Float.wBlockDecode, Float.wProject, Format.parameters, List.map, List.map2,
    Float.wBlockProject, Float.block_op_map2_wop_unary]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]

theorem block_sqrt_ok
  (b : int)
  (f_sx : Format.t) (f_x : Format.t)
  (f_s : Format.t)
  (f_z : Format.t)
  (pi_s : Projection.t)
  (pi_z : Projection.t)
  (s_x, x : Float.t * Float.t list)
  (s_z : Float.t) =
  block_preconditions_unary b f_sx f_x f_s f_z pi_s pi_z (s_x, x) s_z ==>
  Result.is_ok (Float.blockSqrt b f_sx f_x f_s f_z pi_s pi_z (s_x, x) s_z)
  [@@timeout 3600]
  [@@disable
    Float.reduce, Float.wSqrt, Float.map2_wMultiply,
    Float.wBlockDecode, Float.wProject, Format.parameters, List.map, List.map2,
    Float.wBlockProject, Float.block_op_map2_wop_unary]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]

theorem block_rsqrt_ok
  (b : int)
  (f_sx : Format.t) (f_x : Format.t)
  (f_s : Format.t)
  (f_z : Format.t)
  (pi_s : Projection.t)
  (pi_z : Projection.t)
  (s_x, x : Float.t * Float.t list)
  (s_z : Float.t) =
  block_preconditions_unary b f_sx f_x f_s f_z pi_s pi_z (s_x, x) s_z ==>
  Result.is_ok (Float.blockRSqrt b f_sx f_x f_s f_z pi_s pi_z (s_x, x) s_z)
  [@@timeout 3600]
  [@@disable
    Float.reduce, Float.wRSqrt, Float.map2_wMultiply,
    Float.wBlockDecode, Float.wProject, Format.parameters, List.map, List.map2,
    Float.wBlockProject, Float.block_op_map2_wop_unary]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]

theorem block_exp2_ok
  (b : int)
  (f_sx : Format.t) (f_x : Format.t)
  (f_s : Format.t)
  (f_z : Format.t)
  (pi_s : Projection.t)
  (pi_z : Projection.t)
  (s_x, x : Float.t * Float.t list)
  (s_z : Float.t) =
  block_preconditions_unary b f_sx f_x f_s f_z pi_s pi_z (s_x, x) s_z ==>
  Result.is_ok (Float.blockExp2 b f_sx f_x f_s f_z pi_s pi_z (s_x, x) s_z)
  [@@timeout 3600]
  [@@disable
    Float.reduce, Float.wExp2, Float.map2_wMultiply,
    Float.wBlockDecode, Float.wProject, Format.parameters, List.map, List.map2,
    Float.wBlockProject, Float.block_op_map2_wop_unary]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]

theorem block_log2_ok
  (b : int)
  (f_sx : Format.t) (f_x : Format.t)
  (f_s : Format.t)
  (f_z : Format.t)
  (pi_s : Projection.t)
  (pi_z : Projection.t)
  (s_x, x : Float.t * Float.t list)
  (s_z : Float.t) =
  block_preconditions_unary b f_sx f_x f_s f_z pi_s pi_z (s_x, x) s_z ==>
  Result.is_ok (Float.blockLog2 b f_sx f_x f_s f_z pi_s pi_z (s_x, x) s_z)
  [@@timeout 3600]
  [@@disable
    Float.reduce, Float.wLog2, Float.map2_wMultiply,
    Float.wBlockDecode, Float.wProject, Format.parameters, List.map, List.map2,
    Float.wBlockProject, Float.block_op_map2_wop_unary]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]

theorem block_log_ok
  (b : int)
  (f_sx : Format.t) (f_x : Format.t)
  (f_s : Format.t)
  (f_z : Format.t)
  (pi_s : Projection.t)
  (pi_z : Projection.t)
  (s_x, x : Float.t * Float.t list)
  (s_z : Float.t) =
  block_preconditions_unary b f_sx f_x f_s f_z pi_s pi_z (s_x, x) s_z ==>
  Result.is_ok (Float.blockLog b f_sx f_x f_s f_z pi_s pi_z (s_x, x) s_z)
  [@@timeout 3600]
  [@@disable
    Float.reduce, Float.wLog, Float.map2_wMultiply,
    Float.wBlockDecode, Float.wProject, Format.parameters, List.map, List.map2,
    Float.wBlockProject, Float.block_op_map2_wop_unary]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]

theorem block_recip_ok
  (b : int)
  (f_sx : Format.t) (f_x : Format.t)
  (f_s : Format.t)
  (f_z : Format.t)
  (pi_s : Projection.t)
  (pi_z : Projection.t)
  (s_x, x : Float.t * Float.t list)
  (s_z : Float.t) =
  block_preconditions_unary b f_sx f_x f_s f_z pi_s pi_z (s_x, x) s_z ==>
  Result.is_ok (Float.blockRecip b f_sx f_x f_s f_z pi_s pi_z (s_x, x) s_z)
  [@@timeout 3600]
  [@@disable
    Float.reduce, Float.wRecip, Float.map2_wMultiply,
    Float.wBlockDecode, Float.wProject, Format.parameters, List.map, List.map2,
    Float.wBlockProject, Float.block_op_map2_wop_unary]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]

let block_preconditions_binary b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z =
  let params = [{f_s = f_sx1; f_x = f_x1}; {f_s = f_sx2; f_x = f_x2}] in
  let args = [{s = s_x1; x = x1}; {s = s_x2; x = x2}] in
  b >= 1 &&
  List.length params = List.length args &&
  List.length args = 2 &&
  List.length x1 = b && List.length x2 = b &&
  equal_block_sizes b args
  [@@macro]

let block_preconditions_ternary b f_sx1 f_x1 f_sx2 f_x2 f_sx3 f_x3 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) (s_x3, x3) s_z =
  let params = [{f_s = f_sx1; f_x = f_x1}; {f_s = f_sx2; f_x = f_x2}; {f_s = f_sx3; f_x = f_x3}] in
  let args = [{s = s_x1; x = x1}; {s = s_x2; x = x2}; {s = s_x3; x = x3}] in
  b >= 1 &&
  List.length params = List.length args &&
  List.length args = 3 &&
  List.length x1 = b && List.length x2 = b && List.length x3 = b &&
  equal_block_sizes b args
  [@@macro]

theorem block_CopySign_ok
  (b : int)
  (f_sx1 : Format.t) (f_x1 : Format.t)
  (f_sx2 : Format.t) (f_x2 : Format.t)
  (f_s : Format.t)
  (f_z : Format.t)
  (pi_s : Projection.t)
  (pi_z : Projection.t)
  (s_x1, x1 : Float.t * Float.t list)
  (s_x2, x2 : Float.t * Float.t list)
  (s_z : Float.t) =
  block_preconditions_binary b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z ==>
  Result.is_ok (Float.blockCopySign b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z)
  [@@timeout 3600]
  [@@disable
    Float.reduce, Float.wCopySign, Float.map2_wMultiply,
    Float.wBlockDecode, Float.wProject, Format.parameters, List.map, List.map2,
    Float.wBlockProject, Float.block_op_map2_wop_binary]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]

theorem block_add_ok
  (b : int)
  (f_sx1 : Format.t) (f_x1 : Format.t)
  (f_sx2 : Format.t) (f_x2 : Format.t)
  (f_s : Format.t)
  (f_z : Format.t)
  (pi_s : Projection.t)
  (pi_z : Projection.t)
  (s_x1, x1 : Float.t * Float.t list)
  (s_x2, x2 : Float.t * Float.t list)
  (s_z : Float.t) =
  block_preconditions_binary b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z ==>
  Result.is_ok (Float.blockAdd b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z)
  [@@timeout 3600]
  [@@disable
    Float.reduce, Float.wAdd, Float.map2_wMultiply,
    Float.wBlockDecode, Float.wProject, Format.parameters, List.map, List.map2,
    Float.wBlockProject, Float.block_op_map2_wop_binary]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]

theorem block_subtract_ok
  (b : int)
  (f_sx1 : Format.t) (f_x1 : Format.t)
  (f_sx2 : Format.t) (f_x2 : Format.t)
  (f_s : Format.t)
  (f_z : Format.t)
  (pi_s : Projection.t)
  (pi_z : Projection.t)
  (s_x1, x1 : Float.t * Float.t list)
  (s_x2, x2 : Float.t * Float.t list)
  (s_z : Float.t) =
  block_preconditions_binary b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z ==>
  Result.is_ok (Float.blockSubtract b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z)
  [@@timeout 3600]
  [@@disable
    Float.reduce, Float.wSubtract, Float.map2_wMultiply,
    Float.wBlockDecode, Float.wProject, Format.parameters, List.map, List.map2,
    Float.wBlockProject, Float.block_op_map2_wop_binary]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]

theorem block_multiply_ok
  (b : int)
  (f_sx1 : Format.t) (f_x1 : Format.t)
  (f_sx2 : Format.t) (f_x2 : Format.t)
  (f_s : Format.t)
  (f_z : Format.t)
  (pi_s : Projection.t)
  (pi_z : Projection.t)
  (s_x1, x1 : Float.t * Float.t list)
  (s_x2, x2 : Float.t * Float.t list)
  (s_z : Float.t) =
  block_preconditions_binary b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z ==>
  Result.is_ok (Float.blockMultiply b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z)
  [@@timeout 3600]
  [@@disable
    Float.reduce, Float.wMultiply, Float.map2_wMultiply,
    Float.wBlockDecode, Float.wProject, Format.parameters, List.map, List.map2,
    Float.wBlockProject, Float.block_op_map2_wop_binary]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]

theorem block_divide_ok
  (b : int)
  (f_sx1 : Format.t) (f_x1 : Format.t)
  (f_sx2 : Format.t) (f_x2 : Format.t)
  (f_s : Format.t)
  (f_z : Format.t)
  (pi_s : Projection.t)
  (pi_z : Projection.t)
  (s_x1, x1 : Float.t * Float.t list)
  (s_x2, x2 : Float.t * Float.t list)
  (s_z : Float.t) =
  block_preconditions_binary b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z ==>
  Result.is_ok (Float.blockDivide b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z)
  [@@timeout 3600]
  [@@disable
    Float.reduce, Float.wDivide, Float.map2_wMultiply,
    Float.wBlockDecode, Float.wProject, Format.parameters, List.map, List.map2,
    Float.wBlockProject, Float.block_op_map2_wop_binary]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]


theorem block_hypot_ok
  (b : int)
  (f_sx1 : Format.t) (f_x1 : Format.t)
  (f_sx2 : Format.t) (f_x2 : Format.t)
  (f_s : Format.t)
  (f_z : Format.t)
  (pi_s : Projection.t)
  (pi_z : Projection.t)
  (s_x1, x1 : Float.t * Float.t list)
  (s_x2, x2 : Float.t * Float.t list)
  (s_z : Float.t) =
  block_preconditions_binary b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z ==>
  Result.is_ok (Float.blockHypot b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z)
  [@@timeout 3600]
  [@@disable
    Float.reduce, Float.wHypot, Float.map2_wMultiply,
    Float.wBlockDecode, Float.wProject, Format.parameters, List.map, List.map2,
    Float.wBlockProject, Float.block_op_map2_wop_binary]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]

theorem block_minimum_ok
  (b : int)
  (f_sx1 : Format.t) (f_x1 : Format.t)
  (f_sx2 : Format.t) (f_x2 : Format.t)
  (f_s : Format.t)
  (f_z : Format.t)
  (pi_s : Projection.t)
  (pi_z : Projection.t)
  (s_x1, x1 : Float.t * Float.t list)
  (s_x2, x2 : Float.t * Float.t list)
  (s_z : Float.t) =
  block_preconditions_binary b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z ==>
  Result.is_ok (Float.blockMinimum b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z)
  [@@timeout 3600]
  [@@disable
    Float.reduce, Float.wMinimum, Float.map2_wMultiply,
    Float.wBlockDecode, Float.wProject, Format.parameters, List.map, List.map2,
    Float.wBlockProject, Float.block_op_map2_wop_binary]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]

theorem block_minimum_number_ok
  (b : int)
  (f_sx1 : Format.t) (f_x1 : Format.t)
  (f_sx2 : Format.t) (f_x2 : Format.t)
  (f_s : Format.t)
  (f_z : Format.t)
  (pi_s : Projection.t)
  (pi_z : Projection.t)
  (s_x1, x1 : Float.t * Float.t list)
  (s_x2, x2 : Float.t * Float.t list)
  (s_z : Float.t) =
  block_preconditions_binary b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z ==>
  Result.is_ok (Float.blockMinimumNumber b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z)
  [@@timeout 3600]
  [@@disable
    Float.reduce, Float.wMinimumNumber, Float.map2_wMultiply,
    Float.wBlockDecode, Float.wProject, Format.parameters, List.map, List.map2,
    Float.wBlockProject, Float.block_op_map2_wop_binary]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]

theorem block_minimum_magnitude_ok
  (b : int)
  (f_sx1 : Format.t) (f_x1 : Format.t)
  (f_sx2 : Format.t) (f_x2 : Format.t)
  (f_s : Format.t)
  (f_z : Format.t)
  (pi_s : Projection.t)
  (pi_z : Projection.t)
  (s_x1, x1 : Float.t * Float.t list)
  (s_x2, x2 : Float.t * Float.t list)
  (s_z : Float.t) =
  block_preconditions_binary b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z ==>
  Result.is_ok (Float.blockMinimumMagnitude b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z)
  [@@timeout 3600]
  [@@disable
    Float.reduce, Float.wMinimumMagnitude, Float.map2_wMultiply,
    Float.wBlockDecode, Float.wProject, Format.parameters, List.map, List.map2,
    Float.wBlockProject, Float.block_op_map2_wop_binary]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]

theorem block_minimum_magnitude_number_ok
  (b : int)
  (f_sx1 : Format.t) (f_x1 : Format.t)
  (f_sx2 : Format.t) (f_x2 : Format.t)
  (f_s : Format.t)
  (f_z : Format.t)
  (pi_s : Projection.t)
  (pi_z : Projection.t)
  (s_x1, x1 : Float.t * Float.t list)
  (s_x2, x2 : Float.t * Float.t list)
  (s_z : Float.t) =
  block_preconditions_binary b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z ==>
  Result.is_ok (Float.blockMinimumMagnitudeNumber b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z)
  [@@timeout 3600]
  [@@disable
    Float.reduce, Float.wMinimumMagnitudeNumber, Float.map2_wMultiply,
    Float.wBlockDecode, Float.wProject, Format.parameters, List.map, List.map2,
    Float.wBlockProject, Float.block_op_map2_wop_binary]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]

theorem block_maximum_ok
  (b : int)
  (f_sx1 : Format.t) (f_x1 : Format.t)
  (f_sx2 : Format.t) (f_x2 : Format.t)
  (f_s : Format.t)
  (f_z : Format.t)
  (pi_s : Projection.t)
  (pi_z : Projection.t)
  (s_x1, x1 : Float.t * Float.t list)
  (s_x2, x2 : Float.t * Float.t list)
  (s_z : Float.t) =
  block_preconditions_binary b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z ==>
  Result.is_ok (Float.blockMaximum b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z)
  [@@timeout 3600]
  [@@disable
    Float.reduce, Float.wMaximum, Float.map2_wMultiply,
    Float.wBlockDecode, Float.wProject, Format.parameters, List.map, List.map2,
    Float.wBlockProject, Float.block_op_map2_wop_binary]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]

theorem block_maximum_number_ok
  (b : int)
  (f_sx1 : Format.t) (f_x1 : Format.t)
  (f_sx2 : Format.t) (f_x2 : Format.t)
  (f_s : Format.t)
  (f_z : Format.t)
  (pi_s : Projection.t)
  (pi_z : Projection.t)
  (s_x1, x1 : Float.t * Float.t list)
  (s_x2, x2 : Float.t * Float.t list)
  (s_z : Float.t) =
  block_preconditions_binary b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z ==>
  Result.is_ok (Float.blockMaximumNumber b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z)
  [@@timeout 3600]
  [@@disable
    Float.reduce, Float.wMaximumNumber, Float.map2_wMultiply,
    Float.wBlockDecode, Float.wProject, Format.parameters, List.map, List.map2,
    Float.wBlockProject, Float.block_op_map2_wop_binary]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]

theorem block_maximum_magnitude_ok
  (b : int)
  (f_sx1 : Format.t) (f_x1 : Format.t)
  (f_sx2 : Format.t) (f_x2 : Format.t)
  (f_s : Format.t)
  (f_z : Format.t)
  (pi_s : Projection.t)
  (pi_z : Projection.t)
  (s_x1, x1 : Float.t * Float.t list)
  (s_x2, x2 : Float.t * Float.t list)
  (s_z : Float.t) =
  block_preconditions_binary b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z ==>
  Result.is_ok (Float.blockMaximumMagnitude b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z)
  [@@timeout 3600]
  [@@disable
    Float.reduce, Float.wMaximumMagnitude, Float.map2_wMultiply,
    Float.wBlockDecode, Float.wProject, Format.parameters, List.map, List.map2,
    Float.wBlockProject, Float.block_op_map2_wop_binary]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]

theorem block_maximum_magnitude_number_ok
  (b : int)
  (f_sx1 : Format.t) (f_x1 : Format.t)
  (f_sx2 : Format.t) (f_x2 : Format.t)
  (f_s : Format.t)
  (f_z : Format.t)
  (pi_s : Projection.t)
  (pi_z : Projection.t)
  (s_x1, x1 : Float.t * Float.t list)
  (s_x2, x2 : Float.t * Float.t list)
  (s_z : Float.t) =
  block_preconditions_binary b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z ==>
  Result.is_ok (Float.blockMaximumMagnitudeNumber b f_sx1 f_x1 f_sx2 f_x2 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) s_z)
  [@@timeout 3600]
  [@@disable
    Float.reduce, Float.wMaximumMagnitudeNumber, Float.map2_wMultiply,
    Float.wBlockDecode, Float.wProject, Format.parameters, List.map, List.map2,
    Float.wBlockProject, Float.block_op_map2_wop_binary]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]

theorem op_block_ternary_decoded_ok b params args =
  b >= 1 &&
  List.length params = List.length args &&
  List.length args = 3 &&
  equal_block_sizes b args
  ==>
  Result.is_ok (
    let*@ cxs = block_op_map2_wBlockDecode b params args in
    Ok (true))
  [@@disable extract_error, block_op_map2_wBlockDecode]
  [@@by
    [%use block_op_map2_wBlockDecode_ok b params args] @>
    [%use block_op_map2_wBlockDecode_elems_ok b params args] @>
    [%use block_op_map2_wBlockDecode_preserves_length b params args] @>
    [%use block_op_map2_wBlockDecode_preserves_block_size b params args] @>
    simplify ()
  ]

theorem op_block_ternary_decoded_lengths_equal b params args =
  b >= 1 &&
  List.length params = List.length args &&
  List.length args = 3 &&
  equal_block_sizes b args
  ==>
  match
    let*@ cxs = block_op_map2_wBlockDecode b params args in
    Ok (equal_list_lengths b cxs)
  with
  | Ok r -> r
  | _ -> false
  [@@disable extract_error, block_op_map2_wBlockDecode]
  [@@by
    [%use op_block_ternary_decoded_ok b params args] @>
    [%use block_op_map2_wBlockDecode_ok b params args] @>
    [%use block_op_map2_wBlockDecode_elems_ok b params args] @>
    [%use block_op_map2_wBlockDecode_preserves_length b params args] @>
    [%use block_op_map2_wBlockDecode_preserves_block_size b params args] @>
    simplify ()
  ]

theorem nth_r_preserves_block_size (b : int) (n : int) (xs : 'a list list) =
  equal_list_lengths b xs && 0 <= n && n < List.length xs ==>
  match nth_r n xs with
  | Ok r -> List.length r = b
  | _ -> false
  [@@by auto]

let decoded b params args =
  match block_op_map2_wBlockDecode b params args with
  | Ok r -> (match extract_error r with Ok r -> r | _ -> [])
  | _ -> []

theorem op_block_ternary_decoded_lengths b params args =
  b >= 1 &&
  List.length params = List.length args &&
  List.length args = 3 &&
  equal_block_sizes b args
  ==>
  match
    let*@ cxs = block_op_map2_wBlockDecode b params args in
    let* x1 = nth_r 0 cxs in
    let* x2 = nth_r 1 cxs in
    let* x3 = nth_r 2 cxs in
    Ok (List.length x1 = b && List.length x2 = b && List.length x3 = b)
  with
  | Ok r -> r
  | _ -> false
  [@@disable extract_error, block_op_map2_wBlockDecode, nth_r, List.length]
  [@@by
    [%use op_block_ternary_decoded_ok b params args] @>
    [%use block_op_map2_wBlockDecode_ok b params args] @>
    [%use block_op_map2_wBlockDecode_elems_ok b params args] @>
    [%use block_op_map2_wBlockDecode_preserves_length b params args] @>
    [%use block_op_map2_wBlockDecode_preserves_block_size b params args] @>
    [%use op_block_ternary_decoded_lengths_equal b params args] @>
    [%use nth_r_preserves_block_size b 0 (decoded b params args)] @>
    [%use nth_r_preserves_block_size b 1 (decoded b params args)] @>
    [%use nth_r_preserves_block_size b 2 (decoded b params args)] @>
    simplify ()
  ]

theorem op_block_ternary_fma_encode_ok
  (b : int)
  (params : Specification.Float.block_op_parameter list)
  (args : Specification.Float.block_op_argument list)
  (f_s : Format.t) (f_z : Format.t)
  (pi_z : Projection.t)
  (s_z : Float.t) =
  b >= 1 &&
  List.length params = List.length args &&
  List.length args = 3 &&
  equal_block_sizes b args
  ==>
  Result.is_ok (
    let*@ cxs = block_op_map2_wBlockDecode b params args in
    let* x1 = nth_r 0 cxs in
    let* x2 = nth_r 1 cxs in
    let* x3 = nth_r 2 cxs in
    let*@ cz = block_op_map2_wop_ternary wFMA x1 x2 x3 in
    let* z = wBlockProject b f_s f_z pi_z (s_z, cz) in
    Ok (s_z, z)
  )
  [@@disable extract_error, block_op_map2_wBlockDecode, nth_r, List.length, block_op_map2_wop_ternary, wBlockProject]
  [@@by
    [%use op_block_ternary_decoded_ok b params args] @>
    [%use block_op_map2_wBlockDecode_ok b params args] @>
    [%use block_op_map2_wBlockDecode_elems_ok b params args] @>
    [%use block_op_map2_wBlockDecode_preserves_length b params args] @>
    [%use block_op_map2_wBlockDecode_preserves_block_size b params args] @>
    [%use op_block_ternary_decoded_lengths_equal b params args] @>
    [%use nth_r_preserves_block_size b 0 (decoded b params args)] @>
    [%use nth_r_preserves_block_size b 1 (decoded b params args)] @>
    [%use nth_r_preserves_block_size b 2 (decoded b params args)] @>
    simplify ()
  ]


theorem block_fma_ok
  (b : int)
  (f_sx1 : Format.t) (f_x1 : Format.t)
  (f_sx2 : Format.t) (f_x2 : Format.t)
  (f_sx3 : Format.t) (f_x3 : Format.t)
  (f_s : Format.t)
  (f_z : Format.t)
  (pi_s : Projection.t)
  (pi_z : Projection.t)
  (s_x1, x1 : Float.t * Float.t list)
  (s_x2, x2 : Float.t * Float.t list)
  (s_x3, x3 : Float.t * Float.t list)
  (s_z : Float.t) =
  block_preconditions_ternary b f_sx1 f_x1 f_sx2 f_x2 f_sx3 f_x3 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) (s_x3, x3) s_z ==>
  Result.is_ok (Float.blockFMA b f_sx1 f_x1 f_sx2 f_x2 f_sx3 f_x3 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) (s_x3, x3) s_z)
  [@@timeout 3600]
  [@@disable extract_error, block_op_map2_wBlockDecode, nth_r, List.length, block_op_map2_wop_ternary, wBlockProject]
  [@@by
    [%use op_block_ternary_fma_encode_ok b
      [{f_s = f_sx1; f_x = f_x1}; {f_s = f_sx2; f_x = f_x2}; {f_s = f_sx3; f_x = f_x3}]
      [{s = s_x1; x = x1}; {s = s_x2; x = x2}; {s = s_x3; x = x3}]
      f_s f_z pi_z s_z
    ] @>
    induct ~do_not:["gen"; "fert"; "delim"] ()
  ]

theorem op_block_ternary_faa_encode_ok
  (b : int)
  (params : Specification.Float.block_op_parameter list)
  (args : Specification.Float.block_op_argument list)
  (f_s : Format.t) (f_z : Format.t)
  (pi_z : Projection.t)
  (s_z : Float.t) =
  b >= 1 &&
  List.length params = List.length args &&
  List.length args = 3 &&
  equal_block_sizes b args
  ==>
  Result.is_ok (
    let*@ cxs = block_op_map2_wBlockDecode b params args in
    let* x1 = nth_r 0 cxs in
    let* x2 = nth_r 1 cxs in
    let* x3 = nth_r 2 cxs in
    let*@ cz = block_op_map2_wop_ternary wFAA x1 x2 x3 in
    let* z = wBlockProject b f_s f_z pi_z (s_z, cz) in
    Ok (s_z, z)
  )
  [@@disable extract_error, block_op_map2_wBlockDecode, nth_r, List.length, block_op_map2_wop_ternary, wBlockProject]
  [@@by
    [%use op_block_ternary_decoded_ok b params args] @>
    [%use block_op_map2_wBlockDecode_ok b params args] @>
    [%use block_op_map2_wBlockDecode_elems_ok b params args] @>
    [%use block_op_map2_wBlockDecode_preserves_length b params args] @>
    [%use block_op_map2_wBlockDecode_preserves_block_size b params args] @>
    [%use op_block_ternary_decoded_lengths_equal b params args] @>
    [%use nth_r_preserves_block_size b 0 (decoded b params args)] @>
    [%use nth_r_preserves_block_size b 1 (decoded b params args)] @>
    [%use nth_r_preserves_block_size b 2 (decoded b params args)] @>
    simplify ()
  ]

theorem block_faa_ok
  (b : int)
  (f_sx1 : Format.t) (f_x1 : Format.t)
  (f_sx2 : Format.t) (f_x2 : Format.t)
  (f_sx3 : Format.t) (f_x3 : Format.t)
  (f_s : Format.t)
  (f_z : Format.t)
  (pi_s : Projection.t)
  (pi_z : Projection.t)
  (s_x1, x1 : Float.t * Float.t list)
  (s_x2, x2 : Float.t * Float.t list)
  (s_x3, x3 : Float.t * Float.t list)
  (s_z : Float.t) =
  block_preconditions_ternary b f_sx1 f_x1 f_sx2 f_x2 f_sx3 f_x3 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) (s_x3, x3) s_z ==>
  Result.is_ok (Float.blockFAA b f_sx1 f_x1 f_sx2 f_x2 f_sx3 f_x3 f_s f_z pi_s pi_z (s_x1, x1) (s_x2, x2) (s_x3, x3) s_z)
  [@@timeout 3600]
  [@@disable extract_error, block_op_map2_wBlockDecode, nth_r, List.length, block_op_map2_wop_ternary, wBlockProject]
  [@@by
    [%use op_block_ternary_faa_encode_ok b
      [{f_s = f_sx1; f_x = f_x1}; {f_s = f_sx2; f_x = f_x2}; {f_s = f_sx3; f_x = f_x3}]
      [{s = s_x1; x = x1}; {s = s_x2; x = x2}; {s = s_x3; x = x3}]
      f_s f_z pi_z s_z
    ] @>
    induct ~do_not:["gen"; "fert"; "delim"] ()
  ]

theorem block_reduce_add_ok (b : int) (f_sx : Format.t) (f_x : Format.t) (f_z : Format.t) (pi_z : Projection.t) (s_x, x : t * t list) =
  b >= 1 && List.length x = b ==>
  Result.is_ok (Float.blockReduceAdd b f_sx f_x f_z pi_z (s_x, x))
  [@@timeout 3600]
  [@@disable extract_error, wBlockDecode, nth_r, wBlockProject, wAdd, List.length, wProject, reduce_wAdd]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]

theorem reduce_wMultiply_ok (x : CER.t list) =
  List.length x >= 2 ==> Result.is_ok ((reduce Float.wMultiply x) [@trigger])
  [@@by auto]
  [@@fc]

theorem reduce_wMultiply_confl_ok (x : CER.t list) =
  List.length x >= 1 ==> Result.is_ok ((reduce_wMultiply x) [@trigger])
  [@@by auto]
  [@@fc]

theorem block_reduce_multiply_ok (b : int) (f_sx : Format.t) (f_x : Format.t) (f_z : Format.t) (pi_z : Projection.t) (s_x, x : t * t list) =
  b >= 1 && List.length x = b ==>
  Result.is_ok (Float.blockReduceMultiply b f_sx f_x f_z pi_z (s_x, x))
  [@@timeout 3600]
  [@@disable extract_error, wBlockDecode, nth_r, wBlockProject, wMultiply, List.length, wProject, reduce_wMultiply]
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]

theorem block_op_map2_wop_binary_preserves_block_size
  (wOp : CER.t -> CER.t -> (CER.t, string) Result.t)
  (x : CER.t list)
  (y : CER.t list) =
  List.length x = List.length y
  ==>
  match (block_op_map2_wop_binary wOp x y) [@trigger] with
  | Ok r -> (
    match extract_error r with
    | Ok mapped -> List.length mapped = List.length x
    | Error _ -> true)
  | Error _ -> false
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]
  [@@fc]

theorem block_op_binary_preserves_block_size
  (b : int)
  (params : block_op_parameter list)
  (f_s : Format.t)
  (f_z : Format.t)
  (s_z : t)
  (pi_z : Projection.t)
  (args: block_op_argument list)
  (wOp : CER.t -> CER.t -> (CER.t, string) Result.t) =
  b >= 1 &&
  List.length params = List.length args &&
  List.length args = 2 &&
  List.for_all (fun a_i -> List.length a_i.x = b) args
  ==>
  match ((Float.block_op_binary b params f_s f_z s_z pi_z args wOp) [@trigger]) with
  | Ok (_, r) -> List.length r = b
  | _ -> true
  [@@timeout 3600]
  [@@disable
    wProject, Format.parameters, List.map, List.map2,
    reduce, wBlockDecode, wBlockProject, block_op_map2_wop_binary,
    block_op_map2_wBlockDecode]
  (* nondet? *)
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]
  [@@fc]

let one (f : Format.t) = match wEncode f CER.one with Ok r -> r | _ -> nan f

let is_in_value_set (f : Format.t) (x : CER.t) =
  match
    let* e = wEncode f x in
    let d = wDecode f e in
    Ok (d = x)
  with
  | Ok r -> r
  | _ -> false

(* All except a few of our formats have 1.0 in their value set. *)
theorem one_in_value_set (f : Format.t) =
  let k, p, _, _, _, s, d = Format.parameters f in
  match k, p, d, s with
  | 2, 1, Extended, _ -> true
  | 2, 2, Extended, _ -> true
  | 2, 2, Finite, Signed -> true
  | _ -> is_in_value_set f CER.one
  [@@timeout 3600]
  [@@by enumerate ["f"] @> ground_eval ()]

(* Scaled addition via a block of size 1 is okay as long as the output format has 1.0 in it's value set. *)
theorem internal_scaled_add_ok f_x f_y f_z pi x s_x y s_y =
  is_in_value_set f_z CER.one ==>
  Result.is_ok (Float.internal_scaledAdd f_x f_y f_z pi x s_x y s_y)
  [@@timeout 3600]
  [@@disable
    wProject, Format.parameters, List.map, List.map2,
    reduce, wBlockDecode, wBlockProject, block_op_map2_wop_binary,
    block_op_map2_wBlockDecode,
    wEncode, wDecode, Util.pow2, Util.ipow2, blockAdd]
  [@@by
    [%use block_add_ok 1 f_x f_x f_y f_y f_z f_z pi pi (s_x, [x]) (s_y, [y]) (one f_z)] @>
    induct ~do_not:["gen"; "fert"; "delim"] ()
  ]

(* Scaled multiplication via a block of size 1 is okay as long as the output format has 1.0 in it's value set. *)
theorem internal_scaled_multiply_ok f_x f_y f_z pi x s_x y s_y =
  is_in_value_set f_z CER.one ==>
  Result.is_ok (Float.internal_scaledMultiply f_x f_y f_z pi x s_x y s_y)
  [@@timeout 3600]
  [@@disable
    wProject, Format.parameters, List.map, List.map2,
    reduce, wBlockDecode, wBlockProject, block_op_map2_wop_binary,
    block_op_map2_wBlockDecode,
    wEncode, wDecode, Util.pow2, Util.ipow2, blockMultiply]
  [@@by
    [%use block_multiply_ok 1 f_x f_x f_y f_y f_z f_z pi pi (s_x, [x]) (s_y, [y]) (one f_z)] @>
    induct ~do_not:["gen"; "fert"; "delim"] ()
  ]

theorem block_op_ternary_preserves_block_size
  (b : int)
  (params : block_op_parameter list)
  (f_s : Format.t)
  (f_z : Format.t)
  (s_z : t)
  (pi_z : Projection.t)
  (args: block_op_argument list)
  (wOp : CER.t -> CER.t -> CER.t -> (CER.t, string) Result.t) =
  b >= 1 &&
  List.length params = List.length args &&
  List.length args = 3 &&
  List.for_all (fun a_i -> List.length a_i.x = b) args
  ==>
  match ((Float.block_op_ternary b params f_s f_z s_z pi_z args wOp) [@trigger]) with
  | Ok (_, r) -> List.length r = b
  | _ -> true
  [@@timeout 3600]
  [@@disable
    wProject, Format.parameters, List.map, List.map2,
    reduce, wBlockDecode, wBlockProject, block_op_map2_wop_ternary,
    block_op_map2_wBlockDecode]
  (* nondet? *)
  [@@by induct ~do_not:["gen"; "fert"; "delim"] ()]
  [@@fc]

(* Scaled FMA via a block of size 1 is okay as long as the output format has 1.0 in it's value set. *)
theorem internal_scaled_fma_ok f_x f_y f_sxy f_z f_sz f_r pi x y s_xy z s_z =
  is_in_value_set f_r CER.one ==>
  Result.is_ok (Float.internal_scaledFMA f_x f_y f_sxy f_z f_sz f_r pi x y s_xy z s_z)
  [@@timeout 3600]
  [@@disable
    wProject, Format.parameters, List.map, List.map2,
    reduce, wBlockDecode, wBlockProject, block_op_map2_wop_ternary,
    block_op_map2_wBlockDecode,
    wEncode, wDecode, Util.pow2, Util.ipow2, blockFMA]
  (* nondet? *)
  [@@by
    [%use block_fma_ok 1 f_sxy f_x f_sxy f_y f_sz f_z f_r f_r pi pi (s_xy, [x]) (s_xy, [y]) (s_z, [z]) (one f_r)] @>
    induct ~do_not:["gen"; "fert"; "delim"] ()
  ]

  *)