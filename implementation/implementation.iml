(** For spec see https://github.com/P3109/Public *)

[@@@import Specification, "dune:specification"]

(** Format definitions *)

module Format = struct
  type t = Specification.Format.t
end

(** Rounding mode definitions *)

module RoundingMode = struct
  type t = Specification.RoundingMode.t
end

(** 8-bit Floating-point numbers *)

module Float = struct
  (* Type definition. Our implementation supports only 8-bit formats. *)
  type t = { b7 : bool; b6 : bool; b5 : bool; b4 : bool; b3 : bool; b2 : bool; b1 : bool; b0 : bool }

  (** Constants *)

  let nan (_ : Format.t) : t = { b7 = true; b6 = false; b5 = false; b4 = false; b3 = false; b2 = false; b1 = false; b0 = false; } [@@ocamlformat "disable"]
  let ninf (_ : Format.t) : t = { b7 = true; b6 = true; b5 = true; b4 = true; b3 = true; b2 = true; b1 = true; b0 = true; } [@@ocamlformat "disable"]
  let pinf (_ : Format.t) : t = { b7 = false; b6 = true; b5 = true; b4 = true; b3 = true; b2 = true; b1 = true; b0 = true; } [@@ocamlformat "disable"]
  let zero (_ : Format.t) : t = { b7 = false; b6 = false; b5 = false; b4 = false; b3 = false; b2 = false; b1 = false; b0 = false; } [@@ocamlformat "disable"]

  (** Classification predicates *)

  let isZero (_f : Format.t) (x : t) : bool =
    not x.b7 && not x.b6 && not x.b5 && not x.b4 && not x.b3 && not x.b2 && not x.b1 && not x.b0 [@@macro]

  let isOne (f : Format.t) (x : t) : bool =
    let open Specification.Format in
    not x.b7 &&
    match f.kp with
    | B8P1 -> not x.b6 && x.b5 && x.b4 && x.b3 && x.b2 && x.b1 && x.b0
    | _ -> x.b6 && not x.b5 && not x.b4 && not x.b3 && not x.b2 && not x.b1 && not x.b0

  let isNaN (_f : Format.t) (x : t) : bool =
    x.b7 && not x.b6 && not x.b5 && not x.b4 && not x.b3 && not x.b2 && not x.b1 && not x.b0 [@@macro]

  let isInfinite (f : Format.t) (x : t) : bool = x = ninf f || x = pinf f [@@macro]

  let isFinite (f : Format.t) (x : t) : bool = not (isInfinite f x) && not (isNaN f x) [@@macro]

  let isNormal (f : Format.t) (x : t) : bool =
    let open Specification.Format in
    isFinite f x
    &&
    match f.kp with
    | B8P1 -> x.b6 || x.b5 || x.b4 || x.b3 || x.b2 || x.b1 || x.b0
    | B8P2 -> x.b6 || x.b5 || x.b4 || x.b3 || x.b2 || x.b1
    | B8P3 -> x.b6 || x.b5 || x.b4 || x.b3 || x.b2
    | B8P4 -> x.b6 || x.b5 || x.b4 || x.b3
    | B8P5 -> x.b6 || x.b5 || x.b4
    | B8P6 -> x.b6 || x.b5
    | B8P7 -> x.b6
    | _ -> false

  let isSubnormal (f : Format.t)  (x : t) : bool =
    let open Specification.Format in
    isFinite f x && not (isZero f x)
    &&
    match f.kp with
    | B8P1 -> not x.b6 && not x.b5 && not x.b4 && not x.b3 && not x.b2 && not x.b1 && not x.b0
    | B8P2 -> not x.b6 && not x.b5 && not x.b4 && not x.b3 && not x.b2 && not x.b1
    | B8P3 -> not x.b6 && not x.b5 && not x.b4 && not x.b3 && not x.b2
    | B8P4 -> not x.b6 && not x.b5 && not x.b4 && not x.b3
    | B8P5 -> not x.b6 && not x.b5 && not x.b4
    | B8P6 -> not x.b6 && not x.b5
    | B8P7 -> not x.b6
    | _ -> false

  let isSignMinus (_f : Format.t) (x : t) : bool = x.b7

  (** Classifier *)

  type class_ = Specification.Float.class_

  let class_ (f : Format.t) (x : t) : class_ =
      if isNaN f x then NaN
      else if isInfinite f x && isSignMinus f x then NegativeInfinity
      else if isNormal f x && isSignMinus f x then NegativeNormal
      else if isSubnormal f x && isSignMinus f x then NegativeSubnormal
      else if isZero f x then Zero
      else if isSubnormal f x && not (isSignMinus f x) then PositiveSubnormal
      else if isNormal f x && not (isSignMinus f x) then PositiveNormal
      else if isInfinite f x && not (isSignMinus f x) then PositiveInfinity
      else NaN (* unreachable *)

  (** Operations *)

  let abs (f : Format.t) (x : t) : t =
    if isNaN f x then x
    else
      {
        b7 = false;
        b6 = x.b6;
        b5 = x.b5;
        b4 = x.b4;
        b3 = x.b3;
        b2 = x.b2;
        b1 = x.b1;
        b0 = x.b0;
      }

  let negate (f : Format.t) (x : t) : t =
    if isNaN f x || isZero f x then x
    else
      {
        b7 = not x.b7;
        b6 = x.b6;
        b5 = x.b5;
        b4 = x.b4;
        b3 = x.b3;
        b2 = x.b2;
        b1 = x.b1;
        b0 = x.b0;
      }
    [@@macro]

  let i2s (x : t) =
      (if x.b0 then 1 else 0)
    + (if x.b1 then 2 else 0)
    + (if x.b2 then 4 else 0)
    + (if x.b3 then 8 else 0)
    + (if x.b4 then 16 else 0)
    + (if x.b5 then 32 else 0)
    + (if x.b6 then 64 else 0)
    + (if x.b7 then 128 else 0)

  let to_string (f : Format.t) (x : t) =
    let bool_to_bin x = if x then "1" else "0" in
    Printf.sprintf "%s%s%s%s%s%s%s%s = %s" (bool_to_bin x.b7) (bool_to_bin x.b6)
      (bool_to_bin x.b5) (bool_to_bin x.b4) (bool_to_bin x.b3)
      (bool_to_bin x.b2) (bool_to_bin x.b1) (bool_to_bin x.b0)
      (Math.CER.to_string (Specification.Float.wDecode f (i2s x)))
      [@@ocamlformat "if-then-else=compact"] [@@program]

  [@@program]

end
